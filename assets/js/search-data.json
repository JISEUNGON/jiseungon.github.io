{"0": {
    "doc": "3-Way Handshake",
    "title": "3-Way Handshake",
    "content": " ",
    "url": "/docs/network/3way-handshake.html",
    
    "relUrl": "/docs/network/3way-handshake.html"
  },"1": {
    "doc": "3-Way Handshake",
    "title": "개요",
    "content": "3-Way Handshake는 TCP(Transmission Control Protocol)에서 클라이언트와 서버 간의 연결을 설정하는 과정입니다. 이 과정을 통해 양쪽 모두 연결 준비가 완료되었음을 확인하고, 신뢰성 있는 통신을 시작할 수 있습니다. 주요 목적 . | 연결 설정: 클라이언트와 서버 간의 TCP 연결을 설정 | 시퀀스 번호 동기화: 데이터 전송을 위한 시퀀스 번호를 동기화 | 신뢰성 보장: 양쪽 모두 연결 준비가 완료되었음을 확인 | 보안: 연결 요청의 유효성을 검증 | . ",
    "url": "/docs/network/3way-handshake.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/network/3way-handshake.html#개요"
  },"2": {
    "doc": "3-Way Handshake",
    "title": "3-Way Handshake 과정",
    "content": "sequenceDiagram participant Client as 클라이언트 participant Server as 서버 Note over Client,Server: 1단계: SYN 전송 Client-&gt;&gt;Server: SYN (seq=x) Note over Client: SYN_SENT 상태 Note over Client,Server: 2단계: SYN+ACK 전송 Server-&gt;&gt;Client: SYN+ACK (seq=y, ack=x+1) Note over Server: SYN_RECEIVED 상태 Note over Client,Server: 3단계: ACK 전송 Client-&gt;&gt;Server: ACK (ack=y+1) Note over Client: ESTABLISHED 상태 Note over Server: ESTABLISHED 상태 . ",
    "url": "/docs/network/3way-handshake.html#3-way-handshake-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/network/3way-handshake.html#3-way-handshake-과정"
  },"3": {
    "doc": "3-Way Handshake",
    "title": "상세 과정 설명",
    "content": "1단계: SYN (Synchronize) 전송 . graph LR A[클라이언트] --&gt;|SYN seq=x| B[서버] subgraph \"클라이언트 상태\" C[CLOSED → SYN_SENT] end subgraph \"서버 상태\" D[LISTEN] end . 클라이언트 동작: . | 서버에 연결 요청을 보내기 위해 SYN 패킷을 전송 | 시퀀스 번호(seq)를 랜덤하게 생성하여 포함 | 상태를 SYN_SENT로 변경 | . 패킷 정보: . SYN 플래그: 1 시퀀스 번호: x (랜덤 값) ACK 번호: 0 . 2단계: SYN+ACK 전송 . graph LR A[클라이언트] --&gt;|SYN seq=x| B[서버] B --&gt;|SYN+ACK seq=y, ack=x+1| A subgraph \"클라이언트 상태\" C[SYN_SENT → ESTABLISHED] end subgraph \"서버 상태\" D[LISTEN → SYN_RECEIVED] end . 서버 동작: . | 클라이언트의 SYN 패킷을 받고 연결 요청을 수락 | 자신의 시퀀스 번호(seq=y)를 생성 | 클라이언트의 시퀀스 번호에 1을 더한 값(ack=x+1)을 ACK 번호로 설정 | SYN과 ACK 플래그를 모두 설정한 패킷을 전송 | 상태를 SYN_RECEIVED로 변경 | . 패킷 정보: . SYN 플래그: 1 ACK 플래그: 1 시퀀스 번호: y (랜덤 값) ACK 번호: x+1 . 3단계: ACK 전송 . graph LR A[클라이언트] --&gt;|SYN seq=x| B[서버] B --&gt;|SYN+ACK seq=y, ack=x+1| A A --&gt;|ACK ack=y+1| B subgraph \"클라이언트 상태\" C[SYN_SENT → ESTABLISHED] end subgraph \"서버 상태\" D[SYN_RECEIVED → ESTABLISHED] end . 클라이언트 동작: . | 서버의 SYN+ACK 패킷을 받고 연결 설정을 완료 | 서버의 시퀀스 번호에 1을 더한 값(ack=y+1)을 ACK 번호로 설정 | ACK 패킷을 전송하여 연결 설정 완료를 알림 | 상태를 ESTABLISHED로 변경 | . 패킷 정보: . SYN 플래그: 0 ACK 플래그: 1 시퀀스 번호: x+1 ACK 번호: y+1 . ",
    "url": "/docs/network/3way-handshake.html#%EC%83%81%EC%84%B8-%EA%B3%BC%EC%A0%95-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/network/3way-handshake.html#상세-과정-설명"
  },"4": {
    "doc": "3-Way Handshake",
    "title": "TCP 상태 변화",
    "content": "stateDiagram-v2 [*] --&gt; CLOSED CLOSED --&gt; LISTEN : 서버 시작 CLOSED --&gt; SYN_SENT : 클라이언트 연결 요청 SYN_SENT --&gt; ESTABLISHED : SYN+ACK 수신 후 ACK 전송 LISTEN --&gt; SYN_RECEIVED : SYN 수신 SYN_RECEIVED --&gt; ESTABLISHED : ACK 수신 ESTABLISHED --&gt; [*] : 연결 종료 . ",
    "url": "/docs/network/3way-handshake.html#tcp-%EC%83%81%ED%83%9C-%EB%B3%80%ED%99%94",
    
    "relUrl": "/docs/network/3way-handshake.html#tcp-상태-변화"
  },"5": {
    "doc": "3-Way Handshake",
    "title": "시퀀스 번호의 역할",
    "content": "1. 데이터 순서 보장 . 클라이언트 → 서버: seq=1000, 데이터=\"Hello\" 서버 → 클라이언트: ack=1005 (1000+5) . 2. 중복 패킷 감지 . | 동일한 시퀀스 번호의 패킷이 다시 오면 중복으로 판단 | 네트워크 지연이나 재전송으로 인한 중복 패킷을 필터링 | . 3. 데이터 무결성 검증 . | 시퀀스 번호를 통해 데이터 손실을 감지 | 누락된 데이터를 재전송 요청 | . ",
    "url": "/docs/network/3way-handshake.html#%EC%8B%9C%ED%80%80%EC%8A%A4-%EB%B2%88%ED%98%B8%EC%9D%98-%EC%97%AD%ED%95%A0",
    
    "relUrl": "/docs/network/3way-handshake.html#시퀀스-번호의-역할"
  },"6": {
    "doc": "3-Way Handshake",
    "title": "실제 예시",
    "content": "웹 브라우저 접속 과정 . sequenceDiagram participant Browser as 웹 브라우저 participant WebServer as 웹 서버 Note over Browser,WebServer: 1. SYN 전송 Browser-&gt;&gt;WebServer: SYN (seq=12345) Note over Browser,WebServer: 2. SYN+ACK 전송 WebServer-&gt;&gt;Browser: SYN+ACK (seq=67890, ack=12346) Note over Browser,WebServer: 3. ACK 전송 Browser-&gt;&gt;WebServer: ACK (ack=67891) Note over Browser,WebServer: 연결 설정 완료 Browser-&gt;&gt;WebServer: HTTP GET 요청 WebServer-&gt;&gt;Browser: HTTP 응답 . ",
    "url": "/docs/network/3way-handshake.html#%EC%8B%A4%EC%A0%9C-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/network/3way-handshake.html#실제-예시"
  },"7": {
    "doc": "3-Way Handshake",
    "title": "보안 관점에서의 3-Way Handshake",
    "content": "1. SYN Flooding 공격 . 공격자 → 서버: SYN (seq=랜덤) 서버 → 공격자: SYN+ACK (seq=y, ack=랜덤+1) 공격자: ACK 응답 없음 (서버 리소스 소모) . 2. 방어 방법 . | SYN Cookie: 서버가 SYN+ACK에 특별한 값을 포함 | Connection Limiting: 동시 연결 수 제한 | Firewall: 의심스러운 패킷 필터링 | . ",
    "url": "/docs/network/3way-handshake.html#%EB%B3%B4%EC%95%88-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C%EC%9D%98-3-way-handshake",
    
    "relUrl": "/docs/network/3way-handshake.html#보안-관점에서의-3-way-handshake"
  },"8": {
    "doc": "3-Way Handshake",
    "title": "4-Way Handshake (연결 종료)",
    "content": "sequenceDiagram participant Client as 클라이언트 participant Server as 서버 Note over Client,Server: 1단계: FIN 전송 Client-&gt;&gt;Server: FIN (seq=x) Note over Client,Server: 2단계: ACK 전송 Server-&gt;&gt;Client: ACK (ack=x+1) Note over Client,Server: 3단계: FIN 전송 Server-&gt;&gt;Client: FIN (seq=y) Note over Client,Server: 4단계: ACK 전송 Client-&gt;&gt;Server: ACK (ack=y+1) . ",
    "url": "/docs/network/3way-handshake.html#4-way-handshake-%EC%97%B0%EA%B2%B0-%EC%A2%85%EB%A3%8C",
    
    "relUrl": "/docs/network/3way-handshake.html#4-way-handshake-연결-종료"
  },"9": {
    "doc": "3-Way Handshake",
    "title": "주의사항",
    "content": "1. 타임아웃 . | 각 단계에서 응답이 없으면 타임아웃 발생 | 클라이언트는 SYN 재전송 시도 | 서버는 SYN+ACK 재전송 시도 | . 2. 네트워크 지연 . | 네트워크 상황에 따라 패킷 전송 지연 가능 | 적절한 타임아웃 설정 필요 | . 3. 방화벽 설정 . | 일부 방화벽에서 SYN 패킷 차단 가능 | 방화벽 규칙 확인 필요 | . ",
    "url": "/docs/network/3way-handshake.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/network/3way-handshake.html#주의사항"
  },"10": {
    "doc": "3-Way Handshake",
    "title": "결론",
    "content": "3-Way Handshake는 TCP 연결의 핵심 과정으로, 신뢰성 있는 통신을 위한 필수적인 단계입니다. 이 과정을 통해 클라이언트와 서버는 서로의 존재를 확인하고, 데이터 전송을 위한 준비를 완료합니다. 네트워크 프로그래밍이나 시스템 관리 시 이 과정을 이해하는 것이 중요합니다. ",
    "url": "/docs/network/3way-handshake.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/network/3way-handshake.html#결론"
  },"11": {
    "doc": "Spring boot gateway",
    "title": "Spring API Gateway &amp; WebFlux",
    "content": " ",
    "url": "/docs/spring/api-gateway-webflux.html#spring-api-gateway--webflux",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#spring-api-gateway--webflux"
  },"12": {
    "doc": "Spring boot gateway",
    "title": "개요",
    "content": "Spring Cloud Gateway는 Spring Cloud 생태계의 API Gateway로, Spring WebFlux를 기반으로 구축되어 비동기 논블로킹 방식으로 동작합니다. 이 문서에서는 Spring API Gateway의 구조와 WebFlux의 핵심 개념을 다이어그램과 함께 상세히 설명합니다. ",
    "url": "/docs/spring/api-gateway-webflux.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#개요"
  },"13": {
    "doc": "Spring boot gateway",
    "title": "Spring Cloud Gateway 아키텍처",
    "content": "1. 전체 시스템 구조 . graph TB Client[클라이언트] --&gt; Gateway[Spring Cloud Gateway] Gateway --&gt; Route1[Route 1: /api/users] Gateway --&gt; Route2[Route 2: /api/orders] Gateway --&gt; Route3[Route 3: /api/products] Route1 --&gt; Service1[User Service] Route2 --&gt; Service2[Order Service] Route3 --&gt; Service3[Product Service] subgraph \"Gateway Components\" Gateway --&gt; Predicate[Predicate] Gateway --&gt; Filter[Filter] Gateway --&gt; LoadBalancer[Load Balancer] end subgraph \"WebFlux Core\" WebFlux[WebFlux Engine] Netty[Netty Server] EventLoop[Event Loop] end Gateway --&gt; WebFlux WebFlux --&gt; Netty Netty --&gt; EventLoop . 2. Gateway 핵심 컴포넌트 . graph LR Request[HTTP Request] --&gt; Predicate[Predicate&lt;br/&gt;요청 조건 확인] Predicate --&gt; Filter[Filter&lt;br/&gt;요청/응답 처리] Filter --&gt; Route[Route&lt;br/&gt;라우팅 결정] Route --&gt; Target[Target Service] subgraph \"Predicate Types\" Path[Path Predicate] Method[Method Predicate] Header[Header Predicate] Query[Query Predicate] end subgraph \"Filter Types\" Pre[Pre Filter] Post[Post Filter] Global[Global Filter] Gateway[Gateway Filter] end . ",
    "url": "/docs/spring/api-gateway-webflux.html#spring-cloud-gateway-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#spring-cloud-gateway-아키텍처"
  },"14": {
    "doc": "Spring boot gateway",
    "title": "WebFlux 핵심 개념",
    "content": "1. Reactive Streams 구조 . graph TB Publisher[Publisher&lt;br/&gt;데이터 발행자] --&gt; Subscriber[Subscriber&lt;br/&gt;데이터 구독자] Publisher --&gt; Subscription[Subscription&lt;br/&gt;구독 관계] Subscription --&gt; Subscriber subgraph \"Reactive Streams\" Mono[Mono&lt;T&gt;&lt;br/&gt;0 또는 1개 요소] Flux[Flux&lt;T&gt;&lt;br/&gt;0개 이상의 요소] end Publisher --&gt; Mono Publisher --&gt; Flux . 2. WebFlux 이벤트 루프 모델 . graph TB Request[HTTP Request] --&gt; EventLoop[Event Loop Thread] subgraph \"Event Loop\" Accept[Accept Event] Read[Read Event] Process[Process Event] Write[Write Event] end EventLoop --&gt; Accept Accept --&gt; Read Read --&gt; Process Process --&gt; Write Write --&gt; Response[HTTP Response] subgraph \"Non-blocking I/O\" NIO[NIO Channels] Selector[Selector] end EventLoop --&gt; NIO NIO --&gt; Selector . ",
    "url": "/docs/spring/api-gateway-webflux.html#webflux-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#webflux-핵심-개념"
  },"15": {
    "doc": "Spring boot gateway",
    "title": "Spring Cloud Gateway 설정 예제",
    "content": "1. 기본 라우팅 설정 . spring: cloud: gateway: routes: - id: user-service uri: lb://user-service predicates: - Path=/api/users/** filters: - StripPrefix=1 - AddRequestHeader=X-Response-Time, {response_time} - id: order-service uri: lb://order-service predicates: - Path=/api/orders/** - Method=GET,POST filters: - CircuitBreaker=orderCircuitBreaker - Retry=3 . 2. 커스텀 필터 구현 . @Component public class CustomGlobalFilter implements GlobalFilter, Ordered { @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); String path = request.getPath().value(); // 요청 로깅 log.info(\"Request: {} {}\", request.getMethod(), path); return chain.filter(exchange) .then(Mono.fromRunnable(() -&gt; { ServerHttpResponse response = exchange.getResponse(); log.info(\"Response: {} {}\", response.getStatusCode(), path); })); } @Override public int getOrder() { return -1; // 높은 우선순위 } } . ",
    "url": "/docs/spring/api-gateway-webflux.html#spring-cloud-gateway-%EC%84%A4%EC%A0%95-%EC%98%88%EC%A0%9C",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#spring-cloud-gateway-설정-예제"
  },"16": {
    "doc": "Spring boot gateway",
    "title": "WebFlux vs Spring MVC 비교",
    "content": "1. 스레드 모델 비교 . graph TB subgraph \"Spring MVC (Blocking)\" MVCRequest[Request] --&gt; MVCThread[Thread Pool] MVCThread --&gt; MVCBlocking[Blocking I/O] MVCBlocking --&gt; MVCResponse[Response] end subgraph \"WebFlux (Non-blocking)\" FluxRequest[Request] --&gt; FluxEventLoop[Event Loop] FluxEventLoop --&gt; FluxNonBlocking[Non-blocking I/O] FluxNonBlocking --&gt; FluxResponse[Response] end style MVCThread fill:#ffcccc style FluxEventLoop fill:#ccffcc . 2. 성능 특성 비교 . | 특성 | Spring MVC | WebFlux | . | 스레드 모델 | Thread-per-request | Event Loop | . | 메모리 사용량 | 높음 (스레드당 1MB) | 낮음 | . | 동시성 처리 | 제한적 | 높음 | . | 학습 곡선 | 낮음 | 높음 | . | 블로킹 작업 | 적합 | 부적합 | . ",
    "url": "/docs/spring/api-gateway-webflux.html#webflux-vs-spring-mvc-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#webflux-vs-spring-mvc-비교"
  },"17": {
    "doc": "Spring boot gateway",
    "title": "실제 사용 사례",
    "content": "1. 마이크로서비스 게이트웨이 . graph TB Client[모바일 앱/웹] --&gt; Gateway[API Gateway] Gateway --&gt; Auth[인증/인가] Gateway --&gt; RateLimit[Rate Limiting] Gateway --&gt; CircuitBreaker[Circuit Breaker] Auth --&gt; Service1[User Service] Auth --&gt; Service2[Order Service] Auth --&gt; Service3[Payment Service] subgraph \"Cross-cutting Concerns\" Logging[로깅] Monitoring[모니터링] Tracing[분산 추적] end Gateway --&gt; Logging Gateway --&gt; Monitoring Gateway --&gt; Tracing . 2. 실시간 데이터 스트리밍 . @RestController public class ReactiveController { @GetMapping(\"/events\") public Flux&lt;Event&gt; getEvents() { return Flux.interval(Duration.ofSeconds(1)) .map(sequence -&gt; new Event(\"Event-\" + sequence, Instant.now())) .take(10); } @PostMapping(\"/process\") public Mono&lt;Result&gt; processData(@RequestBody Flux&lt;Data&gt; dataStream) { return dataStream .filter(data -&gt; data.isValid()) .map(data -&gt; data.process()) .collectList() .map(results -&gt; new Result(results)); } } . ",
    "url": "/docs/spring/api-gateway-webflux.html#%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#실제-사용-사례"
  },"18": {
    "doc": "Spring boot gateway",
    "title": "모니터링 및 관찰성",
    "content": "1. 메트릭 수집 . graph TB Gateway[Gateway] --&gt; Metrics[메트릭 수집] Metrics --&gt; Prometheus[Prometheus] Prometheus --&gt; Grafana[Grafana Dashboard] subgraph \"Key Metrics\" RequestRate[요청률] ResponseTime[응답시간] ErrorRate[에러율] ActiveConnections[활성 연결수] end Metrics --&gt; RequestRate Metrics --&gt; ResponseTime Metrics --&gt; ErrorRate Metrics --&gt; ActiveConnections . 2. 분산 추적 . @Component public class TracingFilter implements GlobalFilter { @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { String traceId = generateTraceId(); return chain.filter(exchange) .doFirst(() -&gt; { exchange.getAttributes().put(\"traceId\", traceId); log.info(\"Trace started: {}\", traceId); }) .doFinally(signalType -&gt; { log.info(\"Trace completed: {} with signal: {}\", traceId, signalType); }); } } . ",
    "url": "/docs/spring/api-gateway-webflux.html#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%B0%8F-%EA%B4%80%EC%B0%B0%EC%84%B1",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#모니터링-및-관찰성"
  },"19": {
    "doc": "Spring boot gateway",
    "title": "성능 최적화 팁",
    "content": "1. 메모리 사용량 최적화 . | 백프레셔 활용: onBackpressureBuffer(), onBackpressureDrop() | 스트림 변환 최소화: 불필요한 map(), filter() 호출 줄이기 | 메모리 풀 사용: Netty의 메모리 풀 활용 | . 2. 네트워크 최적화 . | Connection Pooling: 적절한 커넥션 풀 크기 설정 | Timeout 설정: 적절한 타임아웃 값 설정 | Load Balancing: 클라이언트 사이드 로드 밸런싱 활용 | . ",
    "url": "/docs/spring/api-gateway-webflux.html#%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%ED%8C%81",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#성능-최적화-팁"
  },"20": {
    "doc": "Spring boot gateway",
    "title": "결론",
    "content": "Spring Cloud Gateway와 WebFlux는 현대적인 마이크로서비스 아키텍처에서 필수적인 기술입니다. 비동기 논블로킹 방식으로 높은 성능과 확장성을 제공하며, 특히 대용량 트래픽을 처리하는 시스템에서 큰 장점을 보입니다. 하지만 WebFlux의 학습 곡선이 높고, 모든 상황에서 적합하지 않을 수 있으므로, 프로젝트의 요구사항을 잘 분석하여 적절한 기술을 선택하는 것이 중요합니다. ",
    "url": "/docs/spring/api-gateway-webflux.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html#결론"
  },"21": {
    "doc": "Spring boot gateway",
    "title": "Spring boot gateway",
    "content": " ",
    "url": "/docs/spring/api-gateway-webflux.html",
    
    "relUrl": "/docs/spring/api-gateway-webflux.html"
  },"22": {
    "doc": "Blue/Green Deployment",
    "title": "Blue/Green 배포 전략",
    "content": "Blue/Green 배포는 두 개의 동일한 환경(Blue와 Green)을 사용하여 완전한 버전 전환을 통해 무중단 배포를 구현하는 전략입니다. ",
    "url": "/docs/deploy/blue-green.html#bluegreen-%EB%B0%B0%ED%8F%AC-%EC%A0%84%EB%9E%B5",
    
    "relUrl": "/docs/deploy/blue-green.html#bluegreen-배포-전략"
  },"23": {
    "doc": "Blue/Green Deployment",
    "title": "개요",
    "content": "Blue/Green 배포에서는 현재 운영 중인 환경(Blue)과 새로운 버전을 배포할 환경(Green)을 준비합니다. 새로운 버전이 Green 환경에서 완전히 테스트된 후, 트래픽을 한 번에 Blue에서 Green으로 전환합니다. ",
    "url": "/docs/deploy/blue-green.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/deploy/blue-green.html#개요"
  },"24": {
    "doc": "Blue/Green Deployment",
    "title": "작동 원리",
    "content": "graph TB subgraph \"Phase 1: 준비 단계\" A1[\"Blue v1.0&lt;br/&gt;🔵\"] --&gt; S1[\"Service&lt;br/&gt;🌐\"] A2[\"Blue v1.0&lt;br/&gt;🔵\"] --&gt; S1 A3[\"Blue v1.0&lt;br/&gt;🔵\"] --&gt; S1 G1[\"Green v2.0&lt;br/&gt;🟢\"] -.-&gt; S2[\"Service&lt;br/&gt;🌐\"] G2[\"Green v2.0&lt;br/&gt;🟢\"] -.-&gt; S2 G3[\"Green v2.0&lt;br/&gt;🟢\"] -.-&gt; S2 end subgraph \"Phase 2: 트래픽 전환\" B1[\"Blue v1.0&lt;br/&gt;🔵\"] -.-&gt; S3[\"Service&lt;br/&gt;🌐\"] B2[\"Blue v1.0&lt;br/&gt;🔵\"] -.-&gt; S3 B3[\"Blue v1.0&lt;br/&gt;🔵\"] -.-&gt; S3 H1[\"Green v2.0&lt;br/&gt;🟢\"] --&gt; S3 H2[\"Green v2.0&lt;br/&gt;🟢\"] --&gt; S3 H3[\"Green v2.0&lt;br/&gt;🟢\"] --&gt; S3 end subgraph \"Phase 3: 정리 단계\" C1[\"Blue v1.0&lt;br/&gt;🔵\"] -.-&gt; S4[\"Service&lt;br/&gt;🌐\"] C2[\"Blue v1.0&lt;br/&gt;🔵\"] -.-&gt; S4 C3[\"Blue v1.0&lt;br/&gt;🔵\"] -.-&gt; S4 I1[\"Green v2.0&lt;br/&gt;🟢\"] --&gt; S4 I2[\"Green v2.0&lt;br/&gt;🟢\"] --&gt; S4 I3[\"Green v2.0&lt;br/&gt;🟢\"] --&gt; S4 end Phase1 --&gt; Phase2 --&gt; Phase3 style A1 fill:#87CEEB style A2 fill:#87CEEB style A3 fill:#87CEEB style G1 fill:#90EE90 style G2 fill:#90EE90 style G3 fill:#90EE90 style B1 fill:#87CEEB style B2 fill:#87CEEB style B3 fill:#87CEEB style H1 fill:#90EE90 style H2 fill:#90EE90 style H3 fill:#90EE90 style C1 fill:#87CEEB style C2 fill:#87CEEB style C3 fill:#87CEEB style I1 fill:#90EE90 style I2 fill:#90EE90 style I3 fill:#90EE90 . ",
    "url": "/docs/deploy/blue-green.html#%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/deploy/blue-green.html#작동-원리"
  },"25": {
    "doc": "Blue/Green Deployment",
    "title": "배포 과정",
    "content": "stateDiagram-v2 [*] --&gt; BlueActive BlueActive --&gt; GreenDeploy: 새 버전 배포 GreenDeploy --&gt; GreenTest: Green 환경 테스트 GreenTest --&gt; TrafficSwitch: 트래픽 전환 TrafficSwitch --&gt; GreenActive: Green 활성화 GreenActive --&gt; BlueCleanup: Blue 환경 정리 BlueCleanup --&gt; [*] note right of BlueActive: Blue 환경에서 서비스 제공 note right of GreenDeploy: Green 환경에 새 버전 배포 note right of GreenTest: Green 환경에서 완전한 테스트 note right of TrafficSwitch: 로드밸런서 설정 변경 note right of GreenActive: Green 환경이 새로운 Blue note right of BlueCleanup: 이전 Blue 환경 삭제 . ",
    "url": "/docs/deploy/blue-green.html#%EB%B0%B0%ED%8F%AC-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/deploy/blue-green.html#배포-과정"
  },"26": {
    "doc": "Blue/Green Deployment",
    "title": "장점",
    "content": ". | ✅ 빠른 롤백: 트래픽을 다시 Blue로 전환하여 즉시 롤백 가능 | ✅ 완전한 테스트: Green 환경에서 실제 환경과 동일한 조건으로 테스트 | ✅ 무중단 배포: 트래픽 전환이 순간적으로 이루어짐 | ✅ 버전 분리: Blue와 Green이 완전히 분리되어 버전 충돌 없음 | . ",
    "url": "/docs/deploy/blue-green.html#%EC%9E%A5%EC%A0%90",
    
    "relUrl": "/docs/deploy/blue-green.html#장점"
  },"27": {
    "doc": "Blue/Green Deployment",
    "title": "단점",
    "content": ". | ❌ 리소스 비용: 두 배의 인프라가 필요 | ❌ 데이터베이스 복잡성: 데이터베이스 스키마 변경 시 주의 필요 | ❌ 상태 관리: 세션 상태나 캐시 데이터 처리 필요 | ❌ 복잡한 설정: 로드밸런서와 네트워크 설정이 복잡 | . ",
    "url": "/docs/deploy/blue-green.html#%EB%8B%A8%EC%A0%90",
    
    "relUrl": "/docs/deploy/blue-green.html#단점"
  },"28": {
    "doc": "Blue/Green Deployment",
    "title": "Kubernetes에서의 구현",
    "content": "Blue 환경 (현재 운영) . apiVersion: apps/v1 kind: Deployment metadata: name: my-app-blue labels: app: my-app version: blue spec: replicas: 3 selector: matchLabels: app: my-app version: blue template: metadata: labels: app: my-app version: blue spec: containers: - name: my-app image: my-app:v1.0 --- apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app version: blue # 현재 Blue 환경으로 트래픽 전달 ports: - port: 80 targetPort: 8080 . Green 환경 (새 버전) . apiVersion: apps/v1 kind: Deployment metadata: name: my-app-green labels: app: my-app version: green spec: replicas: 3 selector: matchLabels: app: my-app version: green template: metadata: labels: app: my-app version: green spec: containers: - name: my-app image: my-app:v2.0 . 배포 스크립트 . #!/bin/bash # 1. Green 환경 배포 kubectl apply -f green-deployment.yaml # 2. Green 환경 상태 확인 kubectl rollout status deployment/my-app-green # 3. Green 환경 테스트 kubectl port-forward service/my-app-green 8080:80 &amp; sleep 10 curl -f http://localhost:8080/health || exit 1 # 4. 트래픽 전환 (Service selector 변경) kubectl patch service my-app-service -p '{\"spec\":{\"selector\":{\"version\":\"green\"}}}' # 5. Green 환경 활성화 확인 kubectl get endpoints my-app-service # 6. Blue 환경 정리 (선택사항) kubectl delete deployment my-app-blue . ",
    "url": "/docs/deploy/blue-green.html#kubernetes%EC%97%90%EC%84%9C%EC%9D%98-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/deploy/blue-green.html#kubernetes에서의-구현"
  },"29": {
    "doc": "Blue/Green Deployment",
    "title": "트래픽 전환 방법",
    "content": "1. Service Selector 변경 . # Blue에서 Green으로 전환 kubectl patch service my-app-service -p '{\"spec\":{\"selector\":{\"version\":\"green\"}}}' # Green에서 Blue로 롤백 kubectl patch service my-app-service -p '{\"spec\":{\"selector\":{\"version\":\"blue\"}}}' . 2. Ingress 설정 변경 . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: my-app-ingress spec: rules: - host: my-app.example.com http: paths: - path: / pathType: Prefix backend: service: name: my-app-service port: number: 80 . ",
    "url": "/docs/deploy/blue-green.html#%ED%8A%B8%EB%9E%98%ED%94%BD-%EC%A0%84%ED%99%98-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/deploy/blue-green.html#트래픽-전환-방법"
  },"30": {
    "doc": "Blue/Green Deployment",
    "title": "모니터링 및 검증",
    "content": "# 배포 상태 확인 kubectl get deployments -l app=my-app # 서비스 엔드포인트 확인 kubectl get endpoints my-app-service # 파드 상태 확인 kubectl get pods -l app=my-app # 로그 확인 kubectl logs -l app=my-app,version=green # 헬스체크 kubectl exec -it $(kubectl get pods -l app=my-app,version=green -o jsonpath='{.items[0].metadata.name}') -- curl localhost:8080/health . ",
    "url": "/docs/deploy/blue-green.html#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%B0%8F-%EA%B2%80%EC%A6%9D",
    
    "relUrl": "/docs/deploy/blue-green.html#모니터링-및-검증"
  },"31": {
    "doc": "Blue/Green Deployment",
    "title": "데이터베이스 고려사항",
    "content": "스키마 변경이 없는 경우 . | Green 환경에서 동일한 데이터베이스 사용 | 트래픽 전환만으로 배포 완료 | . 스키마 변경이 있는 경우 . | 데이터베이스 마이그레이션 스크립트 준비 | Green 환경 배포 전 마이그레이션 실행 | 롤백 시 데이터베이스 롤백 계획 필요 | . ",
    "url": "/docs/deploy/blue-green.html#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/deploy/blue-green.html#데이터베이스-고려사항"
  },"32": {
    "doc": "Blue/Green Deployment",
    "title": "베스트 프랙티스",
    "content": ". | 완전한 테스트: Green 환경에서 실제 환경과 동일한 테스트 | 모니터링: 트래픽 전환 후 즉시 모니터링 시작 | 롤백 계획: 문제 발생 시 빠른 롤백 절차 준비 | 리소스 관리: 사용하지 않는 Blue 환경 정리 | 문서화: 배포 절차와 롤백 절차 문서화 | . ",
    "url": "/docs/deploy/blue-green.html#%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4",
    
    "relUrl": "/docs/deploy/blue-green.html#베스트-프랙티스"
  },"33": {
    "doc": "Blue/Green Deployment",
    "title": "사용 시나리오",
    "content": ". | ✅ 중요한 프로덕션 환경: 완전한 무중단 배포가 필요한 경우 | ✅ 복잡한 애플리케이션: 여러 컴포넌트가 상호 의존하는 경우 | ✅ 데이터베이스 변경: 스키마 변경이 포함된 배포 | ✅ 긴급 배포: 빠른 롤백이 필요한 경우 | . Blue/Green 배포는 완전한 환경 분리를 통해 안전하고 신뢰할 수 있는 배포를 제공하지만, 추가 리소스와 복잡한 설정이 필요한 고급 배포 전략입니다. ",
    "url": "/docs/deploy/blue-green.html#%EC%82%AC%EC%9A%A9-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4",
    
    "relUrl": "/docs/deploy/blue-green.html#사용-시나리오"
  },"34": {
    "doc": "Blue/Green Deployment",
    "title": "Blue/Green Deployment",
    "content": " ",
    "url": "/docs/deploy/blue-green.html",
    
    "relUrl": "/docs/deploy/blue-green.html"
  },"35": {
    "doc": "Canary Deployment",
    "title": "Canary 배포 전략",
    "content": "Canary 배포는 새로운 버전을 소규모 사용자 그룹에게 먼저 배포하여 안전성을 검증한 후, 점진적으로 전체 사용자에게 확산하는 배포 전략입니다. ",
    "url": "/docs/deploy/canary.html#canary-%EB%B0%B0%ED%8F%AC-%EC%A0%84%EB%9E%B5",
    
    "relUrl": "/docs/deploy/canary.html#canary-배포-전략"
  },"36": {
    "doc": "Canary Deployment",
    "title": "개요",
    "content": "Canary 배포는 광부들이 카나리아(새)를 광산에 데려가서 유해 가스 유무를 확인했던 것에서 유래한 이름입니다. 소수의 사용자에게 새 버전을 먼저 제공하여 문제가 없는지 확인한 후, 점진적으로 트래픽을 늘려가는 방식입니다. ",
    "url": "/docs/deploy/canary.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/deploy/canary.html#개요"
  },"37": {
    "doc": "Canary Deployment",
    "title": "작동 원리",
    "content": "graph TB subgraph \"Phase 1: Canary 초기 배포\" A1[\"Stable v1.0&lt;br/&gt;🟢\"] --&gt; S1[\"Service&lt;br/&gt;🌐\"] A2[\"Stable v1.0&lt;br/&gt;🟢\"] --&gt; S1 A3[\"Stable v1.0&lt;br/&gt;🟢\"] --&gt; S1 A4[\"Canary v2.0&lt;br/&gt;🟡\"] --&gt; S1 end subgraph \"Phase 2: 트래픽 점진적 증가\" B1[\"Stable v1.0&lt;br/&gt;🟢\"] --&gt; S2[\"Service&lt;br/&gt;🌐\"] B2[\"Stable v1.0&lt;br/&gt;🟢\"] --&gt; S2 B3[\"Canary v2.0&lt;br/&gt;🟡\"] --&gt; S2 B4[\"Canary v2.0&lt;br/&gt;🟡\"] --&gt; S2 end subgraph \"Phase 3: 완전 전환\" C1[\"Canary v2.0&lt;br/&gt;🟡\"] --&gt; S3[\"Service&lt;br/&gt;🌐\"] C2[\"Canary v2.0&lt;br/&gt;🟡\"] --&gt; S3 C3[\"Canary v2.0&lt;br/&gt;🟡\"] --&gt; S3 C4[\"Canary v2.0&lt;br/&gt;🟡\"] --&gt; S3 end Phase1 --&gt; Phase2 --&gt; Phase3 style A1 fill:#90EE90 style A2 fill:#90EE90 style A3 fill:#90EE90 style A4 fill:#FFD700 style B1 fill:#90EE90 style B2 fill:#90EE90 style B3 fill:#FFD700 style B4 fill:#FFD700 style C1 fill:#FFD700 style C2 fill:#FFD700 style C3 fill:#FFD700 style C4 fill:#FFD700 . ",
    "url": "/docs/deploy/canary.html#%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/deploy/canary.html#작동-원리"
  },"38": {
    "doc": "Canary Deployment",
    "title": "배포 과정",
    "content": "stateDiagram-v2 [*] --&gt; StableOnly StableOnly --&gt; CanaryDeploy: Canary 배포 CanaryDeploy --&gt; SmallTraffic: 5% 트래픽 SmallTraffic --&gt; Monitor: 모니터링 Monitor --&gt; IncreaseTraffic: 트래픽 증가 IncreaseTraffic --&gt; Monitor Monitor --&gt; FullDeploy: 전체 배포 FullDeffic --&gt; Rollback: 문제 발생 Monitor --&gt; Rollback: 문제 발생 Rollback --&gt; StableOnly FullDeploy --&gt; [*] note right of StableOnly: 안정 버전만 실행 note right of CanaryDeploy: Canary 버전 소수 배포 note right of SmallTraffic: 5-10% 트래픽으로 테스트 note right of Monitor: 메트릭, 로그, 오류율 모니터링 note right of IncreaseTraffic: 25%, 50%, 75% 순차 증가 note right of FullDeploy: 100% 트래픽으로 완전 전환 note right of Rollback: 문제 발생 시 즉시 롤백 . ",
    "url": "/docs/deploy/canary.html#%EB%B0%B0%ED%8F%AC-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/deploy/canary.html#배포-과정"
  },"39": {
    "doc": "Canary Deployment",
    "title": "장점",
    "content": ". | ✅ 위험 최소화: 소수 사용자에게만 영향 | ✅ 실시간 피드백: 실제 사용자 데이터로 검증 | ✅ 점진적 배포: 트래픽 비율 조정으로 안전한 확산 | ✅ 빠른 롤백: 문제 발생 시 즉시 이전 버전으로 복구 | ✅ A/B 테스트: 사용자 반응 비교 가능 | . ",
    "url": "/docs/deploy/canary.html#%EC%9E%A5%EC%A0%90",
    
    "relUrl": "/docs/deploy/canary.html#장점"
  },"40": {
    "doc": "Canary Deployment",
    "title": "단점",
    "content": ". | ❌ 복잡한 설정: 트래픽 분산 로직 구현 필요 | ❌ 모니터링 부담: 실시간 모니터링과 알림 설정 필요 | ❌ 세션 관리: 사용자 세션 일관성 유지 어려움 | ❌ 데이터 일관성: 두 버전 간 데이터 동기화 문제 | . ",
    "url": "/docs/deploy/canary.html#%EB%8B%A8%EC%A0%90",
    
    "relUrl": "/docs/deploy/canary.html#단점"
  },"41": {
    "doc": "Canary Deployment",
    "title": "Kubernetes에서의 구현",
    "content": "기본 Canary 배포 . # Stable 버전 (기존) apiVersion: apps/v1 kind: Deployment metadata: name: my-app-stable labels: app: my-app version: stable spec: replicas: 9 # 90% 트래픽 selector: matchLabels: app: my-app version: stable template: metadata: labels: app: my-app version: stable spec: containers: - name: my-app image: my-app:v1.0 --- # Canary 버전 (새로운) apiVersion: apps/v1 kind: Deployment metadata: name: my-app-canary labels: app: my-app version: canary spec: replicas: 1 # 10% 트래픽 selector: matchLabels: app: my-app version: canary template: metadata: labels: app: my-app version: canary spec: containers: - name: my-app image: my-app:v2.0 --- # Service (라벨 셀렉터로 트래픽 분산) apiVersion: v1 kind: Service metadata: name: my-app-service spec: selector: app: my-app # stable과 canary 모두 선택 ports: - port: 80 targetPort: 8080 . 트래픽 비율 조정 . # Canary 10% (1개 파드) kubectl scale deployment my-app-canary --replicas=1 kubectl scale deployment my-app-stable --replicas=9 # Canary 25% (2개 파드) kubectl scale deployment my-app-canary --replicas=2 kubectl scale deployment my-app-stable --replicas=6 # Canary 50% (3개 파드) kubectl scale deployment my-app-canary --replicas=3 kubectl scale deployment my-app-stable --replicas=3 # Canary 100% (완전 전환) kubectl scale deployment my-app-canary --replicas=10 kubectl scale deployment my-app-stable --replicas=0 . ",
    "url": "/docs/deploy/canary.html#kubernetes%EC%97%90%EC%84%9C%EC%9D%98-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/deploy/canary.html#kubernetes에서의-구현"
  },"42": {
    "doc": "Canary Deployment",
    "title": "고급 Canary 배포 (Istio 사용)",
    "content": "Istio VirtualService 설정 . apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: my-app-vs spec: hosts: - my-app.example.com http: - route: - destination: host: my-app-stable subset: v1 weight: 90 # 90% 트래픽 - destination: host: my-app-canary subset: v2 weight: 10 # 10% 트래픽 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: my-app-dr spec: host: my-app-service subsets: - name: v1 labels: version: stable - name: v2 labels: version: canary . 트래픽 비율 동적 조정 . # Canary 10%로 시작 kubectl patch virtualservice my-app-vs -p '{\"spec\":{\"http\":[{\"route\":[{\"destination\":{\"host\":\"my-app-stable\",\"subset\":\"v1\"},\"weight\":90},{\"destination\":{\"host\":\"my-app-canary\",\"subset\":\"v2\"},\"weight\":10}]}]}}' # Canary 50%로 증가 kubectl patch virtualservice my-app-vs -p '{\"spec\":{\"http\":[{\"route\":[{\"destination\":{\"host\":\"my-app-stable\",\"subset\":\"v1\"},\"weight\":50},{\"destination\":{\"host\":\"my-app-canary\",\"subset\":\"v2\"},\"weight\":50}]}]}}' # Canary 100%로 완전 전환 kubectl patch virtualservice my-app-vs -p '{\"spec\":{\"http\":[{\"route\":[{\"destination\":{\"host\":\"my-app-canary\",\"subset\":\"v2\"},\"weight\":100}]}]}}' . ",
    "url": "/docs/deploy/canary.html#%EA%B3%A0%EA%B8%89-canary-%EB%B0%B0%ED%8F%AC-istio-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/deploy/canary.html#고급-canary-배포-istio-사용"
  },"43": {
    "doc": "Canary Deployment",
    "title": "모니터링 및 알림",
    "content": "메트릭 수집 . apiVersion: v1 kind: ConfigMap metadata: name: prometheus-config data: prometheus.yml: | global: scrape_interval: 15s scrape_configs: - job_name: 'kubernetes-pods' kubernetes_sd_configs: - role: pod relabel_configs: - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape] action: keep regex: true . 알림 규칙 . apiVersion: monitoring.coreos.com/v1 kind: PrometheusRule metadata: name: canary-alerts spec: groups: - name: canary.rules rules: - alert: CanaryHighErrorRate expr: rate(http_requests_total{status=~\"5..\"}[5m]) &gt; 0.1 for: 2m labels: severity: critical annotations: summary: \"Canary deployment has high error rate\" . ",
    "url": "/docs/deploy/canary.html#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%B0%8F-%EC%95%8C%EB%A6%BC",
    
    "relUrl": "/docs/deploy/canary.html#모니터링-및-알림"
  },"44": {
    "doc": "Canary Deployment",
    "title": "자동화된 Canary 배포",
    "content": "배포 스크립트 . #!/bin/bash # Canary 배포 자동화 스크립트 CANARY_REPLICAS=1 STABLE_REPLICAS=9 MONITORING_DURATION=300 # 5분 echo \"Starting Canary deployment...\" # 1. Canary 배포 kubectl apply -f canary-deployment.yaml kubectl rollout status deployment/my-app-canary # 2. 초기 트래픽 설정 (10%) kubectl scale deployment my-app-canary --replicas=$CANARY_REPLICAS kubectl scale deployment my-app-stable --replicas=$STABLE_REPLICAS # 3. 모니터링 echo \"Monitoring canary deployment for $MONITORING_DURATION seconds...\" sleep $MONITORING_DURATION # 4. 메트릭 확인 ERROR_RATE=$(kubectl exec -it $(kubectl get pods -l app=my-app,version=canary -o jsonpath='{.items[0].metadata.name}') -- curl -s localhost:8080/metrics | grep error_rate | awk '{print $2}') if [ \"$ERROR_RATE\" -lt \"0.05\" ]; then echo \"Canary deployment successful. Increasing traffic...\" # 5. 트래픽 증가 (25%) kubectl scale deployment my-app-canary --replicas=2 kubectl scale deployment my-app-stable --replicas=6 sleep $MONITORING_DURATION # 6. 완전 전환 kubectl scale deployment my-app-canary --replicas=10 kubectl scale deployment my-app-stable --replicas=0 echo \"Canary deployment completed successfully!\" else echo \"High error rate detected. Rolling back...\" kubectl scale deployment my-app-canary --replicas=0 kubectl scale deployment my-app-stable --replicas=10 echo \"Rollback completed.\" fi . ",
    "url": "/docs/deploy/canary.html#%EC%9E%90%EB%8F%99%ED%99%94%EB%90%9C-canary-%EB%B0%B0%ED%8F%AC",
    
    "relUrl": "/docs/deploy/canary.html#자동화된-canary-배포"
  },"45": {
    "doc": "Canary Deployment",
    "title": "베스트 프랙티스",
    "content": ". | 점진적 트래픽 증가: 5% → 25% → 50% → 75% → 100% | 충분한 모니터링: 각 단계별로 충분한 시간 모니터링 | 자동 롤백: 오류율 임계값 설정으로 자동 롤백 | 메트릭 정의: 성공률, 응답시간, 오류율 등 핵심 메트릭 정의 | 사용자 세션: 사용자별 일관된 버전 제공 | . ",
    "url": "/docs/deploy/canary.html#%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4",
    
    "relUrl": "/docs/deploy/canary.html#베스트-프랙티스"
  },"46": {
    "doc": "Canary Deployment",
    "title": "사용 시나리오",
    "content": ". | ✅ 중요한 프로덕션 서비스: 위험을 최소화하고 싶은 경우 | ✅ 새로운 기능 배포: 사용자 반응을 확인하고 싶은 경우 | ✅ 성능 테스트: 실제 트래픽으로 성능 검증 | ✅ A/B 테스트: 사용자 경험 비교 분석 | . Canary 배포는 위험을 최소화하면서 새로운 버전을 안전하게 배포할 수 있는 현대적인 배포 전략입니다. ",
    "url": "/docs/deploy/canary.html#%EC%82%AC%EC%9A%A9-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4",
    
    "relUrl": "/docs/deploy/canary.html#사용-시나리오"
  },"47": {
    "doc": "Canary Deployment",
    "title": "Canary Deployment",
    "content": " ",
    "url": "/docs/deploy/canary.html",
    
    "relUrl": "/docs/deploy/canary.html"
  },"48": {
    "doc": "ClusterRole",
    "title": "ClusterRole 개요",
    "content": "ClusterRole은 Kubernetes에서 클러스터 전체 범위의 권한을 정의하는 리소스입니다. 모든 네임스페이스에 적용되며, 클러스터 관리자나 시스템 컴포넌트가 사용하는 권한을 정의합니다. ClusterRole의 특징 . | 클러스터 범위: 모든 네임스페이스에 적용 | 시스템 권한: 클러스터 관리자 권한 정의 | 네임스페이스 리소스: 모든 네임스페이스의 리소스에 접근 | 클러스터 리소스: Node, PersistentVolume 등 클러스터 리소스 접근 | . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-개요"
  },"49": {
    "doc": "ClusterRole",
    "title": "ClusterRole 구조",
    "content": "graph TD A[ClusterRole] --&gt; B[Rules] B --&gt; C[API Groups] B --&gt; D[Resources] B --&gt; E[Verbs] C --&gt; F[apps/v1] C --&gt; G[core/v1] C --&gt; H[networking.k8s.io/v1] C --&gt; I[rbac.authorization.k8s.io/v1] D --&gt; J[Pods] D --&gt; K[Services] D --&gt; L[Nodes] D --&gt; M[Namespaces] E --&gt; N[get] E --&gt; O[list] E --&gt; P[create] E --&gt; Q[update] E --&gt; R[delete] style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#e8f5e8 style E fill:#e8f5e8 . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-구조"
  },"50": {
    "doc": "ClusterRole",
    "title": "ClusterRole 예시",
    "content": "기본 ClusterRole . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: pod-reader rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\", \"watch\"] . 관리자 ClusterRole . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-admin rules: # 모든 리소스에 대한 모든 권한 - apiGroups: [\"*\"] resources: [\"*\"] verbs: [\"*\"] # 모든 네임스페이스 접근 - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"*\"] . 시스템 ClusterRole . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: system:node rules: # 노드 리소스 관리 - apiGroups: [\"\"] resources: [\"nodes\"] verbs: [\"get\", \"list\", \"watch\", \"update\", \"patch\"] # Pod 관리 - apiGroups: [\"\"] resources: [\"pods\", \"pods/binding\", \"pods/eviction\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # 서비스 관리 - apiGroups: [\"\"] resources: [\"services\", \"endpoints\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-예시"
  },"51": {
    "doc": "ClusterRole",
    "title": "ClusterRole 타입",
    "content": "1. 읽기 전용 ClusterRole . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-reader rules: # 모든 네임스페이스의 리소스 읽기 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\", \"secrets\", \"persistentvolumeclaims\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\"] # 클러스터 리소스 읽기 - apiGroups: [\"\"] resources: [\"nodes\", \"namespaces\"] verbs: [\"get\", \"list\", \"watch\"] . 2. 관리자 ClusterRole . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-manager rules: # 모든 리소스 관리 - apiGroups: [\"*\"] resources: [\"*\"] verbs: [\"*\"] # 네임스페이스 관리 - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # RBAC 관리 - apiGroups: [\"rbac.authorization.k8s.io\"] resources: [\"clusterroles\", \"clusterrolebindings\", \"roles\", \"rolebindings\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . 3. 모니터링 ClusterRole . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: monitoring rules: # 모든 리소스 읽기 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"nodes\", \"namespaces\", \"events\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\"] # Pod 로그 읽기 - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] # 메트릭 수집 - apiGroups: [\"\"] resources: [\"nodes/proxy\"] verbs: [\"get\", \"list\", \"watch\"] . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-%ED%83%80%EC%9E%85",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-타입"
  },"52": {
    "doc": "ClusterRole",
    "title": "ClusterRole과 ClusterRoleBinding 조합",
    "content": "ClusterRoleBinding 예시 . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-admin-binding subjects: - kind: User name: admin@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io . 여러 ClusterRole을 사용자에게 할당 . # 첫 번째 ClusterRole apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-reader rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\"] verbs: [\"get\", \"list\", \"watch\"] --- # 두 번째 ClusterRole apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: namespace-manager rules: - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] --- # 첫 번째 ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-reader-binding subjects: - kind: User name: user@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-reader apiGroup: rbac.authorization.k8s.io --- # 두 번째 ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: namespace-manager-binding subjects: - kind: User name: user@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: namespace-manager apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole%EA%B3%BC-clusterrolebinding-%EC%A1%B0%ED%95%A9",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole과-clusterrolebinding-조합"
  },"53": {
    "doc": "ClusterRole",
    "title": "ClusterRole 관리 명령어",
    "content": "기본 명령어 . # ClusterRole 생성 kubectl apply -f clusterrole.yaml # ClusterRole 목록 확인 kubectl get clusterroles # ClusterRole 상세 정보 확인 kubectl describe clusterrole &lt;clusterrole-name&gt; # ClusterRole 삭제 kubectl delete clusterrole &lt;clusterrole-name&gt; # ClusterRole YAML 확인 kubectl get clusterrole &lt;clusterrole-name&gt; -o yaml . 권한 테스트 . # 사용자 권한 확인 kubectl auth can-i get pods --as=user@example.com --all-namespaces # 특정 동작 권한 확인 kubectl auth can-i create namespaces --as=user@example.com # 모든 권한 확인 kubectl auth can-i --list --as=user@example.com --all-namespaces . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-관리-명령어"
  },"54": {
    "doc": "ClusterRole",
    "title": "ClusterRole 사용 사례",
    "content": "1. 클러스터 관리자 . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-admin rules: # 모든 리소스에 대한 모든 권한 - apiGroups: [\"*\"] resources: [\"*\"] verbs: [\"*\"] # 모든 네임스페이스 접근 - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"*\"] # RBAC 관리 - apiGroups: [\"rbac.authorization.k8s.io\"] resources: [\"clusterroles\", \"clusterrolebindings\", \"roles\", \"rolebindings\"] verbs: [\"*\"] . 2. 시스템 모니터링 . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: system:monitoring rules: # 모든 네임스페이스의 리소스 읽기 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"nodes\", \"events\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\"] # Pod 로그 읽기 - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] # 메트릭 수집 - apiGroups: [\"\"] resources: [\"nodes/proxy\"] verbs: [\"get\", \"list\", \"watch\"] # ConfigMap 관리 (설정용) - apiGroups: [\"\"] resources: [\"configmaps\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . 3. 네임스페이스 관리자 . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: namespace-manager rules: # 네임스페이스 관리 - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # 네임스페이스 내 리소스 관리 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\", \"secrets\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # Role과 RoleBinding 관리 - apiGroups: [\"rbac.authorization.k8s.io\"] resources: [\"roles\", \"rolebindings\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-사용-사례"
  },"55": {
    "doc": "ClusterRole",
    "title": "ClusterRole vs Role",
    "content": "| 특징 | ClusterRole | Role | . | 범위 | 클러스터 전체 | 네임스페이스 | . | 네임스페이스 | 모든 네임스페이스 | 특정 네임스페이스 | . | 사용 사례 | 클러스터 관리자 권한 | 일반적인 권한 관리 | . | 바인딩 | ClusterRoleBinding | RoleBinding | . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-vs-role",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-vs-role"
  },"56": {
    "doc": "ClusterRole",
    "title": "ClusterRole 모범 사례",
    "content": "1. 최소 권한 원칙 . # 필요한 최소한의 권한만 부여 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: minimal-cluster-reader rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\"] verbs: [\"get\", \"list\"] # watch 권한 제거 . 2. 명확한 네이밍 . # 역할을 명확히 하는 이름 사용 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-namespace-manager # 명확한 역할 rules: - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . 3. 리소스별 분리 . # 노드 관리 ClusterRole apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: node-manager rules: - apiGroups: [\"\"] resources: [\"nodes\"] verbs: [\"get\", \"list\", \"watch\", \"update\", \"patch\"] --- # 네임스페이스 관리 ClusterRole apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: namespace-manager rules: - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . ",
    "url": "/docs/k8s/componentes/clusterrole.html#clusterrole-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#clusterrole-모범-사례"
  },"57": {
    "doc": "ClusterRole",
    "title": "주의사항",
    "content": ". | 최소 권한: 필요한 최소한의 권한만 부여해야 합니다 | 정기 검토: ClusterRole과 권한을 정기적으로 검토해야 합니다 | 테스트: 권한 설정 후 실제 테스트를 통해 검증해야 합니다 | 문서화: ClusterRole의 목적과 권한을 명확히 문서화해야 합니다 | 보안: 클러스터 전체 권한이므로 보안에 특히 주의해야 합니다 | . ",
    "url": "/docs/k8s/componentes/clusterrole.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html#주의사항"
  },"58": {
    "doc": "ClusterRole",
    "title": "ClusterRole",
    "content": " ",
    "url": "/docs/k8s/componentes/clusterrole.html",
    
    "relUrl": "/docs/k8s/componentes/clusterrole.html"
  },"59": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding 개요",
    "content": "ClusterRoleBinding은 Kubernetes에서 ClusterRole과 사용자/그룹/서비스 계정을 클러스터 전체 범위로 연결하는 리소스입니다. 모든 네임스페이스에 적용되는 권한을 관리합니다. ClusterRoleBinding의 특징 . | 클러스터 범위: 모든 네임스페이스에 적용 | ClusterRole 연결: ClusterRole만 바인딩 가능 | 시스템 권한: 클러스터 관리자 권한 할당 | 전역 접근: 모든 네임스페이스의 리소스에 접근 | . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-개요"
  },"60": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding 구조",
    "content": "graph TD A[ClusterRoleBinding] --&gt; B[Subjects] A --&gt; C[RoleRef] B --&gt; D[User] B --&gt; E[Group] B --&gt; F[ServiceAccount] C --&gt; G[ClusterRole] D --&gt; H[admin@example.com] E --&gt; I[cluster-admins] F --&gt; J[system:serviceaccount:kube-system:cluster-admin] G --&gt; K[cluster-admin] G --&gt; L[system:node] G --&gt; M[system:monitoring] style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#f3e5f5 style D fill:#e8f5e8 style E fill:#e8f5e8 style F fill:#e8f5e8 style G fill:#fff3e0 . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-구조"
  },"61": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding 예시",
    "content": "기본 ClusterRoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-admin-binding subjects: - kind: User name: admin@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io . 다중 주체 ClusterRoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-managers subjects: # 사용자 - kind: User name: cluster-admin@example.com apiGroup: rbac.authorization.k8s.io # 그룹 - kind: Group name: cluster-admins apiGroup: rbac.authorization.k8s.io # 서비스 계정 - kind: ServiceAccount name: cluster-admin namespace: kube-system roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io . 시스템 ClusterRoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: system:node subjects: - kind: User name: system:node:node-1 apiGroup: rbac.authorization.k8s.io - kind: User name: system:node:node-2 apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: system:node apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-예시"
  },"62": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding 타입",
    "content": "1. 관리자 ClusterRoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-admin-binding subjects: - kind: User name: admin@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io . 2. 모니터링 ClusterRoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: monitoring-binding subjects: - kind: ServiceAccount name: prometheus namespace: monitoring roleRef: kind: ClusterRole name: monitoring apiGroup: rbac.authorization.k8s.io . 3. 네임스페이스 관리자 ClusterRoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: namespace-manager-binding subjects: - kind: User name: namespace-admin@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: namespace-manager apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-%ED%83%80%EC%9E%85",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-타입"
  },"63": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding 관리 명령어",
    "content": "기본 명령어 . # ClusterRoleBinding 생성 kubectl apply -f clusterrolebinding.yaml # ClusterRoleBinding 목록 확인 kubectl get clusterrolebindings # ClusterRoleBinding 상세 정보 확인 kubectl describe clusterrolebinding &lt;clusterrolebinding-name&gt; # ClusterRoleBinding 삭제 kubectl delete clusterrolebinding &lt;clusterrolebinding-name&gt; # ClusterRoleBinding YAML 확인 kubectl get clusterrolebinding &lt;clusterrolebinding-name&gt; -o yaml . 권한 확인 명령어 . # 사용자 권한 확인 kubectl auth can-i get pods --as=user@example.com --all-namespaces # 특정 동작 권한 확인 kubectl auth can-i create namespaces --as=user@example.com # 모든 권한 확인 kubectl auth can-i --list --as=user@example.com --all-namespaces # 서비스 계정 권한 확인 kubectl auth can-i get pods --as=system:serviceaccount:monitoring:prometheus --all-namespaces . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-관리-명령어"
  },"64": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding 사용 사례",
    "content": "1. 클러스터 관리자 설정 . # 클러스터 관리자 ClusterRole apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-admin rules: - apiGroups: [\"*\"] resources: [\"*\"] verbs: [\"*\"] --- # 클러스터 관리자 ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-admin-binding subjects: - kind: User name: admin@example.com apiGroup: rbac.authorization.k8s.io - kind: Group name: cluster-admins apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io . 2. 시스템 모니터링 설정 . # 모니터링 ClusterRole apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: monitoring rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"nodes\", \"events\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] --- # Prometheus 서비스 계정 apiVersion: v1 kind: ServiceAccount metadata: name: prometheus namespace: monitoring --- # 모니터링 ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: monitoring-binding subjects: - kind: ServiceAccount name: prometheus namespace: monitoring roleRef: kind: ClusterRole name: monitoring apiGroup: rbac.authorization.k8s.io . 3. 네임스페이스 관리자 설정 . # 네임스페이스 관리자 ClusterRole apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: namespace-manager rules: - apiGroups: [\"\"] resources: [\"namespaces\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\", \"secrets\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] --- # 네임스페이스 관리자 ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: namespace-manager-binding subjects: - kind: User name: namespace-admin@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: namespace-manager apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-사용-사례"
  },"65": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding vs RoleBinding",
    "content": "| 특징 | ClusterRoleBinding | RoleBinding | . | 범위 | 클러스터 전체 | 네임스페이스 | . | Role 타입 | ClusterRole만 | Role, ClusterRole | . | 사용 사례 | 클러스터 관리자 권한 | 일반적인 권한 관리 | . | 네임스페이스 | 모든 네임스페이스 | 특정 네임스페이스 | . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-vs-rolebinding",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-vs-rolebinding"
  },"66": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding 모범 사례",
    "content": "1. 명확한 네이밍 . # 역할과 주체를 명확히 하는 이름 사용 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-admin-team-binding # 명확한 역할 subjects: - kind: Group name: cluster-admins apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io . 2. 최소 권한 원칙 . # 필요한 최소한의 권한만 부여 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-reader-binding subjects: - kind: User name: auditor@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: cluster-reader # 읽기 전용 권한만 apiGroup: rbac.authorization.k8s.io . 3. 시스템 컴포넌트 분리 . # 노드 관리자 ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: system:node-binding subjects: - kind: User name: system:node:node-1 apiGroup: rbac.authorization.k8s.io - kind: User name: system:node:node-2 apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: system:node apiGroup: rbac.authorization.k8s.io --- # 모니터링 ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: monitoring-binding subjects: - kind: ServiceAccount name: prometheus namespace: monitoring roleRef: kind: ClusterRole name: monitoring apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#clusterrolebinding-모범-사례"
  },"67": {
    "doc": "ClusterRoleBinding",
    "title": "주의사항",
    "content": ". | 최소 권한: 필요한 최소한의 권한만 부여해야 합니다 | 정기 검토: ClusterRoleBinding을 정기적으로 검토하고 정리해야 합니다 | 테스트: 권한 설정 후 실제 테스트를 통해 검증해야 합니다 | 문서화: ClusterRoleBinding의 목적과 권한을 명확히 문서화해야 합니다 | 보안: 클러스터 전체 권한이므로 보안에 특히 주의해야 합니다 | . ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html#주의사항"
  },"68": {
    "doc": "ClusterRoleBinding",
    "title": "ClusterRoleBinding",
    "content": " ",
    "url": "/docs/k8s/componentes/clusterrolebinding.html",
    
    "relUrl": "/docs/k8s/componentes/clusterrolebinding.html"
  },"69": {
    "doc": "How-to-use-Helm",
    "title": "Helm grammer",
    "content": "apiVersion: apps/v1 kind: Deployment metadata: name: nginx namespace: { { .Release.namepsace } } spec: selector: matchLabels: app: nginx replicas: 2 # tells deployment to run 2 pods matching the template template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 . ",
    "url": "/docs/helm/command.html#helm-grammer",
    
    "relUrl": "/docs/helm/command.html#helm-grammer"
  },"70": {
    "doc": "How-to-use-Helm",
    "title": "Helm 주요 command",
    "content": "helm install --upgrade -n {namespace} {chart name} {directory} -f {file name} # If there is a helm chart, upgrade it, and if not, install it. helm ls -n {namespace} # Check the status with the helm list helm uninstall -n {namespace} {chart name} # Remove helm chart in namespace helm template -n {namespace} {chart name} {directory} -f {value file} # Chech the chart grammer helm install --dry-run -n {namespace} {chart name} {directory} -f {file name} # Run a mock helm install . ",
    "url": "/docs/helm/command.html#helm-%EC%A3%BC%EC%9A%94-command",
    
    "relUrl": "/docs/helm/command.html#helm-주요-command"
  },"71": {
    "doc": "How-to-use-Helm",
    "title": "How-to-use-Helm",
    "content": " ",
    "url": "/docs/helm/command.html",
    
    "relUrl": "/docs/helm/command.html"
  },"72": {
    "doc": "How to use kubectl",
    "title": "목차",
    "content": ". | What is kubectl? | How to use kubectl . | Useful setting . | 자동완성 설정 | 별칭(Alias) 설정 | kubectl 플러그인 설치 | 환경 변수 설정 | kubectl 설정 파일 | 유용한 kubectl 플러그인들 | 프로덕션 환경 설정 | . | Primary command . | Show resource list . | 기본 조회 명령어 | -o wide 옵션 | 리소스 타입별 조회 | . | Edit resource | Scale resource . | 스케일 가능한 리소스 종류 | 스케일링 명령어 예시 | . | . | Additional useful commands . | 리소스 상세 정보 조회 | 로그 조회 | 파드 내부 접속 | 포트 포워딩 | 파일 복사 | 배포 관리 | 리소스 삭제 | YAML 파일로 리소스 관리 | 네임스페이스 관리 | 컨텍스트 관리 | 디버깅 도구 | . | . | . ",
    "url": "/docs/k8s/command.html#%EB%AA%A9%EC%B0%A8",
    
    "relUrl": "/docs/k8s/command.html#목차"
  },"73": {
    "doc": "How to use kubectl",
    "title": "What is kubectl?",
    "content": ". | kubectl은 Kubernetes 클러스터와 상호작용하기 위한 명령줄 도구입니다. | 클러스터의 리소스를 관리하고, 애플리케이션을 배포하며, 문제를 진단하는 데 사용됩니다. | . ",
    "url": "/docs/k8s/command.html#what-is-kubectl",
    
    "relUrl": "/docs/k8s/command.html#what-is-kubectl"
  },"74": {
    "doc": "How to use kubectl",
    "title": "How to use kubectl",
    "content": " ",
    "url": "/docs/k8s/command.html",
    
    "relUrl": "/docs/k8s/command.html"
  },"75": {
    "doc": "How to use kubectl",
    "title": "Useful setting",
    "content": "kubectl을 더 효율적으로 사용하기 위한 유용한 설정들입니다. 자동완성 설정 . Bash 자동완성 . # kubectl 자동완성 스크립트 추가 echo 'source &lt;(kubectl completion bash)' &gt;&gt;~/.bashrc # 현재 세션에 적용 source ~/.bashrc # 또는 직접 실행 source &lt;(kubectl completion bash) . kubectl 설정 파일 (~/.kube/config) . apiVersion: v1 kind: Config clusters: - name: my-cluster cluster: server: https://kubernetes.example.com certificate-authority-data: &lt;base64-encoded-ca-cert&gt; contexts: - name: my-context context: cluster: my-cluster user: my-user namespace: default current-context: my-context users: - name: my-user user: client-certificate-data: &lt;base64-encoded-client-cert&gt; client-key-data: &lt;base64-encoded-client-key&gt; . 프로덕션 환경 설정 . # 네임스페이스별 컨텍스트 설정 kubectl config set-context --current --namespace=production # 리소스 제한 확인 kubectl top nodes kubectl top pods # 클러스터 상태 확인 kubectl get componentstatuses kubectl get nodes -o wide . ",
    "url": "/docs/k8s/command.html#useful-setting",
    
    "relUrl": "/docs/k8s/command.html#useful-setting"
  },"76": {
    "doc": "How to use kubectl",
    "title": "Primary command",
    "content": "Show resource list . | 리소스 목록을 조회하는 기본 명령어들입니다. | . 기본 조회 명령어 . # 모든 네임스페이스의 파드 조회 kubectl get pods --all-namespaces # 특정 네임스페이스의 파드 조회 kubectl get pods -n default # 모든 리소스 타입 조회 kubectl get all . -o wide 옵션 . -o wide 옵션을 사용하면 더 자세한 정보를 볼 수 있습니다. # 파드의 상세 정보 조회 (IP, 노드 정보 포함) kubectl get pods -o wide # 서비스의 상세 정보 조회 (클러스터 IP, 외부 IP 포함) kubectl get services -o wide # 디플로이먼트의 상세 정보 조회 kubectl get deployments -o wide . 리소스 타입별 조회 . # 디플로이먼트 조회 kubectl get deploy # 서비스 조회 # port 조회 kubectl get service # StatefulSet 조회 kubectl get sts # 파드 조회 kubectl get pod # ConfigMap 조회 kubectl get configmap # Secret 조회 kubectl get secret # Role 조회 kubectl get role # ServiceAccount 조회 kubectl get serviceaccount # RoleBinding 조회 kubectl get rolebinding # PersistentVolumeClaim 조회 kubectl get pvc # PersistentVolume 조회 kubectl get pv . Edit resource . 리소스를 직접 편집할 수 있습니다. # 디플로이먼트 편집 kubectl edit deployment my-app # 서비스 편집 kubectl edit service my-service # ConfigMap 편집 kubectl edit configmap my-config # Secret 편집 kubectl edit secret my-secret . 편집기가 열리면 YAML 형식으로 리소스를 수정할 수 있습니다. 저장하면 변경사항이 즉시 클러스터에 적용됩니다. Scale resource . 리소스의 복제본 수를 조정할 수 있습니다. 스케일 가능한 리소스 종류 . | Deployment: 가장 일반적인 스케일링 대상 | StatefulSet: 상태를 가진 애플리케이션 | ReplicaSet: 디플로이먼트의 하위 리소스 | HorizontalPodAutoscaler: 자동 스케일링 | . 스케일링 명령어 예시 . # 디플로이먼트 스케일링 (3개 복제본으로 확장) kubectl scale deployment my-app --replicas=3 # StatefulSet 스케일링 (5개 복제본으로 확장) kubectl scale statefulset my-stateful-app --replicas=5 # 현재 복제본 수 확인 kubectl get deployment my-app -o jsonpath='{.spec.replicas}' # 실시간으로 복제본 수 모니터링 kubectl get pods -l app=my-app -w . ",
    "url": "/docs/k8s/command.html#primary-command",
    
    "relUrl": "/docs/k8s/command.html#primary-command"
  },"77": {
    "doc": "How to use kubectl",
    "title": "Additional useful commands",
    "content": "리소스 상세 정보 조회 . # 파드의 상세 정보 조회 kubectl describe pod my-pod # 디플로이먼트의 상세 정보 조회 kubectl describe deployment my-app # 서비스의 상세 정보 조회 kubectl describe service my-service . 로그 조회 . # 파드 로그 조회 kubectl logs my-pod # 실시간 로그 조회 (follow) kubectl logs -f my-pod # 이전 컨테이너 로그 조회 kubectl logs my-pod --previous # 특정 컨테이너 로그 조회 (멀티 컨테이너 파드) kubectl logs my-pod -c container-name . 파드 내부 접속 . # 파드 내부로 쉘 접속 kubectl exec -it my-pod -- /bin/bash # 특정 컨테이너로 접속 kubectl exec -it my-pod -c container-name -- /bin/bash # 명령어 실행 kubectl exec my-pod -- ls /app . 포트 포워딩 . # 로컬 포트를 파드 포트로 포워딩 kubectl port-forward my-pod 8080:80 # 서비스 포트 포워딩 kubectl port-forward service/my-service 8080:80 . 파일 복사 . 로컬 시스템과 파드 간에 파일을 복사할 수 있습니다. 기본 파일 복사 . # 로컬 파일을 파드로 복사 kubectl cp /local/path/file.txt my-pod:/remote/path/ # 파드 파일을 로컬로 복사 kubectl cp my-pod:/remote/path/file.txt /local/path/ # 특정 컨테이너에 파일 복사 (멀티 컨테이너 파드) kubectl cp /local/path/file.txt my-pod:/remote/path/ -c container-name . 디렉토리 복사 . # 로컬 디렉토리를 파드로 복사 kubectl cp /local/directory/ my-pod:/remote/directory/ # 파드 디렉토리를 로컬로 복사 kubectl cp my-pod:/remote/directory/ /local/directory/ . 네임스페이스 지정 . # 특정 네임스페이스의 파드에 파일 복사 kubectl cp /local/file.txt my-pod:/remote/ -n my-namespace # 다른 네임스페이스의 파드에서 파일 복사 kubectl cp my-namespace/my-pod:/remote/file.txt /local/ . 실용적인 예시 . # 설정 파일을 파드로 복사 kubectl cp -n namespace config.yaml pod-name:/app/config/ # 로그 파일을 로컬로 복사 kubectl cp -n namespace pod-name:/var/log/app.log ./logs/ # 데이터베이스 백업 파일 복사 kubectl cp -n namespace pod-name:/backup/db.sql ./backup/ # 웹 애플리케이션 정적 파일 복사 kubectl cp -n namespace ./static/ pod-name:/app/public/ . 주의사항 . | 권한: 파드에 파일을 복사할 때 적절한 권한이 필요합니다 | 용량: 대용량 파일 복사 시 시간이 오래 걸릴 수 있습니다 | 네트워크: 클러스터 네트워크 상태에 따라 속도가 달라집니다 | 보안: 민감한 파일 복사 시 주의가 필요합니다 | . 배포 관리 . kubectl rollout 명령어는 Deployment, StatefulSet, DaemonSet의 배포 상태를 관리하는 데 사용됩니다. 왜 rollout을 사용하는가? . | 무중단 배포: 새로운 버전으로 업데이트하면서 서비스 중단 최소화 | 롤백 기능: 문제 발생 시 이전 버전으로 빠른 복구 | 배포 상태 모니터링: 실시간으로 배포 진행 상황 확인 | 배포 전략: Rolling, Blue/Green, Canary 등 다양한 배포 방식 지원 | . 배포 상태 확인 . # 배포 상태 조회 kubectl rollout status deployment/my-app # 배포 히스토리 조회 kubectl rollout history deployment/my-app # 특정 리비전의 상세 정보 kubectl rollout history deployment/my-app --revision=2 . 배포 일시정지/재개 . # 배포 일시정지 (새로운 ReplicaSet 생성을 중단) kubectl rollout pause deployment/my-app # 배포 재개 kubectl rollout resume deployment/my-app . 롤백 (이전 버전으로 되돌리기) . # 이전 버전으로 롤백 kubectl rollout undo deployment/my-app # 특정 리비전으로 롤백 kubectl rollout undo deployment/my-app --to-revision=2 # 롤백 상태 확인 kubectl rollout status deployment/my-app . 실시간 모니터링 . # 배포 진행 상황 실시간 모니터링 kubectl rollout status deployment/my-app -w # 파드 상태 실시간 모니터링 kubectl get pods -l app=my-app -w . 배포 전략별 예시 . Rolling Update (기본) . # Rolling Update로 배포 kubectl set image deployment/my-app nginx=nginx:1.21 # 배포 설정 확인 kubectl get deployment my-app -o yaml | grep -A 10 strategy . Blue/Green 배포 . # 새 버전 배포 kubectl apply -f new-version.yaml # 트래픽 전환 kubectl patch service my-service -p '{\"spec\":{\"selector\":{\"version\":\"v2\"}}}' # 이전 버전 정리 kubectl delete deployment my-app-v1 . Canary 배포 . # Canary 버전 배포 (10% 트래픽) kubectl apply -f canary-deployment.yaml # 트래픽 비율 조정 kubectl patch service my-service -p '{\"spec\":{\"selector\":{\"version\":\"canary\"}}}' . 고급 배포 관리 . # 배포 설정 편집 kubectl edit deployment/my-app # 이미지 업데이트 kubectl set image deployment/my-app container-name=new-image:tag # 환경 변수 업데이트 kubectl set env deployment/my-app ENV_VAR=new-value # 리소스 제한 업데이트 kubectl set resources deployment/my-app --requests=cpu=100m,memory=128Mi --limits=cpu=200m,memory=256Mi . 문제 해결 . # 배포 실패 시 디버깅 kubectl describe deployment/my-app # 이벤트 확인 kubectl get events --sort-by='.lastTimestamp' # 파드 로그 확인 kubectl logs -l app=my-app --tail=100 # 강제 롤백 (비상시) kubectl rollout undo deployment/my-app --force . 배포 모니터링 도구 . # 배포 상태 요약 kubectl get deployments -o wide # ReplicaSet 상태 확인 kubectl get rs -l app=my-app # 파드 상태 확인 kubectl get pods -l app=my-app # 서비스 엔드포인트 확인 kubectl get endpoints my-service . 베스트 프랙티스 . | 배포 전 테스트: 스테이징 환경에서 충분한 테스트 | 점진적 배포: 한 번에 모든 인스턴스를 업데이트하지 않기 | 모니터링: 배포 후 메트릭과 로그를 주의 깊게 관찰 | 롤백 계획: 문제 발생 시 빠른 롤백 전략 수립 | 문서화: 배포 히스토리와 변경 사항 기록 | . 리소스 삭제 . # 파드 삭제 kubectl delete pod my-pod # 디플로이먼트 삭제 kubectl delete deployment my-app # 네임스페이스 삭제 (모든 리소스 포함) kubectl delete namespace my-namespace # 라벨로 리소스 삭제 kubectl delete pods -l app=my-app . YAML 파일로 리소스 관리 . # YAML 파일로 리소스 생성 kubectl apply -f deployment.yaml # 여러 파일 적용 kubectl apply -f k8s/ # 리소스 삭제 kubectl delete -f deployment.yaml # YAML 형식으로 출력 kubectl get pod my-pod -o yaml . 네임스페이스 관리 . # 네임스페이스 생성 kubectl create namespace my-namespace # 네임스페이스 목록 조회 kubectl get namespaces # 특정 네임스페이스의 모든 리소스 조회 kubectl get all -n my-namespace . 컨텍스트 관리 . # 현재 컨텍스트 확인 kubectl config current-context # 컨텍스트 목록 조회 kubectl config get-contexts # 컨텍스트 변경 kubectl config use-context my-cluster # 클러스터 목록 조회 kubectl config get-clusters . 디버깅 도구 . # 파드 이벤트 조회 kubectl get events --sort-by='.lastTimestamp' # 노드 정보 조회 kubectl describe node my-node # 클러스터 정보 조회 kubectl cluster-info # API 리소스 목록 조회 kubectl api-resources . 이러한 명령어들을 조합하여 Kubernetes 클러스터를 효과적으로 관리할 수 있습니다. ",
    "url": "/docs/k8s/command.html#additional-useful-commands",
    
    "relUrl": "/docs/k8s/command.html#additional-useful-commands"
  },"78": {
    "doc": "git-command",
    "title": "Git 구성",
    "content": ". | 작업 디렉토리(working directory) . | 실제 파일들로 이루어져 있음 | . | 인덱스(Index) . | 준비 영역(staging area)의 역할 | . | HEAD . | 최종 확정본(commit) | . | . ",
    "url": "/docs/git/command.html#git-%EA%B5%AC%EC%84%B1",
    
    "relUrl": "/docs/git/command.html#git-구성"
  },"79": {
    "doc": "git-command",
    "title": "Branch",
    "content": " ",
    "url": "/docs/git/command.html#branch",
    
    "relUrl": "/docs/git/command.html#branch"
  },"80": {
    "doc": "git-command",
    "title": "branch는 안전하게 격리된 상태에서 작업을 할 때 사용",
    "content": ". | 저장소를 만들면 기본이 master 브랜치이다. | 다른 branch를 이용해서 개발을 진행하고, master 브랜로 돌아와 merge 한다. | . ",
    "url": "/docs/git/command.html#branch%EB%8A%94-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EA%B2%A9%EB%A6%AC%EB%90%9C-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C-%EC%9E%91%EC%97%85%EC%9D%84-%ED%95%A0-%EB%95%8C-%EC%82%AC%EC%9A%A9",
    
    "relUrl": "/docs/git/command.html#branch는-안전하게-격리된-상태에서-작업을-할-때-사용"
  },"81": {
    "doc": "git-command",
    "title": "Git 명령어",
    "content": ". | 원격 저장소 추가 | 기존에 있던 원격 저장를 추가할 때 | . git remote add origin &lt;원격 서버 주소&gt; . ",
    "url": "/docs/git/command.html#git-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/git/command.html#git-명령어"
  },"82": {
    "doc": "git-command",
    "title": "새로운 저장소 만들기",
    "content": ". | git init : 현재 폴더를 git 저장소로 만들기 | 로컬 저장소를 복제(clone) 하기 | . git clone /로컬/저장소/경로 . ",
    "url": "/docs/git/command.html#%EC%83%88%EB%A1%9C%EC%9A%B4-%EC%A0%80%EC%9E%A5%EC%86%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0",
    
    "relUrl": "/docs/git/command.html#새로운-저장소-만들기"
  },"83": {
    "doc": "git-command",
    "title": "원격 서버의 저장소 복제",
    "content": "git clone 사용자명@호스트:/원격/저장소/경로 git clone https://githugib.com/[USERNAME]/[REPOSITORY_NAME].git . ",
    "url": "/docs/git/command.html#%EC%9B%90%EA%B2%A9-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%A0%80%EC%9E%A5%EC%86%8C-%EB%B3%B5%EC%A0%9C",
    
    "relUrl": "/docs/git/command.html#원격-서버의-저장소-복제"
  },"84": {
    "doc": "git-command",
    "title": "git checkout",
    "content": "git checkout branchName git checkout -b &lt;branch name&gt; //브랜치 생성 및 이 git checkout -d &lt;branch name&gt; //delete branch git push origin &lt;branch namem&gt; //원격 저장소로 전송 전에는 다른 사용자들이 사용 불가 . ",
    "url": "/docs/git/command.html#git-checkout",
    
    "relUrl": "/docs/git/command.html#git-checkout"
  },"85": {
    "doc": "git-command",
    "title": "git add",
    "content": ". | 변경된 파일을 인덱스(staging area)에 추가 | . git add . =&gt; 해당 폴더의 모든 파일을 더하겠다 git add file_name =&gt; 해당 파일만 더하겠다 git add -i //파일을 추가할 때 대화식으로 추가하 . ",
    "url": "/docs/git/command.html#git-add",
    
    "relUrl": "/docs/git/command.html#git-add"
  },"86": {
    "doc": "git-command",
    "title": "git commit",
    "content": ". | 실제 변경 내용을 확정 | HEAD에 반영 | 원격 저장소에는 반영이 안된다. | git push를 해야 remote에 반영된다. | . ",
    "url": "/docs/git/command.html#git-commit",
    
    "relUrl": "/docs/git/command.html#git-commit"
  },"87": {
    "doc": "git-command",
    "title": "git commit 뜻",
    "content": ". | 인덱스에 추가된 변경 내용 및 새로 생성한 파일은 남는다. git checkout -- &lt;파일 이름&gt; . | . git commit -m \"commit 내용\" git commit # 이 명령어만 치면 변겨 사항을 확인하는 상태로 작성할 수 있다. ",
    "url": "/docs/git/command.html#git-commit-%EB%9C%BB",
    
    "relUrl": "/docs/git/command.html#git-commit-뜻"
  },"88": {
    "doc": "git-command",
    "title": "git pull",
    "content": ". | 로컬 저장소를 원격 저장소와 동기화 | git pull = git fetch &amp;&amp; git merge . | 변경사항을 가져오고 현재 브랜치를 remote 브랜치로 업데이트한다. | . | . git pull . ",
    "url": "/docs/git/command.html#git-pull",
    
    "relUrl": "/docs/git/command.html#git-pull"
  },"89": {
    "doc": "git-command",
    "title": "git push",
    "content": ". | HEAD의 변경 내역을 서버로 올린다. git push origin master # upstream을생성하지 않았을 때 사용 . | . ",
    "url": "/docs/git/command.html#git-push",
    
    "relUrl": "/docs/git/command.html#git-push"
  },"90": {
    "doc": "git-command",
    "title": "git pull request",
    "content": ". | merge를 해도 되는지를 요청 git pull request =&gt; 해당 변경사항에 대한 merge를 요청 . | . ",
    "url": "/docs/git/command.html#git-pull-request",
    
    "relUrl": "/docs/git/command.html#git-pull-request"
  },"91": {
    "doc": "git-command",
    "title": "git merge",
    "content": ". | 소스 파일을 병합 git merge =&gt; 변경 사항들을 병합 git merge &lt;branch name&gt; //브랜치에 있는 변경 내용을 현재 브랜치에 병합(현재 branch is a branch name is master) # ex) Current branch is dev git merge master # master 내용을 dev에 합친다. | . ",
    "url": "/docs/git/command.html#git-merge",
    
    "relUrl": "/docs/git/command.html#git-merge"
  },"92": {
    "doc": "git-command",
    "title": "reset 그림",
    "content": ". ",
    "url": "/docs/git/command.html#reset-%EA%B7%B8%EB%A6%BC",
    
    "relUrl": "/docs/git/command.html#reset-그림"
  },"93": {
    "doc": "git-command",
    "title": "git status",
    "content": ". | 현재 폴더 상태를 나타낸다. git reset --hard HEAD : HEAD로 되돌리기 | . git reset --merge : branch|merging 풀기 . ",
    "url": "/docs/git/command.html#git-status",
    
    "relUrl": "/docs/git/command.html#git-status"
  },"94": {
    "doc": "git-command",
    "title": "Git Conflict",
    "content": ". | 충돌 발생 시 충돌 부분을 수정해서 merge git diff &lt;원래 브랜치&gt; &lt;비교 대상 브랜치&gt; //변경사항 비 git fetch --all git reset --hard origin/master git pull origin/master . | . ",
    "url": "/docs/git/command.html#git-conflict",
    
    "relUrl": "/docs/git/command.html#git-conflict"
  },"95": {
    "doc": "git-command",
    "title": "git log",
    "content": ". | 로컬 변경 내용 되돌리기 | . ",
    "url": "/docs/git/command.html#git-log",
    
    "relUrl": "/docs/git/command.html#git-log"
  },"96": {
    "doc": "git-command",
    "title": "Rebase",
    "content": "브랜치 업데이트 . git rebase staging . ",
    "url": "/docs/git/command.html#rebase",
    
    "relUrl": "/docs/git/command.html#rebase"
  },"97": {
    "doc": "git-command",
    "title": "git-command",
    "content": " ",
    "url": "/docs/git/command.html",
    
    "relUrl": "/docs/git/command.html"
  },"98": {
    "doc": "What-is-Helm",
    "title": "Helm이란?",
    "content": ". | Kubernetes 환경에서 여러 서비스를 효율적으로 배포·관리할 수 있도록 도와주는 패키지 매니저입니다. | Helm Chart를 통해 서비스별 설정과 리소스를 템플릿화하여 관리합니다. | . ",
    "url": "/docs/helm/concept.html#helm%EC%9D%B4%EB%9E%80",
    
    "relUrl": "/docs/helm/concept.html#helm이란"
  },"99": {
    "doc": "What-is-Helm",
    "title": "Helm 사용 시 장점",
    "content": ". | 여러 서비스를 효율적으로 배포, 관리할 수 있다. | Git을 통해 버전 관리가 용이하다. | . ",
    "url": "/docs/helm/concept.html#helm-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%9E%A5%EC%A0%90",
    
    "relUrl": "/docs/helm/concept.html#helm-사용-시-장점"
  },"100": {
    "doc": "What-is-Helm",
    "title": "Helm Chart 구조",
    "content": ". ├── Chart.yaml # chart 버전 및 정보 ├── templates/ # 실제 yaml file 들이 들어가 있다. └── values.yaml # 변수들 . ",
    "url": "/docs/helm/concept.html#helm-chart-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/helm/concept.html#helm-chart-구조"
  },"101": {
    "doc": "What-is-Helm",
    "title": "What-is-Helm",
    "content": " ",
    "url": "/docs/helm/concept.html",
    
    "relUrl": "/docs/helm/concept.html"
  },"102": {
    "doc": "What-is-Kubernetes",
    "title": "Kubernetes란?",
    "content": "Kubernetes(쿠버네티스)는 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈소스 오케스트레이션 플랫폼입니다. Google에서 개발했으며, 현재는 Cloud Native Computing Foundation(CNCF)에서 관리하고 있습니다. ",
    "url": "/docs/k8s/concept.html#kubernetes%EB%9E%80",
    
    "relUrl": "/docs/k8s/concept.html#kubernetes란"
  },"103": {
    "doc": "What-is-Kubernetes",
    "title": "핵심 특징",
    "content": ". | 자동화된 배포: 애플리케이션을 원하는 상태로 자동 배포 | 자동 스케일링: 트래픽에 따라 자동으로 확장/축소 | 자동 복구: 장애 발생 시 자동으로 복구 | 로드 밸런싱: 트래픽을 여러 인스턴스에 분산 | 서비스 디스커버리: 마이크로서비스 간 통신 자동화 | . ",
    "url": "/docs/k8s/concept.html#%ED%95%B5%EC%8B%AC-%ED%8A%B9%EC%A7%95",
    
    "relUrl": "/docs/k8s/concept.html#핵심-특징"
  },"104": {
    "doc": "What-is-Kubernetes",
    "title": "kubernetes 쓰는 이유",
    "content": " ",
    "url": "/docs/k8s/concept.html#kubernetes-%EC%93%B0%EB%8A%94-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/k8s/concept.html#kubernetes-쓰는-이유"
  },"105": {
    "doc": "What-is-Kubernetes",
    "title": "1. 컨테이너 오케스트레이션",
    "content": ". | 수백, 수천 개의 컨테이너를 효율적으로 관리 | 복잡한 마이크로서비스 아키텍처 지원 | . ",
    "url": "/docs/k8s/concept.html#1-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%98%A4%EC%BC%80%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%85%98",
    
    "relUrl": "/docs/k8s/concept.html#1-컨테이너-오케스트레이션"
  },"106": {
    "doc": "What-is-Kubernetes",
    "title": "2. 높은 가용성",
    "content": ". | 노드 장애 시 자동으로 다른 노드로 이동 | 무중단 배포(Zero-downtime deployment) 지원 | . ",
    "url": "/docs/k8s/concept.html#2-%EB%86%92%EC%9D%80-%EA%B0%80%EC%9A%A9%EC%84%B1",
    
    "relUrl": "/docs/k8s/concept.html#2-높은-가용성"
  },"107": {
    "doc": "What-is-Kubernetes",
    "title": "3. 자동 스케일링",
    "content": ". | CPU, 메모리 사용량에 따른 자동 확장 | 수평적 확장(Horizontal scaling) 지원 | . ",
    "url": "/docs/k8s/concept.html#3-%EC%9E%90%EB%8F%99-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81",
    
    "relUrl": "/docs/k8s/concept.html#3-자동-스케일링"
  },"108": {
    "doc": "What-is-Kubernetes",
    "title": "4. 클라우드 네이티브",
    "content": ". | 클라우드 환경에 최적화 | 멀티 클라우드 지원 | . ",
    "url": "/docs/k8s/concept.html#4-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C",
    
    "relUrl": "/docs/k8s/concept.html#4-클라우드-네이티브"
  },"109": {
    "doc": "What-is-Kubernetes",
    "title": "5. 생태계",
    "content": ". | 풍부한 도구와 플러그인 | 대규모 커뮤니티 지원 | . ",
    "url": "/docs/k8s/concept.html#5-%EC%83%9D%ED%83%9C%EA%B3%84",
    
    "relUrl": "/docs/k8s/concept.html#5-생태계"
  },"110": {
    "doc": "What-is-Kubernetes",
    "title": "kubernetes를 쓰면 좋은 상황",
    "content": " ",
    "url": "/docs/k8s/concept.html#kubernetes%EB%A5%BC-%EC%93%B0%EB%A9%B4-%EC%A2%8B%EC%9D%80-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/k8s/concept.html#kubernetes를-쓰면-좋은-상황"
  },"111": {
    "doc": "What-is-Kubernetes",
    "title": "✅ Kubernetes가 적합한 상황",
    "content": "1. 대규모 마이크로서비스 . | 수십 개 이상의 서비스 | 복잡한 서비스 간 의존성 | 높은 트래픽 처리 필요 | . 2. 클라우드 네이티브 애플리케이션 . | 컨테이너 기반 아키텍처 | 자동 스케일링 필요 | 멀티 클라우드 환경 | . 3. 엔터프라이즈 환경 . | 높은 가용성 요구 | 복잡한 배포 전략 | 보안 및 규정 준수 | . 4. DevOps 문화 . | CI/CD 파이프라인 | 자동화된 운영 | 모니터링 및 로깅 | . ",
    "url": "/docs/k8s/concept.html#-kubernetes%EA%B0%80-%EC%A0%81%ED%95%A9%ED%95%9C-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/k8s/concept.html#-kubernetes가-적합한-상황"
  },"112": {
    "doc": "What-is-Kubernetes",
    "title": "Kubernetes가 과도한 상황",
    "content": "1. 단순한 애플리케이션 . | 단일 서비스 | 낮은 트래픽 | 간단한 배포 요구사항 | . 2. 소규모 팀 . | 학습 곡선이 높음 | 복잡한 운영 오버헤드 | 리소스 제약 | . 3. 레거시 시스템 . | 모놀리식 아키텍처 | 컨테이너화되지 않은 애플리케이션 | 급진적인 변화가 어려운 환경 | . ",
    "url": "/docs/k8s/concept.html#kubernetes%EA%B0%80-%EA%B3%BC%EB%8F%84%ED%95%9C-%EC%83%81%ED%99%A9",
    
    "relUrl": "/docs/k8s/concept.html#kubernetes가-과도한-상황"
  },"113": {
    "doc": "What-is-Kubernetes",
    "title": "kubernetes architecture diagram",
    "content": " ",
    "url": "/docs/k8s/concept.html#kubernetes-architecture-diagram",
    
    "relUrl": "/docs/k8s/concept.html#kubernetes-architecture-diagram"
  },"114": {
    "doc": "What-is-Kubernetes",
    "title": "전체 아키텍처",
    "content": "graph TB subgraph \"Control Plane (Master Node)\" API[\"API Server\"] ETCD[(etcd)] Scheduler[Scheduler] Controller[\"Controller Manager\"] Cloud[\"Cloud Controller Manager\"] end subgraph \"Worker Nodes\" Kubelet1[Kubelet] Proxy1[kube-proxy] Container1[\"Container Runtime\"] Kubelet2[Kubelet] Proxy2[kube-proxy] Container2[\"Container Runtime\"] Kubelet3[Kubelet] Proxy3[kube-proxy] Container3[\"Container Runtime\"] end subgraph \"Applications\" Pod1[\"Pod 1\"] Pod2[\"Pod 2\"] Pod3[\"Pod 3\"] Pod4[\"Pod 4\"] end API --&gt; ETCD API --&gt; Scheduler API --&gt; Controller API --&gt; Cloud Scheduler --&gt; Kubelet1 Scheduler --&gt; Kubelet2 Scheduler --&gt; Kubelet3 Kubelet1 --&gt; Container1 Kubelet2 --&gt; Container2 Kubelet3 --&gt; Container3 Container1 --&gt; Pod1 Container1 --&gt; Pod2 Container2 --&gt; Pod3 Container3 --&gt; Pod4 Proxy1 --&gt; Pod1 Proxy1 --&gt; Pod2 Proxy2 --&gt; Pod3 Proxy3 --&gt; Pod4 . ",
    "url": "/docs/k8s/concept.html#%EC%A0%84%EC%B2%B4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98",
    
    "relUrl": "/docs/k8s/concept.html#전체-아키텍처"
  },"115": {
    "doc": "What-is-Kubernetes",
    "title": "컴포넌트 설명",
    "content": "Control Plane (마스터 노드) . | API Server: 클러스터의 통합 엔트리 포인트 | etcd: 클러스터 데이터 저장소 | Scheduler: Pod를 적절한 노드에 배치 | Controller Manager: 클러스터 상태 관리 | Cloud Controller Manager: 클라우드 제공자와 연동 | . Worker Nodes (워커 노드) . | Kubelet: 노드의 Pod 관리 | kube-proxy: 네트워크 통신 관리 | Container Runtime: 컨테이너 실행 (Docker, containerd 등) | . ",
    "url": "/docs/k8s/concept.html#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/k8s/concept.html#컴포넌트-설명"
  },"116": {
    "doc": "What-is-Kubernetes",
    "title": "Pod 생명주기",
    "content": "stateDiagram-v2 [*] --&gt; Pending Pending --&gt; Running : Pod scheduled Running --&gt; Succeeded : Job completed Running --&gt; Failed : Error occurred Running --&gt; Unknown : Node unreachable Succeeded --&gt; [*] Failed --&gt; [*] Unknown --&gt; [*] . ",
    "url": "/docs/k8s/concept.html#pod-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0",
    
    "relUrl": "/docs/k8s/concept.html#pod-생명주기"
  },"117": {
    "doc": "What-is-Kubernetes",
    "title": "kubernetes vs docker compose",
    "content": " ",
    "url": "/docs/k8s/concept.html#kubernetes-vs-docker-compose",
    
    "relUrl": "/docs/k8s/concept.html#kubernetes-vs-docker-compose"
  },"118": {
    "doc": "What-is-Kubernetes",
    "title": "비교표",
    "content": "| 구분 | Kubernetes | Docker Compose | . | 용도 | 프로덕션 오케스트레이션 | 개발/테스트 환경 | . | 규모 | 수백~수천 컨테이너 | 수십 개 컨테이너 | . | 복잡도 | 높음 (학습 곡선 가파름) | 낮음 (간단한 YAML) | . | 자동화 | 고도 자동화 (스케일링, 복구) | 수동 관리 | . | 스케일링 | 자동 수평 스케일링 | 수동 스케일링 | . | 로드 밸런싱 | 내장 로드 밸런서 | 외부 도구 필요 | . | 서비스 디스커버리 | 내장 | 수동 설정 | . | 배포 전략 | Rolling, Blue/Green, Canary | 단순 배포 | . | 모니터링 | 풍부한 메트릭 | 기본 로그만 | . | 보안 | RBAC, 네트워크 정책 | 기본 보안 | . | 리소스 관리 | CPU/메모리 제한 | 기본 제한 | . | 학습 비용 | 높음 (몇 주~몇 달) | 낮음 (몇 시간) | . | 운영 오버헤드 | 높음 | 낮음 | . | 클라우드 지원 | 모든 클라우드 지원 | 제한적 | . ",
    "url": "/docs/k8s/concept.html#%EB%B9%84%EA%B5%90%ED%91%9C",
    
    "relUrl": "/docs/k8s/concept.html#비교표"
  },"119": {
    "doc": "What-is-Kubernetes",
    "title": "언제 어떤 것을 사용할까?",
    "content": "Docker Compose 사용 시기 . | ✅ 개발 환경에서 빠른 프로토타이핑 | ✅ 단순한 애플리케이션 (웹앱 + DB) | ✅ 소규모 팀 (DevOps 전문가 없음) | ✅ 테스트 환경 구축 | ✅ 학습 목적 (컨테이너 개념 이해) | . Kubernetes 사용 시기 . | ✅ 프로덕션 환경에서 대규모 서비스 | ✅ 마이크로서비스 아키텍처 | ✅ 높은 가용성 요구 | ✅ 자동 스케일링 필요 | ✅ 복잡한 배포 전략 (Canary, Blue/Green) | ✅ 멀티 클라우드 환경 | . ",
    "url": "/docs/k8s/concept.html#%EC%96%B8%EC%A0%9C-%EC%96%B4%EB%96%A4-%EA%B2%83%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C",
    
    "relUrl": "/docs/k8s/concept.html#언제-어떤-것을-사용할까"
  },"120": {
    "doc": "What-is-Kubernetes",
    "title": "마이그레이션 전략",
    "content": "graph LR A[\"Simple Application\"] --&gt; B[\"Docker Compose\"] B --&gt; C[\"Complex Requirements\"] C --&gt; D[\"Kubernetes\"] E[\"Team Growth\"] --&gt; F[\"DevOps Adoption\"] F --&gt; D G[\"Traffic Increase\"] --&gt; H[\"Scaling Needed\"] H --&gt; D . ",
    "url": "/docs/k8s/concept.html#%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%EC%A0%84%EB%9E%B5",
    
    "relUrl": "/docs/k8s/concept.html#마이그레이션-전략"
  },"121": {
    "doc": "What-is-Kubernetes",
    "title": "What-is-Kubernetes",
    "content": " ",
    "url": "/docs/k8s/concept.html",
    
    "relUrl": "/docs/k8s/concept.html"
  },"122": {
    "doc": "ConfigMap",
    "title": "ConfigMap 개요",
    "content": "ConfigMap은 Kubernetes에서 설정 데이터를 Pod와 분리하여 관리하는 리소스입니다. 애플리케이션의 설정 파일, 환경변수, 명령행 인수 등을 외부화하여 컨테이너 이미지와 독립적으로 관리할 수 있습니다. ConfigMap의 특징 . | 설정 분리: 애플리케이션 코드와 설정을 분리 | 환경별 관리: 개발, 스테이징, 프로덕션 환경별 설정 관리 | 동적 업데이트: Pod 재시작 없이 설정 변경 가능 (일부 경우) | 보안: 민감한 정보는 Secret을 사용하여 관리 | . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-개요"
  },"123": {
    "doc": "ConfigMap",
    "title": "ConfigMap 구조",
    "content": "graph TD A[ConfigMap] --&gt; B[Key-Value Pairs] A --&gt; C[Configuration Files] A --&gt; D[Environment Variables] B --&gt; E[app.properties] B --&gt; F[database.conf] B --&gt; G[nginx.conf] H[Pod] --&gt; I[Container] I --&gt; J[Volume Mount] I --&gt; K[Environment Variable] J --&gt; L[/etc/config/app.properties] K --&gt; M[APP_CONFIG=database.conf] style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#f3e5f5 style D fill:#f3e5f5 style H fill:#e8f5e8 style I fill:#fff3e0 style J fill:#e3f2fd style K fill:#e3f2fd . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-구조"
  },"124": {
    "doc": "ConfigMap",
    "title": "ConfigMap 생성 방법",
    "content": "1. 명령행에서 생성 . # 키-값 쌍으로 생성 kubectl create configmap my-config --from-literal=key1=value1 --from-literal=key2=value2 # 파일에서 생성 kubectl create configmap my-config --from-file=app.properties --from-file=database.conf # 디렉토리에서 생성 kubectl create configmap my-config --from-file=./config/ # 환경변수 파일에서 생성 kubectl create configmap my-config --from-env-file=app.env . 2. YAML 파일로 생성 . apiVersion: v1 kind: ConfigMap metadata: name: my-config namespace: default data: # 키-값 쌍 log-level: \"INFO\" database-url: \"postgresql://user:pass@db:5432/mydb\" # 설정 파일 app.properties: | server.port=8080 logging.level.root=INFO spring.profiles.active=production nginx.conf: | server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; } } database.conf: | [database] host=db.example.com port=5432 name=myapp user=appuser . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-생성-방법"
  },"125": {
    "doc": "ConfigMap",
    "title": "ConfigMap 사용 방법",
    "content": "1. 환경변수로 사용 . apiVersion: v1 kind: Pod metadata: name: config-pod spec: containers: - name: app image: myapp:1.0 env: # 단일 값 - name: LOG_LEVEL valueFrom: configMapKeyRef: name: my-config key: log-level # 전체 ConfigMap을 환경변수로 envFrom: - configMapRef: name: my-config . 2. 볼륨으로 마운트 . apiVersion: v1 kind: Pod metadata: name: config-pod spec: containers: - name: app image: myapp:1.0 volumeMounts: - name: config-volume mountPath: /etc/config readOnly: true - name: nginx-config mountPath: /etc/nginx/conf.d readOnly: true volumes: - name: config-volume configMap: name: my-config items: - key: app.properties path: app.properties - key: database.conf path: database.conf - name: nginx-config configMap: name: my-config items: - key: nginx.conf path: default.conf . 3. 하위 경로로 마운트 . apiVersion: v1 kind: Pod metadata: name: config-pod spec: containers: - name: app image: myapp:1.0 volumeMounts: - name: config-volume mountPath: /etc/config readOnly: true volumes: - name: config-volume configMap: name: my-config # 전체 ConfigMap을 개별 파일로 마운트 . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-사용-방법"
  },"126": {
    "doc": "ConfigMap",
    "title": "ConfigMap 예시",
    "content": "1. 웹 애플리케이션 설정 . apiVersion: v1 kind: ConfigMap metadata: name: web-app-config data: # 환경변수 NODE_ENV: \"production\" PORT: \"8080\" DATABASE_URL: \"postgresql://user:pass@db:5432/webapp\" # 설정 파일 config.json: | { \"server\": { \"port\": 8080, \"host\": \"0.0.0.0\" }, \"database\": { \"host\": \"db.example.com\", \"port\": 5432, \"name\": \"webapp\" }, \"logging\": { \"level\": \"info\", \"format\": \"json\" } } nginx.conf: | server { listen 80; server_name localhost; location / { proxy_pass http://localhost:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; } } . 2. 데이터베이스 설정 . apiVersion: v1 kind: ConfigMap metadata: name: database-config data: # PostgreSQL 설정 postgresql.conf: | # 기본 설정 listen_addresses = '*' port = 5432 max_connections = 100 # 메모리 설정 shared_buffers = 256MB effective_cache_size = 1GB # 로깅 설정 log_destination = 'stderr' logging_collector = on log_directory = 'log' log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log' # 초기화 스크립트 init.sql: | CREATE DATABASE myapp; CREATE USER appuser WITH PASSWORD 'password'; GRANT ALL PRIVILEGES ON DATABASE myapp TO appuser; # 환경변수 POSTGRES_DB: \"myapp\" POSTGRES_USER: \"appuser\" POSTGRES_PASSWORD: \"password\" . 3. 마이크로서비스 설정 . apiVersion: v1 kind: ConfigMap metadata: name: microservice-config data: # API 서비스 설정 api-service.properties: | server.port=8080 spring.application.name=api-service spring.profiles.active=production # 데이터베이스 설정 spring.datasource.url=jdbc:postgresql://db:5432/myapp spring.datasource.username=appuser spring.datasource.password=password # 로깅 설정 logging.level.root=INFO logging.level.com.myapp=DEBUG # 보안 설정 security.oauth2.client.client-id=myapp security.oauth2.client.client-secret=secret # 사용자 서비스 설정 user-service.properties: | server.port=8081 spring.application.name=user-service spring.profiles.active=production # 데이터베이스 설정 spring.datasource.url=jdbc:postgresql://db:5432/users spring.datasource.username=userapp spring.datasource.password=password # 캐시 설정 spring.cache.type=redis spring.redis.host=redis spring.redis.port=6379 # 주문 서비스 설정 order-service.properties: | server.port=8082 spring.application.name=order-service spring.profiles.active=production # 데이터베이스 설정 spring.datasource.url=jdbc:postgresql://db:5432/orders spring.datasource.username=orderapp spring.datasource.password=password # 메시징 설정 spring.kafka.bootstrap-servers=kafka:9092 spring.kafka.consumer.group-id=order-service . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-예시"
  },"127": {
    "doc": "ConfigMap",
    "title": "ConfigMap 관리 명령어",
    "content": "기본 명령어 . # ConfigMap 생성 kubectl create configmap my-config --from-literal=key=value kubectl apply -f configmap.yaml # ConfigMap 목록 확인 kubectl get configmaps kubectl get cm # ConfigMap 상세 정보 확인 kubectl describe configmap &lt;configmap-name&gt; # ConfigMap 내용 확인 kubectl get configmap &lt;configmap-name&gt; -o yaml # ConfigMap 삭제 kubectl delete configmap &lt;configmap-name&gt; . 편집 명령어 . # ConfigMap 편집 kubectl edit configmap &lt;configmap-name&gt; # ConfigMap 복사 kubectl get configmap &lt;source-configmap&gt; -o yaml | sed 's/name: &lt;source-configmap&gt;/name: &lt;target-configmap&gt;/' | kubectl apply -f - # ConfigMap 내보내기 kubectl get configmap &lt;configmap-name&gt; -o yaml &gt; configmap-backup.yaml . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-관리-명령어"
  },"128": {
    "doc": "ConfigMap",
    "title": "ConfigMap 업데이트",
    "content": "1. ConfigMap 업데이트 . # ConfigMap 업데이트 kubectl patch configmap my-config -p '{\"data\":{\"log-level\":\"DEBUG\"}}' # 또는 편집 kubectl edit configmap my-config . 2. Pod 재시작 없이 업데이트 . apiVersion: apps/v1 kind: Deployment metadata: name: my-app spec: template: spec: containers: - name: app image: myapp:1.0 volumeMounts: - name: config-volume mountPath: /etc/config readOnly: true volumes: - name: config-volume configMap: name: my-config # ConfigMap 변경 시 Pod 재시작 annotations: checksum/config: \"${CONFIG_CHECKSUM}\" . 3. 자동 재시작 스크립트 . #!/bin/bash # ConfigMap 변경 시 Deployment 재시작 CONFIGMAP_NAME=\"my-config\" DEPLOYMENT_NAME=\"my-app\" # ConfigMap의 체크섬 계산 CHECKSUM=$(kubectl get configmap $CONFIGMAP_NAME -o yaml | sha256sum | cut -d' ' -f1) # Deployment 패치 kubectl patch deployment $DEPLOYMENT_NAME -p \"{\\\"spec\\\":{\\\"template\\\":{\\\"metadata\\\":{\\\"annotations\\\":{\\\"checksum/config\\\":\\\"$CHECKSUM\\\"}}}}}\" . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-업데이트"
  },"129": {
    "doc": "ConfigMap",
    "title": "ConfigMap 사용 사례",
    "content": "1. 환경별 설정 관리 . # 개발 환경 apiVersion: v1 kind: ConfigMap metadata: name: app-config-dev namespace: development data: LOG_LEVEL: \"DEBUG\" DATABASE_URL: \"postgresql://dev:dev@localhost:5432/devdb\" API_URL: \"http://localhost:3000\" --- # 스테이징 환경 apiVersion: v1 kind: ConfigMap metadata: name: app-config-staging namespace: staging data: LOG_LEVEL: \"INFO\" DATABASE_URL: \"postgresql://staging:staging@db-staging:5432/stagingdb\" API_URL: \"https://api-staging.example.com\" --- # 프로덕션 환경 apiVersion: v1 kind: ConfigMap metadata: name: app-config-prod namespace: production data: LOG_LEVEL: \"WARN\" DATABASE_URL: \"postgresql://prod:prod@db-prod:5432/proddb\" API_URL: \"https://api.example.com\" . 2. 설정 파일 관리 . apiVersion: v1 kind: ConfigMap metadata: name: application-config data: # 애플리케이션 설정 application.yml: | spring: application: name: myapp profiles: active: production datasource: url: jdbc:postgresql://db:5432/myapp username: appuser password: password jpa: hibernate: ddl-auto: validate show-sql: false logging: level: root: INFO com.myapp: DEBUG # 로그백 설정 logback.xml: | &lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; # Nginx 설정 nginx.conf: | events { worker_connections 1024; } http { upstream backend { server app:8080; } server { listen 80; location / { proxy_pass http://backend; } } } . 3. 기능 플래그 관리 . apiVersion: v1 kind: ConfigMap metadata: name: feature-flags data: features.json: | { \"newUI\": true, \"darkMode\": false, \"analytics\": true, \"betaFeatures\": { \"advancedSearch\": true, \"realTimeUpdates\": false, \"aiRecommendations\": true }, \"experiments\": { \"abTest1\": { \"enabled\": true, \"weight\": 0.5 }, \"abTest2\": { \"enabled\": false, \"weight\": 0.0 } } } feature-flags.properties: | feature.new-ui.enabled=true feature.dark-mode.enabled=false feature.analytics.enabled=true feature.advanced-search.enabled=true feature.real-time-updates.enabled=false feature.ai-recommendations.enabled=true experiment.ab-test-1.enabled=true experiment.ab-test-1.weight=0.5 experiment.ab-test-2.enabled=false experiment.ab-test-2.weight=0.0 . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-사용-사례"
  },"130": {
    "doc": "ConfigMap",
    "title": "ConfigMap vs Secret",
    "content": "| 특징 | ConfigMap | Secret | . | 용도 | 일반 설정 데이터 | 민감한 데이터 | . | 암호화 | Base64 인코딩만 | 암호화 저장 | . | 볼륨 마운트 | 지원 | 지원 | . | 환경변수 | 지원 | 지원 | . | 사용 사례 | 애플리케이션 설정 | 비밀번호, 토큰 | . ",
    "url": "/docs/k8s/componentes/configmap.html#configmap-vs-secret",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#configmap-vs-secret"
  },"131": {
    "doc": "ConfigMap",
    "title": "주의사항",
    "content": ". | 크기 제한: ConfigMap은 1MB로 제한됩니다 | 민감한 정보: 비밀번호, 토큰 등은 Secret을 사용해야 합니다 | 업데이트: ConfigMap 변경 시 Pod 재시작이 필요할 수 있습니다 | 네임스페이스: ConfigMap은 네임스페이스 범위입니다 | 버전 관리: 설정 변경 시 버전 관리를 고려해야 합니다 | . ",
    "url": "/docs/k8s/componentes/configmap.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/configmap.html#주의사항"
  },"132": {
    "doc": "ConfigMap",
    "title": "ConfigMap",
    "content": " ",
    "url": "/docs/k8s/componentes/configmap.html",
    
    "relUrl": "/docs/k8s/componentes/configmap.html"
  },"133": {
    "doc": "What-is-Container-Runtime",
    "title": "What is container runtime",
    "content": ". | 컨테이너 런타임은 컨테이너 이미지를 실제로 실행하고 관리하는 소프트웨어입니다. | 컨테이너의 생성, 시작, 중지, 삭제 등 라이프사이클을 담당합니다. | 주요 특징 . | 컨테이너 프로세스의 격리와 자원 할당 관리 . | 자원: 네트워크, 볼륨, CPU, 메모리 등 | . | 표준 인터페이스(OCI, CRI 등) 지원 | 컨테이너의 보안, 네트워크, 스토리지 등 다양한 기능 제공 | . | . ",
    "url": "/docs/all-container/container-runtime.html#what-is-container-runtime",
    
    "relUrl": "/docs/all-container/container-runtime.html#what-is-container-runtime"
  },"134": {
    "doc": "What-is-Container-Runtime",
    "title": "대표적인 런타임",
    "content": "Docker . | 설명: 초기에는 컨테이너 엔진과 런타임을 모두 포함한 올인원 솔루션이었으나, 현재는 런타임 역할을 containerd에 위임함. | 장점: . | 사용이 쉽고, 생태계(도구, 문서, 커뮤니티)가 매우 풍부함 | 로컬 개발 및 테스트에 적합 | 다양한 플랫폼 지원 | . | 단점: . | 오버헤드가 상대적으로 있음(엔진+런타임 구조) | Kubernetes와 직접 연동이 비효율적(추가 계층 필요) | . | . containerd . | 설명: . | Docker에서 분리된 경량화된 컨테이너 런타임. Kubernetes의 기본 런타임으로 채택됨. | . | 장점: . | 경량화되어 있고, 성능이 우수함 | Kubernetes와의 연동이 뛰어남(CRI 지원) | 안정적이고 대규모 환경에 적합 | . | 단점: . | Docker에 비해 직접 사용 시 기능이 제한적(빌드, 네트워크 등) | image build 명령어가 없음 | CLI 등 사용자 친화적 도구가 적음 | . | . CRI-O . | 설명: Kubernetes를 위해 설계된 매우 경량화된 컨테이너 런타임. 오직 Kubernetes와의 연동만을 목표로 함. | 장점: . | 매우 가볍고, 보안에 초점을 맞춤 | Kubernetes와의 호환성이 뛰어남 | 불필요한 기능이 없어 관리가 용이 | podman 명령어를 설치해서 쓰면 도커 명령어를 podman으로 사용 가능 | . podman images podman rmi podman ps . | 단점: . | 범용성이 떨어짐(Kubernetes 외 환경에서 사용 어려움) | 커뮤니티와 생태계가 상대적으로 작음 | . | . ",
    "url": "/docs/all-container/container-runtime.html#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%EB%9F%B0%ED%83%80%EC%9E%84",
    
    "relUrl": "/docs/all-container/container-runtime.html#대표적인-런타임"
  },"135": {
    "doc": "What-is-Container-Runtime",
    "title": "개발자가 추가로 알아야 할 점",
    "content": ". | Kubernetes 등 오케스트레이션 도구는 컨테이너 런타임과 연동하여 컨테이너를 관리함 | 런타임 선택에 따라 성능, 보안, 운영 방식이 달라질 수 있음 | OCI(Open Container Initiative) 표준을 지원하는 런타임을 사용하는 것이 호환성과 유지보수에 유리함 | 런타임은 컨테이너의 보안, 네트워크, 스토리지 등 다양한 기능에 영향을 미침 | . ",
    "url": "/docs/all-container/container-runtime.html#%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%B6%94%EA%B0%80%EB%A1%9C-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EC%A0%90",
    
    "relUrl": "/docs/all-container/container-runtime.html#개발자가-추가로-알아야-할-점"
  },"136": {
    "doc": "What-is-Container-Runtime",
    "title": "What-is-Container-Runtime",
    "content": " ",
    "url": "/docs/all-container/container-runtime.html",
    
    "relUrl": "/docs/all-container/container-runtime.html"
  },"137": {
    "doc": "What-is-Container",
    "title": "What is container",
    "content": ". | 컨테이너는 애플리케이션과 그 실행에 필요한 모든 라이브러리, 설정 파일, 종속성을 하나의 패키지로 묶어, 어디서든 일관되게 실행할 수 있도록 해주는 기술입니다. | 컨테이너는 운영체제 수준에서 격리되어 실행되며, 가상머신보다 가볍고 빠릅니다. | 주요 특징 . | 애플리케이션 실행 환경을 표준화 . | web app . | node app | . | server app . | spring boot application | . | . | 빠른 배포 및 확장 가능 | 리소스 효율적(가상머신보다 오버헤드 적음) | 격리된 환경 제공(보안성↑) | . | 개발자가 알아야 할 점 . | 컨테이너는 호스트 OS의 커널을 공유함 | 컨테이너 내부와 외부의 네트워크, 파일시스템, 프로세스가 분리됨 | 대표적인 컨테이너 엔진: Docker, containerd, crio | . | . ",
    "url": "/docs/all-container/container.html#what-is-container",
    
    "relUrl": "/docs/all-container/container.html#what-is-container"
  },"138": {
    "doc": "What-is-Container",
    "title": "What is container image",
    "content": ". | 컨테이너 이미지는 컨테이너를 실행하기 위한 모든 파일, 라이브러리, 설정, 코드 등을 포함한 불변(immutable)한 패키지입니다. | 이미지는 여러 계층(layer)으로 구성되어 있고, 읽기 전용입니다. | 주요 특징 . | 컨테이너 실행의 ‘설계도’ 역할 | Dockerfile 등으로 이미지를 정의하고 빌드 | 이미지 레지스트리(예: Docker Hub, Google Container Registry, harbor, docker registry)에 저장 및 배포 | . | 개발자가 알아야 할 점 . | 이미지는 계층 구조로 되어 있어, 중복된 계층은 캐싱되어 효율적 | 이미지를 작게 만들기 위해 불필요한 파일/패키지 제외 필요 | 보안 취약점이 없는 베이스 이미지를 사용하는 것이 중요 | . | . ",
    "url": "/docs/all-container/container.html#what-is-container-image",
    
    "relUrl": "/docs/all-container/container.html#what-is-container-image"
  },"139": {
    "doc": "What-is-Container",
    "title": "How to write a Dockerfile",
    "content": "Dockerfile은 컨테이너 이미지를 만들기 위한 설정 파일로, 이미지 빌드 과정을 단계별로 명시합니다. ",
    "url": "/docs/all-container/container.html#how-to-write-a-dockerfile",
    
    "relUrl": "/docs/all-container/container.html#how-to-write-a-dockerfile"
  },"140": {
    "doc": "What-is-Container",
    "title": "기본 문법",
    "content": ". | FROM: 베이스 이미지 지정 (필수) | RUN: 명령어 실행 (이미지 빌드 시) | COPY/ADD: 파일/디렉토리 복사 | WORKDIR: 작업 디렉토리 설정 | ENV: 환경 변수 설정 | EXPOSE: 컨테이너가 열 포트 지정(문서화 목적) | CMD/ENTRYPOINT: 컨테이너 시작 시 실행할 명령 | . ",
    "url": "/docs/all-container/container.html#%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95",
    
    "relUrl": "/docs/all-container/container.html#기본-문법"
  },"141": {
    "doc": "What-is-Container",
    "title": "예시: Node.js 애플리케이션",
    "content": "# 1. 베이스 이미지 지정 FROM node:18-alpine # 2. 작업 디렉토리 생성 및 이동 WORKDIR /app # 3. 의존성 파일 복사 및 설치 COPY package*.json ./ RUN npm install # 4. 소스 코드 복사 # COPY {local directory or file} {container directory or file} COPY . # 5. 컨테이너가 열 포트 지정(문서화 목적) EXPOSE 3000 # 6. 컨테이너 시작 시 실행할 명령 CMD [ \"npm\", \"start\" ] . ",
    "url": "/docs/all-container/container.html#%EC%98%88%EC%8B%9C-nodejs-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98",
    
    "relUrl": "/docs/all-container/container.html#예시-nodejs-애플리케이션"
  },"142": {
    "doc": "What-is-Container",
    "title": "개발자가 알아야 할 점",
    "content": ". | 불필요한 파일은 .dockerignore로 제외하여 이미지 용량 최소화 | 보안상 신뢰할 수 있는 베이스 이미지를 사용 | 멀티스테이지 빌드로 빌드/런타임 환경 분리 가능 | 계층 구조를 이해하고, 캐시 효율을 높이기 위해 자주 변경되는 파일은 아래쪽에 COPY | . ",
    "url": "/docs/all-container/container.html#%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-%EC%A0%90",
    
    "relUrl": "/docs/all-container/container.html#개발자가-알아야-할-점"
  },"143": {
    "doc": "What-is-Container",
    "title": "What-is-Container",
    "content": " ",
    "url": "/docs/all-container/container.html",
    
    "relUrl": "/docs/all-container/container.html"
  },"144": {
    "doc": "Deployment",
    "title": "Deployment 개요",
    "content": "Deployment는 Kubernetes에서 가장 일반적으로 사용되는 워크로드 리소스입니다. Pod와 ReplicaSet을 관리하여 애플리케이션의 배포, 업데이트, 스케일링을 자동화합니다. Deployment의 특징 . | 선언적 업데이트: 원하는 상태를 선언하면 자동으로 현재 상태를 목표 상태로 변경 | 롤링 업데이트: 무중단 배포를 위한 점진적 업데이트 | 롤백 기능: 이전 버전으로 쉽게 되돌릴 수 있음 | 스케일링: Pod 개수를 쉽게 조정 가능 | . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-개요"
  },"145": {
    "doc": "Deployment",
    "title": "Deployment 구조",
    "content": "graph TD A[Deployment Controller] --&gt; B[ReplicaSet v1] A --&gt; C[ReplicaSet v2] A --&gt; D[ReplicaSet v3] B --&gt; E[Pod 1] B --&gt; F[Pod 2] B --&gt; G[Pod 3] C --&gt; H[Pod 1] C --&gt; I[Pod 2] C --&gt; J[Pod 3] D --&gt; K[Pod 1] D --&gt; L[Pod 2] D --&gt; M[Pod 3] style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#f3e5f5 style D fill:#f3e5f5 style E fill:#e8f5e8 style F fill:#e8f5e8 style G fill:#e8f5e8 style H fill:#e8f5e8 style I fill:#e8f5e8 style J fill:#e8f5e8 style K fill:#e8f5e8 style L fill:#e8f5e8 style M fill:#e8f5e8 . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-구조"
  },"146": {
    "doc": "Deployment",
    "title": "Deployment 예시",
    "content": "기본 Deployment . apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 resources: requests: memory: \"64Mi\" cpu: \"250m\" limits: memory: \"128Mi\" cpu: \"500m\" . 환경변수가 있는 Deployment . apiVersion: apps/v1 kind: Deployment metadata: name: web-app labels: app: web spec: replicas: 2 selector: matchLabels: app: web template: metadata: labels: app: web spec: containers: - name: web image: myapp:1.0 ports: - containerPort: 8080 env: - name: DATABASE_URL value: \"postgresql://user:pass@db:5432/mydb\" - name: API_KEY valueFrom: secretKeyRef: name: app-secret key: api-key - name: LOG_LEVEL value: \"INFO\" envFrom: - configMapRef: name: app-config . 볼륨이 있는 Deployment . apiVersion: apps/v1 kind: Deployment metadata: name: app-with-storage spec: replicas: 3 selector: matchLabels: app: storage-app template: metadata: labels: app: storage-app spec: containers: - name: app image: myapp:1.0 ports: - containerPort: 8080 volumeMounts: - name: config-volume mountPath: /app/config - name: data-volume mountPath: /app/data volumes: - name: config-volume configMap: name: app-config - name: data-volume persistentVolumeClaim: claimName: app-data-pvc . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-예시"
  },"147": {
    "doc": "Deployment",
    "title": "Deployment 업데이트 전략",
    "content": "Rolling Update (기본값) . apiVersion: apps/v1 kind: Deployment metadata: name: rolling-update-deployment spec: replicas: 5 strategy: type: RollingUpdate rollingUpdate: maxSurge: 1 # 최대 추가 Pod 수 maxUnavailable: 1 # 최대 사용 불가 Pod 수 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 . Recreate 전략 . apiVersion: apps/v1 kind: Deployment metadata: name: recreate-deployment spec: replicas: 3 strategy: type: Recreate # 모든 Pod를 삭제 후 새로 생성 selector: matchLabels: app: app template: metadata: labels: app: app spec: containers: - name: app image: myapp:1.0 ports: - containerPort: 8080 . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%A0%84%EB%9E%B5",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-업데이트-전략"
  },"148": {
    "doc": "Deployment",
    "title": "Deployment 업데이트 과정",
    "content": "graph LR A[Deployment v1] --&gt; B[ReplicaSet v1] B --&gt; C[Pod v1.1] B --&gt; D[Pod v1.2] B --&gt; E[Pod v1.3] F[Deployment v2] --&gt; G[ReplicaSet v2] G --&gt; H[Pod v2.1] G --&gt; I[Pod v2.2] G --&gt; J[Pod v2.3] style A fill:#e1f5fe style F fill:#e1f5fe style B fill:#f3e5f5 style G fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#e8f5e8 style E fill:#e8f5e8 style H fill:#e8f5e8 style I fill:#e8f5e8 style J fill:#e8f5e8 . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-업데이트-과정"
  },"149": {
    "doc": "Deployment",
    "title": "Deployment 관리 명령어",
    "content": "기본 명령어 . # Deployment 생성 kubectl apply -f deployment.yaml # Deployment 목록 확인 kubectl get deployments kubectl get deployments -o wide # Deployment 상세 정보 확인 kubectl describe deployment &lt;deployment-name&gt; # Deployment 스케일링 kubectl scale deployment &lt;deployment-name&gt; --replicas=5 # Deployment 삭제 kubectl delete deployment &lt;deployment-name&gt; . 업데이트 명령어 . # 이미지 업데이트 kubectl set image deployment/&lt;deployment-name&gt; &lt;container-name&gt;=&lt;new-image&gt; # 환경변수 설정 kubectl set env deployment/&lt;deployment-name&gt; KEY=value # 롤아웃 상태 확인 kubectl rollout status deployment/&lt;deployment-name&gt; # 롤아웃 히스토리 확인 kubectl rollout history deployment/&lt;deployment-name&gt; # 이전 버전으로 롤백 kubectl rollout undo deployment/&lt;deployment-name&gt; # 특정 리비전으로 롤백 kubectl rollout undo deployment/&lt;deployment-name&gt; --to-revision=2 # 롤아웃 일시 중지 kubectl rollout pause deployment/&lt;deployment-name&gt; # 롤아웃 재개 kubectl rollout resume deployment/&lt;deployment-name&gt; . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-관리-명령어"
  },"150": {
    "doc": "Deployment",
    "title": "Deployment 상태 모니터링",
    "content": "상태 확인 . # Deployment 상태 kubectl get deployment nginx-deployment # Pod 상태 kubectl get pods -l app=nginx # ReplicaSet 상태 kubectl get rs -l app=nginx # 이벤트 확인 kubectl get events --sort-by='.lastTimestamp' # 로그 확인 kubectl logs -l app=nginx . 상태 설명 . | 상태 | 설명 | . | Available | 최소 요구 복제본 수가 사용 가능 | . | Progressing | 새로운 ReplicaSet이 생성 중이거나 업데이트 중 | . | ReplicaFailure | ReplicaSet 생성 중 오류 발생 | . | Condition | Deployment의 현재 상태를 나타내는 조건들 | . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EC%83%81%ED%83%9C-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-상태-모니터링"
  },"151": {
    "doc": "Deployment",
    "title": "Deployment 사용 사례",
    "content": "1. 웹 애플리케이션 . apiVersion: apps/v1 kind: Deployment metadata: name: web-app labels: app: web spec: replicas: 3 selector: matchLabels: app: web template: metadata: labels: app: web spec: containers: - name: web image: nginx:1.14.2 ports: - containerPort: 80 livenessProbe: httpGet: path: / port: 80 initialDelaySeconds: 30 periodSeconds: 10 readinessProbe: httpGet: path: / port: 80 initialDelaySeconds: 5 periodSeconds: 5 . 2. API 서버 . apiVersion: apps/v1 kind: Deployment metadata: name: api-server spec: replicas: 5 selector: matchLabels: app: api template: metadata: labels: app: api spec: containers: - name: api image: myapi:2.0 ports: - containerPort: 8080 env: - name: NODE_ENV value: \"production\" - name: DB_HOST valueFrom: configMapKeyRef: name: api-config key: database_host resources: requests: memory: \"256Mi\" cpu: \"500m\" limits: memory: \"512Mi\" cpu: \"1000m\" . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-사용-사례"
  },"152": {
    "doc": "Deployment",
    "title": "Deployment vs StatefulSet",
    "content": "| 특징 | Deployment | StatefulSet | . | Pod 식별자 | 임의의 이름 | 고유한 이름 (app-0, app-1, …) | . | 스토리지 | 공유 스토리지 | 각 Pod마다 고유한 PVC | . | 네트워크 | 공통 서비스 이름 | 고유한 DNS 이름 | . | 확장 순서 | 무작위 순서 | 순서대로 확장/축소 | . | 용도 | 웹 애플리케이션, API 서버 | 데이터베이스, 메시징 시스템 | . ",
    "url": "/docs/k8s/componentes/deployment.html#deployment-vs-statefulset",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#deployment-vs-statefulset"
  },"153": {
    "doc": "Deployment",
    "title": "주의사항",
    "content": ". | 리소스 제한: 적절한 리소스 요청과 제한을 설정해야 합니다 | 헬스 체크: livenessProbe와 readinessProbe를 설정하여 안정성을 확보해야 합니다 | 업데이트 전략: 애플리케이션 특성에 맞는 업데이트 전략을 선택해야 합니다 | 모니터링: Deployment의 상태와 메트릭을 지속적으로 모니터링해야 합니다 | 백업: 중요한 데이터는 적절한 백업 전략을 수립해야 합니다 | . ",
    "url": "/docs/k8s/componentes/deployment.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/deployment.html#주의사항"
  },"154": {
    "doc": "Deployment",
    "title": "Deployment",
    "content": " ",
    "url": "/docs/k8s/componentes/deployment.html",
    
    "relUrl": "/docs/k8s/componentes/deployment.html"
  },"155": {
    "doc": "How to make diagram in markdown",
    "title": "How to make diagram in markdown",
    "content": " ",
    "url": "/docs/markdown/diagram.html",
    
    "relUrl": "/docs/markdown/diagram.html"
  },"156": {
    "doc": "All-of-docker",
    "title": "What is docker",
    "content": ". | Docker는 애플리케이션을 컨테이너라는 격리된 환경에서 실행할 수 있게 해주는 플랫폼입니다. 컨테이너는 애플리케이션과 그 실행에 필요한 모든 것을 하나로 묶어, 어디서든 일관되게 실행할 수 있도록 합니다. | . ",
    "url": "/docs/all-container/docker.html#what-is-docker",
    
    "relUrl": "/docs/all-container/docker.html#what-is-docker"
  },"157": {
    "doc": "All-of-docker",
    "title": "장점",
    "content": ". | 컨테이너 기반 가상화 기술로, 가볍고 빠른 배포가 가능 | 이미지 기반으로 환경을 표준화하여, 개발-테스트-운영 환경 차이를 최소화 | 격리된 환경에서 여러 애플리케이션을 동시에 실행 가능 | . ",
    "url": "/docs/all-container/docker.html#%EC%9E%A5%EC%A0%90",
    
    "relUrl": "/docs/all-container/docker.html#장점"
  },"158": {
    "doc": "All-of-docker",
    "title": "Docker 구조",
    "content": ". | Docker CLI: 사용자가 명령을 입력하는 도구 (docker 명령어) | Docker Daemon: 컨테이너와 이미지를 관리하는 백그라운드 서비스 | Images: 컨테이너 실행에 필요한 모든 파일과 설정을 포함한 패키지 | Containers: 실제로 실행 중인 애플리케이션 인스턴스 | Volumes: 데이터 영속성을 위한 저장소 | Networks: 컨테이너 간 통신을 위한 가상 네트워크 | . flowchart TD subgraph \"Host OS\" D1[\"Docker Daemon (dockerd)\"] C1[\"Container 1\"] C2[\"Container 2\"] IMG[\"Images\"] VOL[\"Volumes\"] NET[\"Networks\"] end CLI[\"Docker CLI (docker)\"] --&gt; D1 D1 --&gt; IMG D1 --&gt; VOL D1 --&gt; NET D1 --&gt; C1 D1 --&gt; C2 C1 -- \"Uses\" --&gt; IMG C2 -- \"Uses\" --&gt; IMG C1 -- \"Mounts\" --&gt; VOL C2 -- \"Mounts\" --&gt; VOL C1 -- \"Connects\" --&gt; NET C2 -- \"Connects\" --&gt; NET . ",
    "url": "/docs/all-container/docker.html#docker-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/all-container/docker.html#docker-구조"
  },"159": {
    "doc": "All-of-docker",
    "title": "How to use docker",
    "content": ". | Docker 설치 후, 이미지를 받아 컨테이너를 실행 | . | image는 기본적으로 hub.docker.com에서 가져온다. | . | Dockerfile로 이미지를 직접 빌드하여 배포 가능 | 주요 사용 흐름: . | 이미지를 다운로드(pull) | 컨테이너 실행(run) | 상태 확인(ps) . | 컨테이너 접속(exec) | . | 중지/삭제(stop/rm) | . | . 예시: . docker pull nginx # -d option is background # --name option is create container name # -p option is port forwarding {local port}:{container port} # nginx is image docker run -d --name webserver -p 8080:80 nginx docker ps # -it: interactive # bash is command running shell docker exec -it webserver bash docker stop webserver docker rm webserver . ",
    "url": "/docs/all-container/docker.html#how-to-use-docker",
    
    "relUrl": "/docs/all-container/docker.html#how-to-use-docker"
  },"160": {
    "doc": "All-of-docker",
    "title": "Local Volume과 Mount 구조",
    "content": "flowchart LR subgraph Host DIR1[\"/host/data\"] end subgraph Container DIR2[\"/container/data\"] APP[\"App\"] end DIR1 -- \"Volume Mount (-v /host/data:/container/data)\" --&gt; DIR2 APP -- \"Read/Write\" --&gt; DIR2 . 왜 volume mount를 사용하는가? . | 컨테이너는 기본적으로 휘발성(컨테이너 삭제 시 데이터도 삭제) | 호스트와 데이터를 공유하거나, 데이터 영속성을 보장하기 위해 사용 | 개발 환경에서 소스코드 실시간 반영, DB 데이터 보존 등에 활용 | . ",
    "url": "/docs/all-container/docker.html#local-volume%EA%B3%BC-mount-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/all-container/docker.html#local-volume과-mount-구조"
  },"161": {
    "doc": "All-of-docker",
    "title": "Port Forwarding 구조",
    "content": "flowchart LR subgraph Host PORT1[\"Host: 8080\"] end subgraph Container PORT2[\"Container: 80\"] APP[\"Web App\"] end PORT1 -- \"-p 8080:80\" --&gt; PORT2 APP -- \"Listen\" --&gt; PORT2 . 왜 port forwarding을 사용하는가? . | 컨테이너 내부 서비스(예: 80번 포트 웹서버)를 외부(호스트)에서 접근 가능하게 함 | 여러 컨테이너가 각각 다른 포트로 외부에 서비스 제공 가능 | 개발/운영 환경에서 서비스 접근 및 테스트 용이 | . ",
    "url": "/docs/all-container/docker.html#port-forwarding-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/all-container/docker.html#port-forwarding-구조"
  },"162": {
    "doc": "All-of-docker",
    "title": "Docker Network란?",
    "content": "Docker Network는 컨테이너 간 통신, 외부와의 연결을 관리하는 가상 네트워크입니다. | 컨테이너끼리 독립적이면서도 필요에 따라 서로 통신 가능 | 브리지, 호스트, 오버레이 등 다양한 네트워크 드라이버 제공 | 네트워크 격리 및 보안성 강화 | . 왜 docker network를 사용하는가? . | 여러 컨테이너가 하나의 서비스처럼 상호작용(예: 웹+DB) | 네트워크 격리로 보안성 향상 | 복잡한 서비스 아키텍처(마이크로서비스 등) 구현에 필수 | . Docker Network 구조 다이어그램 . flowchart LR NET[\"Docker Network (bridge)\"] C1[\"Container 1 (web)\"] C2[\"Container 2 (db)\"] C1 -- \"172.18.0.2\" --&gt; NET C2 -- \"172.18.0.3\" --&gt; NET NET -- \"가상 네트워크\" --- C1 NET -- \"가상 네트워크\" --- C2 . ",
    "url": "/docs/all-container/docker.html#docker-network%EB%9E%80",
    
    "relUrl": "/docs/all-container/docker.html#docker-network란"
  },"163": {
    "doc": "All-of-docker",
    "title": "Command of docker",
    "content": ". | inspect image . | 이미지 상세 정보 확인 | docker inspect &lt;이미지명&gt; | . | volume mounts . | 호스트와 컨테이너 간 디렉토리/파일 공유 | docker run -v /host/path:/container/path ... | . | network . | 컨테이너 간 통신, 외부와의 연결 설정 | docker network ls, docker network create, docker run --network &lt;네트워크명&gt; | . | How to connect to host ip . | 컨테이너에서 호스트로 접근: Linux는 host.docker.internal 또는 호스트의 실제 IP 사용 | . | How to use exec . | 실행 중인 컨테이너에 명령어 실행/접속 | docker exec -it &lt;컨테이너명&gt; /bin/sh 또는 /bin/bash | . | save . | 이미지를 tar 파일로 저장(백업, 이동, 오프라인 배포 등) | docker save -o &lt;저장할파일명.tar&gt; &lt;이미지명&gt;:&lt;태그&gt; | 예시: docker save -o nginx.tar nginx:latest | . | load . | 저장된 이미지(tar 파일)를 Docker에 불러오기 | docker load -i &lt;이미지파일명.tar&gt; | 예시: docker load -i nginx.tar | . | commit . | 실행 중인 컨테이너의 상태를 새로운 이미지로 저장 | docker commit &lt;컨테이너명 또는 ID&gt; &lt;새이미지명&gt;:&lt;태그&gt; | 예시: docker commit webserver mynginx:custom | . | . ",
    "url": "/docs/all-container/docker.html#command-of-docker",
    
    "relUrl": "/docs/all-container/docker.html#command-of-docker"
  },"164": {
    "doc": "All-of-docker",
    "title": "All-of-docker",
    "content": " ",
    "url": "/docs/all-container/docker.html",
    
    "relUrl": "/docs/all-container/docker.html"
  },"165": {
    "doc": "Flux와 Mono 이해하기",
    "title": "Flux와 Mono 이해하기",
    "content": " ",
    "url": "/docs/spring/flux-mono.html",
    
    "relUrl": "/docs/spring/flux-mono.html"
  },"166": {
    "doc": "Flux와 Mono 이해하기",
    "title": "개요",
    "content": "Flux와 Mono는 Spring WebFlux의 핵심인 Reactor 라이브러리에서 제공하는 리액티브 스트림 타입입니다. 이들은 Reactive Streams 스펙을 구현하며, 비동기 데이터 스트림을 처리하는 데 사용됩니다. ",
    "url": "/docs/spring/flux-mono.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/spring/flux-mono.html#개요"
  },"167": {
    "doc": "Flux와 Mono 이해하기",
    "title": "Reactive Streams 기반",
    "content": "1. Reactive Streams 스펙 . graph LR Publisher[Publisher&lt;br/&gt;데이터 발행자] --&gt; Subscription[Subscription&lt;br/&gt;구독 관계] Subscription --&gt; Subscriber[Subscriber&lt;br/&gt;데이터 구독자] subgraph \"Reactive Streams\" Backpressure[Backpressure&lt;br/&gt;흐름 제어] Error[Error Handling&lt;br/&gt;에러 처리] Complete[Complete&lt;br/&gt;완료 신호] end Publisher --&gt; Backpressure Subscriber --&gt; Error Subscription --&gt; Complete . | Publisher: 데이터를 발행하는 역할 | Subscriber: 데이터를 구독하고 처리하는 역할 | Subscription: Publisher와 Subscriber 간의 구독 관계 | Backpressure: 데이터 흐름 제어 메커니즘 | . 2. Java 9에서의 채택 . // Java 9의 Reactive Streams 인터페이스 import java.util.concurrent.Flow; Flow.Publisher&lt;String&gt; publisher = ...; Flow.Subscriber&lt;String&gt; subscriber = ...; Flow.Subscription subscription = ...; . ",
    "url": "/docs/spring/flux-mono.html#reactive-streams-%EA%B8%B0%EB%B0%98",
    
    "relUrl": "/docs/spring/flux-mono.html#reactive-streams-기반"
  },"168": {
    "doc": "Flux와 Mono 이해하기",
    "title": "Mono - 단일 요소 스트림",
    "content": "1. Mono의 개념 . Mono는 0개 또는 1개의 요소를 발행하는 리액티브 스트림입니다. 주로 단일 결과를 반환하는 작업에 사용됩니다. graph TB subgraph \"Mono&lt;T&gt; - 단일 요소\" MonoEmpty[Mono.empty()&lt;br/&gt;0개 요소 - 완료] MonoJust[Mono.just(item)&lt;br/&gt;1개 요소 - 성공] MonoError[Mono.error()&lt;br/&gt;에러 발생] MonoDefer[Mono.defer()&lt;br/&gt;지연 실행] MonoFromCallable[Mono.fromCallable()&lt;br/&gt;Callable에서 생성] end subgraph \"Mono 생성 패턴\" MonoCreate[Mono.create()&lt;br/&gt;수동 생성] MonoFromSupplier[Mono.fromSupplier()&lt;br/&gt;Supplier에서 생성] MonoFromFuture[Mono.fromFuture()&lt;br/&gt;Future에서 생성] end style MonoJust fill:#e1f5fe style MonoError fill:#ffebee style MonoDefer fill:#f3e5f5 . 2. Mono 생성 방법 . 기본 생성 . // 1. 단일 요소 Mono Mono&lt;String&gt; mono1 = Mono.just(\"Hello World\"); Mono&lt;Integer&gt; mono2 = Mono.just(42); // 2. 빈 Mono Mono&lt;Void&gt; emptyMono = Mono.empty(); // 3. 에러 Mono Mono&lt;String&gt; errorMono = Mono.error(new RuntimeException(\"Error occurred\")); // 4. null 값 Mono Mono&lt;String&gt; nullMono = Mono.justOrEmpty(null); // 빈 Mono 반환 . 지연 실행 Mono . // 1. defer - 구독 시점에 실행 Mono&lt;String&gt; lazyMono = Mono.defer(() -&gt; { System.out.println(\"Executing...\"); return Mono.just(\"Lazy result\"); }); // 2. fromCallable - Callable에서 생성 Mono&lt;String&gt; callableMono = Mono.fromCallable(() -&gt; { // 복잡한 계산이나 I/O 작업 return \"Result from callable\"; }); // 3. fromSupplier - Supplier에서 생성 Mono&lt;String&gt; supplierMono = Mono.fromSupplier(() -&gt; { return \"Result from supplier\"; }); . 수동 생성 . // Mono.create() - 수동으로 Mono 생성 Mono&lt;String&gt; manualMono = Mono.create(sink -&gt; { // 비동기 작업 수행 CompletableFuture.runAsync(() -&gt; { try { Thread.sleep(1000); sink.success(\"Manual result\"); } catch (InterruptedException e) { sink.error(e); } }); }); // 조건부 Mono 생성 Mono&lt;String&gt; conditionalMono = Mono.create(sink -&gt; { if (Math.random() &gt; 0.5) { sink.success(\"Success\"); } else { sink.error(new RuntimeException(\"Random error\")); } }); . 3. Mono 조작 메서드 . 변환 (Transform) . // 1. map - 요소 변환 Mono&lt;String&gt; original = Mono.just(\"Hello\"); Mono&lt;String&gt; transformed = original.map(str -&gt; str + \" World\"); // 결과: \"Hello World\" // 2. flatMap - Mono를 다른 Mono로 변환 Mono&lt;User&gt; userMono = Mono.just(new User(\"john\")); Mono&lt;String&gt; emailMono = userMono.flatMap(user -&gt; Mono.just(user.getEmail())); // 3. switchIfEmpty - 빈 Mono일 때 대체값 Mono&lt;String&gt; fallbackMono = Mono.just(\"Default\"); Mono&lt;String&gt; result = Mono.empty().switchIfEmpty(fallbackMono); . 필터링 (Filter) . // 1. filter - 조건에 맞는 요소만 통과 Mono&lt;Integer&gt; numberMono = Mono.just(10); Mono&lt;Integer&gt; filteredMono = numberMono.filter(n -&gt; n &gt; 5); // 결과: 10 // 2. filterWhen - 비동기 조건으로 필터링 Mono&lt;String&gt; asyncFiltered = Mono.just(\"test\") .filterWhen(str -&gt; Mono.just(str.length() &gt; 3)); . 에러 처리 (Error Handling) . // 1. onErrorReturn - 에러 시 기본값 반환 Mono&lt;String&gt; errorHandledMono = Mono.just(\"test\") .map(str -&gt; { if (str.equals(\"error\")) { throw new RuntimeException(\"Error occurred\"); } return str; }) .onErrorReturn(\"Default value\"); // 2. onErrorResume - 에러 시 다른 Mono로 전환 Mono&lt;String&gt; recoveredMono = Mono.just(\"error\") .map(str -&gt; { if (str.equals(\"error\")) { throw new RuntimeException(\"Error occurred\"); } return str; }) .onErrorResume(throwable -&gt; Mono.just(\"Recovered\")); // 3. onErrorMap - 에러 타입 변환 Mono&lt;String&gt; mappedError = Mono.just(\"test\") .map(str -&gt; { throw new RuntimeException(\"Original error\"); }) .onErrorMap(RuntimeException.class, ex -&gt; new CustomException(\"Mapped error\", ex)); . 타임아웃 처리 . // 1. timeout - 지정 시간 내 완료되지 않으면 에러 Mono&lt;String&gt; timeoutMono = Mono.just(\"Slow operation\") .delayElement(Duration.ofSeconds(5)) .timeout(Duration.ofSeconds(3)) .onErrorReturn(\"Timeout occurred\"); // 2. timeout - 다른 Mono로 fallback Mono&lt;String&gt; timeoutWithFallback = Mono.just(\"Slow operation\") .delayElement(Duration.ofSeconds(5)) .timeout(Duration.ofSeconds(3), Mono.just(\"Fallback\")); . 4. Mono 실제 사용 예제 . 컨트롤러에서의 Mono 사용 . @RestController @RequestMapping(\"/api/users\") public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } // 단일 사용자 조회 @GetMapping(\"/{id}\") public Mono&lt;User&gt; getUserById(@PathVariable String id) { return userService.findById(id) .doOnNext(user -&gt; log.info(\"Found user: {}\", user.getName())) .doOnError(error -&gt; log.error(\"Error finding user: {}\", error.getMessage())) .switchIfEmpty(Mono.error(new UserNotFoundException(id))); } // 사용자 생성 @PostMapping public Mono&lt;User&gt; createUser(@RequestBody User user) { return Mono.just(user) .filter(u -&gt; u.getEmail() != null &amp;&amp; !u.getEmail().isEmpty()) .flatMap(u -&gt; userService.save(u)) .doOnSuccess(savedUser -&gt; log.info(\"User created: {}\", savedUser.getId())) .doOnError(error -&gt; log.error(\"Error creating user: {}\", error.getMessage())); } // 사용자 업데이트 @PutMapping(\"/{id}\") public Mono&lt;User&gt; updateUser(@PathVariable String id, @RequestBody User user) { return userService.findById(id) .flatMap(existingUser -&gt; { user.setId(id); return userService.save(user); }) .switchIfEmpty(Mono.error(new UserNotFoundException(id))); } // 사용자 삭제 @DeleteMapping(\"/{id}\") public Mono&lt;Void&gt; deleteUser(@PathVariable String id) { return userService.findById(id) .flatMap(user -&gt; userService.deleteById(id)) .switchIfEmpty(Mono.error(new UserNotFoundException(id))); } } . ",
    "url": "/docs/spring/flux-mono.html#mono---%EB%8B%A8%EC%9D%BC-%EC%9A%94%EC%86%8C-%EC%8A%A4%ED%8A%B8%EB%A6%BC",
    
    "relUrl": "/docs/spring/flux-mono.html#mono---단일-요소-스트림"
  },"169": {
    "doc": "Flux와 Mono 이해하기",
    "title": "Flux - 다중 요소 스트림",
    "content": "1. Flux의 개념 . Flux는 0개 이상의 요소를 발행하는 리액티브 스트림입니다. 여러 데이터를 순차적으로 처리할 때 사용됩니다. graph TB subgraph \"Flux&lt;T&gt; - 다중 요소\" FluxEmpty[Flux.empty()&lt;br/&gt;0개 요소] FluxJust[Flux.just(items)&lt;br/&gt;여러 요소] FluxRange[Flux.range(1,10)&lt;br/&gt;범위 생성] FluxInterval[Flux.interval()&lt;br/&gt;주기적 생성] FluxGenerate[Flux.generate()&lt;br/&gt;상태 기반 생성] end subgraph \"Flux 생성 패턴\" FluxCreate[Flux.create()&lt;br/&gt;수동 생성] FluxFromIterable[Flux.fromIterable()&lt;br/&gt;Iterable에서 생성] FluxFromStream[Flux.fromStream()&lt;br/&gt;Stream에서 생성] end style FluxJust fill:#e8f5e8 style FluxInterval fill:#fff3e0 style FluxGenerate fill:#fce4ec . 2. Flux 생성 방법 . 기본 생성 . // 1. 여러 요소 Flux Flux&lt;String&gt; flux1 = Flux.just(\"A\", \"B\", \"C\"); Flux&lt;Integer&gt; flux2 = Flux.just(1, 2, 3, 4, 5); // 2. 범위 생성 Flux&lt;Integer&gt; rangeFlux = Flux.range(1, 10); // 1부터 10까지 // 3. 주기적 생성 Flux&lt;Long&gt; intervalFlux = Flux.interval(Duration.ofSeconds(1)); // 4. 빈 Flux Flux&lt;String&gt; emptyFlux = Flux.empty(); . 컬렉션에서 생성 . // 1. List에서 Flux 생성 List&lt;String&gt; list = Arrays.asList(\"Apple\", \"Banana\", \"Cherry\"); Flux&lt;String&gt; fluxFromList = Flux.fromIterable(list); // 2. Stream에서 Flux 생성 Flux&lt;Integer&gt; fluxFromStream = Flux.fromStream( Stream.of(1, 2, 3, 4, 5) ); // 3. Array에서 Flux 생성 String[] array = {\"A\", \"B\", \"C\"}; Flux&lt;String&gt; fluxFromArray = Flux.fromArray(array); // 4. Set에서 Flux 생성 Set&lt;String&gt; set = Set.of(\"X\", \"Y\", \"Z\"); Flux&lt;String&gt; fluxFromSet = Flux.fromIterable(set); . 수동 생성 . // 1. Flux.create() - 수동으로 Flux 생성 Flux&lt;String&gt; manualFlux = Flux.create(sink -&gt; { sink.next(\"First\"); sink.next(\"Second\"); sink.next(\"Third\"); sink.complete(); }); // 2. Flux.generate() - 상태 기반 생성 Flux&lt;Integer&gt; statefulFlux = Flux.generate( () -&gt; 0, // 초기 상태 (state, sink) -&gt; { if (state &lt; 5) { sink.next(state); return state + 1; } else { sink.complete(); return state; } } ); // 3. Flux.push() - 단일 스레드에서 생성 Flux&lt;String&gt; pushFlux = Flux.push(sink -&gt; { sink.next(\"Pushed item\"); sink.complete(); }); . 조건부 생성 . // 1. 조건에 따른 Flux 생성 Flux&lt;String&gt; conditionalFlux = Flux.defer(() -&gt; { if (Math.random() &gt; 0.5) { return Flux.just(\"Success\", \"Items\"); } else { return Flux.empty(); } }); // 2. 에러가 있는 Flux Flux&lt;String&gt; errorFlux = Flux.error(new RuntimeException(\"Flux error\")); . 3. Flux 조작 메서드 . 변환 (Transform) . // 1. map - 각 요소 변환 Flux&lt;String&gt; original = Flux.just(\"a\", \"b\", \"c\"); Flux&lt;String&gt; transformed = original.map(str -&gt; str.toUpperCase()); // 결과: \"A\", \"B\", \"C\" // 2. flatMap - 각 요소를 Flux로 변환 Flux&lt;String&gt; words = Flux.just(\"hello\", \"world\"); Flux&lt;Character&gt; characters = words.flatMap(word -&gt; Flux.fromArray(word.split(\"\")) .map(str -&gt; str.charAt(0))); // 3. concatMap - 순서 보장하며 flatMap Flux&lt;String&gt; ordered = words.concatMap(word -&gt; Flux.fromArray(word.split(\"\")) .map(str -&gt; str.charAt(0)) .map(ch -&gt; String.valueOf(ch))); // 4. switchMap - 새로운 요소가 오면 이전 구독 취소 Flux&lt;String&gt; switched = Flux.just(\"a\", \"b\", \"c\") .switchMap(item -&gt; Flux.interval(Duration.ofMillis(100)) .map(tick -&gt; item + \"-\" + tick)); . 필터링 (Filter) . // 1. filter - 조건에 맞는 요소만 통과 Flux&lt;Integer&gt; numbers = Flux.range(1, 10); Flux&lt;Integer&gt; evenNumbers = numbers.filter(n -&gt; n % 2 == 0); // 결과: 2, 4, 6, 8, 10 // 2. take - 처음 N개 요소만 Flux&lt;Integer&gt; firstFive = numbers.take(5); // 결과: 1, 2, 3, 4, 5 // 3. skip - 처음 N개 요소 건너뛰기 Flux&lt;Integer&gt; skipFirstFive = numbers.skip(5); // 결과: 6, 7, 8, 9, 10 // 4. distinct - 중복 제거 Flux&lt;String&gt; duplicates = Flux.just(\"a\", \"b\", \"a\", \"c\", \"b\"); Flux&lt;String&gt; distinct = duplicates.distinct(); // 결과: \"a\", \"b\", \"c\" . 결합 (Combine) . // 1. merge - 여러 Flux를 하나로 합치기 Flux&lt;String&gt; flux1 = Flux.just(\"A\", \"B\"); Flux&lt;String&gt; flux2 = Flux.just(\"C\", \"D\"); Flux&lt;String&gt; merged = Flux.merge(flux1, flux2); // 결과: \"A\", \"B\", \"C\", \"D\" (순서 보장 안됨) // 2. concat - 순서 보장하며 합치기 Flux&lt;String&gt; concatenated = Flux.concat(flux1, flux2); // 결과: \"A\", \"B\", \"C\", \"D\" (순서 보장) // 3. zip - 여러 Flux를 짝을 맞춰 결합 Flux&lt;String&gt; names = Flux.just(\"John\", \"Jane\"); Flux&lt;Integer&gt; ages = Flux.just(25, 30); Flux&lt;String&gt; zipped = Flux.zip(names, ages) .map(tuple -&gt; tuple.getT1() + \" is \" + tuple.getT2() + \" years old\"); // 결과: \"John is 25 years old\", \"Jane is 30 years old\" . 수집 (Collect) . // 1. collectList - 모든 요소를 List로 수집 Flux&lt;Integer&gt; numbers = Flux.range(1, 5); Mono&lt;List&lt;Integer&gt;&gt; listMono = numbers.collectList(); // 결과: Mono&lt;List&lt;Integer&gt;&gt; with [1, 2, 3, 4, 5] // 2. collectMap - 키-값 쌍으로 수집 Flux&lt;String&gt; items = Flux.just(\"apple\", \"banana\", \"apple\"); Mono&lt;Map&lt;String, Long&gt;&gt; countMap = items .collectMultimap(item -&gt; item, item -&gt; 1L) .map(map -&gt; map.entrySet().stream() .collect(Collectors.toMap( Map.Entry::getKey, entry -&gt; (long) entry.getValue().size() ))); // 3. reduce - 모든 요소를 하나로 축소 Mono&lt;Integer&gt; sum = numbers.reduce(0, Integer::sum); // 결과: Mono&lt;Integer&gt; with 15 . 4. Flux 실제 사용 예제 . 컨트롤러에서의 Flux 사용 . @RestController @RequestMapping(\"/api/users\") public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } // 모든 사용자 조회 @GetMapping public Flux&lt;User&gt; getAllUsers() { return userService.findAll() .filter(User::isActive) .doOnNext(user -&gt; log.debug(\"Processing user: {}\", user.getName())) .doOnComplete(() -&gt; log.info(\"All users processed\")); } // 사용자 검색 @GetMapping(\"/search\") public Flux&lt;User&gt; searchUsers(@RequestParam String query) { return userService.findByEmailContaining(query) .take(10) // 최대 10개만 반환 .doOnNext(user -&gt; log.debug(\"Found matching user: {}\", user.getEmail())); } // 사용자 스트리밍 @GetMapping(value = \"/stream\", produces = MediaType.APPLICATION_NDJSON_VALUE) public Flux&lt;User&gt; streamUsers() { return userService.findAll() .onBackpressureBuffer(100) // 최대 100개 버퍼 .doOnNext(user -&gt; log.debug(\"Streaming user: {}\", user.getName())) .doOnError(error -&gt; log.error(\"Error in stream: {}\", error.getMessage())); } // Server-Sent Events @GetMapping(value = \"/events\", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux&lt;ServerSentEvent&lt;UserEvent&gt;&gt; getUserEvents() { return Flux.interval(Duration.ofSeconds(2)) .flatMap(tick -&gt; userService.findRandomUser()) .map(user -&gt; ServerSentEvent.&lt;UserEvent&gt;builder() .id(String.valueOf(System.currentTimeMillis())) .event(\"user-activity\") .data(new UserEvent(user.getId(), \"User logged in\", Instant.now())) .build()) .take(10); // 10개 이벤트만 전송 } } . ",
    "url": "/docs/spring/flux-mono.html#flux---%EB%8B%A4%EC%A4%91-%EC%9A%94%EC%86%8C-%EC%8A%A4%ED%8A%B8%EB%A6%BC",
    
    "relUrl": "/docs/spring/flux-mono.html#flux---다중-요소-스트림"
  },"170": {
    "doc": "Flux와 Mono 이해하기",
    "title": "Mono와 Flux의 차이점",
    "content": "1. 개념적 차이 . | 특성 | Mono | Flux | . | 요소 개수 | 0개 또는 1개 | 0개 이상 | . | 사용 사례 | 단일 결과 반환 | 다중 데이터 처리 | . | 완료 신호 | 항상 완료 | 완료 또는 무한 | . | 에러 처리 | 단일 에러 | 스트림 중단 | . | 백프레셔 | 단순함 | 복잡함 | . 2. 생명주기 비교 . graph TB subgraph \"Mono 생명주기\" MonoStart[Mono 시작] --&gt; MonoSubscribe[구독] MonoSubscribe --&gt; MonoNext[요소 발행] MonoNext --&gt; MonoComplete[완료] MonoSubscribe --&gt; MonoError[에러] MonoError --&gt; MonoComplete end subgraph \"Flux 생명주기\" FluxStart[Flux 시작] --&gt; FluxSubscribe[구독] FluxSubscribe --&gt; FluxNext[요소 발행] FluxNext --&gt; FluxNext FluxNext --&gt; FluxComplete[완료] FluxSubscribe --&gt; FluxError[에러] FluxError --&gt; FluxComplete end style MonoNext fill:#e1f5fe style FluxNext fill:#e8f5e8 style MonoError fill:#ffebee style FluxError fill:#ffebee . 3. 변환 메서드 . Flux에서 Mono로 변환 . Flux&lt;String&gt; flux = Flux.just(\"A\", \"B\", \"C\"); // 첫 번째 요소만 Mono&lt;String&gt; firstElement = flux.next(); // 모든 요소를 리스트로 Mono&lt;List&lt;String&gt;&gt; allElements = flux.collectList(); // 요소 개수 Mono&lt;Long&gt; count = flux.count(); // 조건에 맞는 첫 번째 요소 Mono&lt;String&gt; firstMatch = flux.filter(s -&gt; s.startsWith(\"A\")).next(); // 모든 요소를 하나로 축소 Mono&lt;String&gt; reduced = flux.reduce(\"\", String::concat); . Mono에서 Flux로 변환 . Mono&lt;String&gt; mono = Mono.just(\"Hello\"); // 단일 요소를 Flux로 Flux&lt;String&gt; fluxFromMono = mono.flux(); // Mono를 Flux로 확장 Mono&lt;List&lt;String&gt;&gt; listMono = Mono.just(Arrays.asList(\"A\", \"B\", \"C\")); Flux&lt;String&gt; expandedFlux = listMono.flatMapMany(Flux::fromIterable); // Mono를 반복하는 Flux Flux&lt;String&gt; repeatedFlux = mono.repeat(3); // 3번 반복 . ",
    "url": "/docs/spring/flux-mono.html#mono%EC%99%80-flux%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90",
    
    "relUrl": "/docs/spring/flux-mono.html#mono와-flux의-차이점"
  },"171": {
    "doc": "Flux와 Mono 이해하기",
    "title": "백프레셔 (Backpressure) 처리",
    "content": "1. 백프레셔 전략 . graph TB FastPublisher[빠른 Publisher] --&gt; SlowSubscriber[느린 Subscriber] subgraph \"Backpressure Strategies\" Buffer[onBackpressureBuffer&lt;br/&gt;버퍼링] Drop[onBackpressureDrop&lt;br/&gt;드롭] Error[onBackpressureError&lt;br/&gt;에러] Latest[onBackpressureLatest&lt;br/&gt;최신만 유지] end FastPublisher --&gt; Buffer FastPublisher --&gt; Drop FastPublisher --&gt; Error FastPublisher --&gt; Latest . 2. 백프레셔 처리 예제 . @Service public class BackpressureService { // 버퍼링 전략 public Flux&lt;String&gt; bufferStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureBuffer(1000) // 최대 1000개 버퍼 .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)); } // 드롭 전략 public Flux&lt;String&gt; dropStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureDrop(item -&gt; log.warn(\"Dropped item: {}\", item)) .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)); } // 에러 전략 public Flux&lt;String&gt; errorStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureError() .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)) .onErrorReturn(\"Error occurred due to backpressure\"); } // 최신만 유지 전략 public Flux&lt;String&gt; latestStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureLatest() .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)); } } . ",
    "url": "/docs/spring/flux-mono.html#%EB%B0%B1%ED%94%84%EB%A0%88%EC%85%94-backpressure-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/spring/flux-mono.html#백프레셔-backpressure-처리"
  },"172": {
    "doc": "Flux와 Mono 이해하기",
    "title": "실제 사용 사례",
    "content": "1. 데이터베이스 조회 . @Service public class ReactiveUserService { private final ReactiveUserRepository userRepository; public ReactiveUserService(ReactiveUserRepository userRepository) { this.userRepository = userRepository; } // 단일 사용자 조회 (Mono) public Mono&lt;User&gt; findById(String id) { return userRepository.findById(id) .doOnNext(user -&gt; log.debug(\"Found user: {}\", user.getEmail())) .doOnError(error -&gt; log.error(\"Error finding user: {}\", error.getMessage())); } // 모든 사용자 조회 (Flux) public Flux&lt;User&gt; findAll() { return userRepository.findAll() .filter(User::isActive) .doOnNext(user -&gt; log.debug(\"Processing user: {}\", user.getName())); } // 사용자 검색 (Flux) public Flux&lt;User&gt; findByEmailContaining(String email) { return userRepository.findByEmailContainingIgnoreCase(email) .take(10) // 최대 10개만 반환 .doOnNext(user -&gt; log.debug(\"Found matching user: {}\", user.getEmail())); } } . 2. 외부 API 호출 . @Service public class ExternalApiService { private final WebClient webClient; public ExternalApiService(WebClient webClient) { this.webClient = webClient; } // 단일 API 호출 (Mono) public Mono&lt;User&gt; getUserFromApi(String id) { return webClient.get() .uri(\"/users/{id}\", id) .retrieve() .bodyToMono(User.class) .timeout(Duration.ofSeconds(5)) .onErrorReturn(new User(id, \"Unknown\")); } // 여러 API 호출 (Flux) public Flux&lt;User&gt; getUsersFromApi(List&lt;String&gt; ids) { return Flux.fromIterable(ids) .flatMap(this::getUserFromApi) .doOnNext(user -&gt; log.debug(\"Retrieved user: {}\", user.getName())); } // 병렬 API 호출 public Flux&lt;User&gt; getUsersParallel(List&lt;String&gt; ids) { return Flux.fromIterable(ids) .flatMap(this::getUserFromApi, 5) // 최대 5개 병렬 처리 .doOnNext(user -&gt; log.debug(\"Retrieved user: {}\", user.getName())); } } . 3. 파일 처리 . @Service public class FileProcessingService { // 파일 읽기 (Flux) public Flux&lt;String&gt; readFileLines(Path filePath) { return Flux.using( () -&gt; Files.lines(filePath), Flux::fromStream, BaseStream::close ).doOnNext(line -&gt; log.debug(\"Processing line: {}\", line)); } // 파일 쓰기 (Mono) public Mono&lt;Void&gt; writeToFile(Flux&lt;String&gt; lines, Path filePath) { return lines .map(line -&gt; line + \"\\n\") .reduce(new StringBuilder(), StringBuilder::append) .flatMap(content -&gt; { try { Files.write(filePath, content.toString().getBytes()); return Mono.empty(); } catch (IOException e) { return Mono.error(e); } }); } } . ",
    "url": "/docs/spring/flux-mono.html#%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/spring/flux-mono.html#실제-사용-사례"
  },"173": {
    "doc": "Flux와 Mono 이해하기",
    "title": "디버깅과 모니터링",
    "content": "1. 로깅 . // Mono 로깅 Mono&lt;String&gt; loggedMono = Mono.just(\"Hello\") .doOnSubscribe(subscription -&gt; log.info(\"Mono subscribed\")) .doOnNext(item -&gt; log.info(\"Mono emitted: {}\", item)) .doOnSuccess(result -&gt; log.info(\"Mono completed successfully\")) .doOnError(error -&gt; log.error(\"Mono failed: {}\", error.getMessage())) .doFinally(signalType -&gt; log.info(\"Mono finally: {}\", signalType)); // Flux 로깅 Flux&lt;String&gt; loggedFlux = Flux.just(\"A\", \"B\", \"C\") .doOnSubscribe(subscription -&gt; log.info(\"Flux subscribed\")) .doOnNext(item -&gt; log.info(\"Flux emitted: {}\", item)) .doOnComplete(() -&gt; log.info(\"Flux completed\")) .doOnError(error -&gt; log.error(\"Flux failed: {}\", error.getMessage())) .doFinally(signalType -&gt; log.info(\"Flux finally: {}\", signalType)); . 2. 메트릭 수집 . @Component public class ReactiveMetrics { private final MeterRegistry meterRegistry; public ReactiveMetrics(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } // Mono 메트릭 public &lt;T&gt; Mono&lt;T&gt; withMetrics(Mono&lt;T&gt; mono, String name) { Timer.Sample sample = Timer.start(meterRegistry); return mono .doOnSuccess(result -&gt; { sample.stop(Timer.builder(\"mono.duration\") .tag(\"name\", name) .tag(\"status\", \"success\") .register(meterRegistry)); }) .doOnError(error -&gt; { sample.stop(Timer.builder(\"mono.duration\") .tag(\"name\", name) .tag(\"status\", \"error\") .register(meterRegistry)); }); } // Flux 메트릭 public &lt;T&gt; Flux&lt;T&gt; withMetrics(Flux&lt;T&gt; flux, String name) { Timer.Sample sample = Timer.start(meterRegistry); AtomicLong count = new AtomicLong(); return flux .doOnNext(item -&gt; count.incrementAndGet()) .doOnComplete(() -&gt; { sample.stop(Timer.builder(\"flux.duration\") .tag(\"name\", name) .tag(\"status\", \"success\") .register(meterRegistry)); meterRegistry.counter(\"flux.items\", \"name\", name) .increment(count.get()); }) .doOnError(error -&gt; { sample.stop(Timer.builder(\"flux.duration\") .tag(\"name\", name) .tag(\"status\", \"error\") .register(meterRegistry)); }); } } . ",
    "url": "/docs/spring/flux-mono.html#%EB%94%94%EB%B2%84%EA%B9%85%EA%B3%BC-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81",
    
    "relUrl": "/docs/spring/flux-mono.html#디버깅과-모니터링"
  },"174": {
    "doc": "Flux와 Mono 이해하기",
    "title": "결론",
    "content": "Mono와 Flux는 Spring WebFlux의 핵심 구성 요소로, 비동기 데이터 스트림을 효율적으로 처리할 수 있게 해줍니다. 주요 포인트: . | Mono: 0개 또는 1개의 요소를 처리하는 단일 결과 스트림 | Flux: 0개 이상의 요소를 처리하는 다중 데이터 스트림 | 백프레셔: 빠른 생산자와 느린 소비자 간의 흐름 제어 | 에러 처리: 다양한 에러 처리 전략 제공 | 변환과 조합: 풍부한 연산자를 통한 데이터 처리 | 모니터링: 로깅과 메트릭을 통한 관찰성 | . 학습 로드맵: . | 기초: Mono와 Flux의 기본 생성과 구독 | 중급: 변환, 필터링, 결합 연산자 활용 | 고급: 백프레셔 처리, 에러 처리, 성능 최적화 | 실전: 실제 프로젝트에서의 활용과 모니터링 | . Mono와 Flux를 마스터하면 Spring WebFlux의 강력한 비동기 프로그래밍 능력을 활용할 수 있으며, 고성능 웹 애플리케이션을 구축할 수 있습니다. ",
    "url": "/docs/spring/flux-mono.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/spring/flux-mono.html#결론"
  },"175": {
    "doc": "Git 개념",
    "title": "Git",
    "content": "개인과 팀의 가장 큰 차이점 . | 내가 알고 있는 내용(코드, 커밋)이 전부가 아니다. | 모든 내용은 위의 가정 하에 시작됩니다. | . 개인 프로젝트에서의 Git . | 모든 Commit 이 무슨 내용인지 알 수 있음. | Conflict 해결에 --force 와 reset --hard 이라는 치트키를 사용할 수 있음. | push / pull 에 큰 신경 쓰지 않았음. | . 팀 프로젝트에서의 Git . | 모든 Commit 이 무슨 내용인지 절대로 알 수 없음. | 따라서 Conflict 가 발생하는 경우, 관련된 모든 개발자가 확인이 필요함. | . ",
    "url": "/docs/git/git-concepts.html#git",
    
    "relUrl": "/docs/git/git-concepts.html#git"
  },"176": {
    "doc": "Git 개념",
    "title": "Git area",
    "content": ". reset . | 코드가 날아감 | 옵션 . | soft: index 보존(add한 상태, staged 상태), 워킹 디렉터리의 파일 보존. 즉 모두 보존. | mixed: index 취소(add하기 전 상태, unstaged 상태), 워킹 디렉터리의 파일 보존 (기본 옵션) | hard: index 취소(add하기 전 상태, unstaged 상태), 워킹 디렉터리의 파일 삭제. 즉 모두 취소. | . | . git reset --hard HEAD # (해당 커밋으로 돌리겠다. 모든 코드 + 커밋을) git reset --soft HEAD # (해당 커밋으로만 돌린다.) . Revert . | reset 없이 코드를 되돌릴 수 있는 명령어 | 그에 반해 revert는 앞서 말한 것 처럼 특정 사건을 골라서 없던일로 만듭니다. 또한 앞서 말한 것처럼 과거 특정 사건을 없에주지만 revert를 했다는 이력이 남게 됩니다. | . git revert &lt;commit id&gt; . ",
    "url": "/docs/git/git-concepts.html#git-area",
    
    "relUrl": "/docs/git/git-concepts.html#git-area"
  },"177": {
    "doc": "Git 개념",
    "title": "Git checkout",
    "content": ". ",
    "url": "/docs/git/git-concepts.html#git-checkout",
    
    "relUrl": "/docs/git/git-concepts.html#git-checkout"
  },"178": {
    "doc": "Git 개념",
    "title": "How to clear working directory",
    "content": "git checkout -- . # Clear changes (exclude untracted files) git clean -df # remove untracted files . ",
    "url": "/docs/git/git-concepts.html#how-to-clear-working-directory",
    
    "relUrl": "/docs/git/git-concepts.html#how-to-clear-working-directory"
  },"179": {
    "doc": "Git 개념",
    "title": "Commit type",
    "content": ". | feat: 새로운 기능 추가 | fix: 버그 수정 | docs: 문서 수정 | style: 코드 포멧팅, 세미콜론 누락, 코드 변경이 없는 경우 | refactor: 코드 리펙토링 | test: 테스트코드, 리펙토링 테스트 코드 추가 | chore: 빌드 업무 수정, 패키지 매니저 수정, .ignore 수정 등 | . ",
    "url": "/docs/git/git-concepts.html#commit-type",
    
    "relUrl": "/docs/git/git-concepts.html#commit-type"
  },"180": {
    "doc": "Git 개념",
    "title": "upstream",
    "content": ". | local branch 와 remote branch 를 연결 | . ",
    "url": "/docs/git/git-concepts.html#upstream",
    
    "relUrl": "/docs/git/git-concepts.html#upstream"
  },"181": {
    "doc": "Git 개념",
    "title": "origin",
    "content": "git push -u origin main //git repository에 main으로 푸쉬 --set-upstream //관계 설정 . ",
    "url": "/docs/git/git-concepts.html#origin",
    
    "relUrl": "/docs/git/git-concepts.html#origin"
  },"182": {
    "doc": "Git 개념",
    "title": "Git 개념",
    "content": " ",
    "url": "/docs/git/git-concepts.html",
    
    "relUrl": "/docs/git/git-concepts.html"
  },"183": {
    "doc": "git-filter-repo",
    "title": "git-filter-repo",
    "content": ". | git-filter-repo is a tool that helps tou organize your Git repository or change history | . ",
    "url": "/docs/git/git-filter-repo.html",
    
    "relUrl": "/docs/git/git-filter-repo.html"
  },"184": {
    "doc": "git-filter-repo",
    "title": "How to install in Mac",
    "content": "brew install git-filter-repo . ",
    "url": "/docs/git/git-filter-repo.html#how-to-install-in-mac",
    
    "relUrl": "/docs/git/git-filter-repo.html#how-to-install-in-mac"
  },"185": {
    "doc": "git-filter-repo",
    "title": "How to use git-filter-repo",
    "content": "git filter-repo --subdirectory-filter path/to/keep # When you want to organize your history by leaving only a specific directory . ",
    "url": "/docs/git/git-filter-repo.html#how-to-use-git-filter-repo",
    
    "relUrl": "/docs/git/git-filter-repo.html#how-to-use-git-filter-repo"
  },"186": {
    "doc": "How-to-write-helm-chart",
    "title": "Chart grammer",
    "content": "apiVersion: The chart API version (required) name: The name of the chart (required) version: A SemVer 2 version (required) # 1.2.3-alpha.1+ef365 description: A single-sentence description of this project (optional) dependencies: # A list of the chart requirements (optional) - name: The name of the chart (nginx) version: The version of the chart (\"1.2.3\") repository: (optional) The repository URL (\"https://example.com/charts\") or alias (\"@repo-name\") condition: (optional) A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled ) tags: # (optional) - Tags can be used to group charts for enabling/disabling together import-values: # (optional) - ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items. alias: (optional) Alias to be used for the chart. Useful when you have to add the same chart multiple times appVersion: The version of the app that this contains (optional). Needn't be SemVer. Quotes recommended. # \"8.2.1\" . ",
    "url": "/docs/helm/grammer.html#chart-grammer",
    
    "relUrl": "/docs/helm/grammer.html#chart-grammer"
  },"187": {
    "doc": "How-to-write-helm-chart",
    "title": "SemVersion",
    "content": " ",
    "url": "/docs/helm/grammer.html#semversion",
    
    "relUrl": "/docs/helm/grammer.html#semversion"
  },"188": {
    "doc": "How-to-write-helm-chart",
    "title": "version",
    "content": ". | major version.minor version.patches . | major . | 호환되지 않는 API 변경 | . | minor . | 하위 호환되는 기능 추가 | . | patch . | 하위 호환되는 기능 추가 | . | . | . ",
    "url": "/docs/helm/grammer.html#version",
    
    "relUrl": "/docs/helm/grammer.html#version"
  },"189": {
    "doc": "How-to-write-helm-chart",
    "title": "alpha",
    "content": ". | 하이픈(-) 사용 . | - 뒤에 오는 값은 정식 릴리즈 전의 버전을 나타낸다. | 정식 버전보다 낮은 버전 | 예시 . | 1.2.3-alpha | 1.2.3-beta.1 | 1.2.3-rc.2 | . | . | 플러스(+) 사용: 빌드 메타데이터 . | 빌드 메타데이터(Build Metadata) | 플러스 뒤에 오는 값은 빌드 정보를 나타냅니다. | 빌드 메타데이터는 버전 우선순위에 영향을 주지 않습니다 (동일 버전으로 간주). | 예시 . | 1.2.3+001 | 1.2.3-alpha+exp.sha.5114f85 | . | . | . ",
    "url": "/docs/helm/grammer.html#alpha",
    
    "relUrl": "/docs/helm/grammer.html#alpha"
  },"190": {
    "doc": "How-to-write-helm-chart",
    "title": "How-to-write-helm-chart",
    "content": " ",
    "url": "/docs/helm/grammer.html",
    
    "relUrl": "/docs/helm/grammer.html"
  },"191": {
    "doc": "How-to-write-helm-chart",
    "title": "Chart grammer",
    "content": "apiVersion: The chart API version (required) name: The name of the chart (required) version: A SemVer 2 version (required) # 1.2.3-alpha.1+ef365 description: A single-sentence description of this project (optional) dependencies: # A list of the chart requirements (optional) - name: The name of the chart (nginx) version: The version of the chart (\"1.2.3\") repository: (optional) The repository URL (\"https://example.com/charts\") or alias (\"@repo-name\") condition: (optional) A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled ) tags: # (optional) - Tags can be used to group charts for enabling/disabling together import-values: # (optional) - ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items. alias: (optional) Alias to be used for the chart. Useful when you have to add the same chart multiple times appVersion: The version of the app that this contains (optional). Needn't be SemVer. Quotes recommended. # \"8.2.1\" . ",
    "url": "/docs/k8s/grammer.html#chart-grammer",
    
    "relUrl": "/docs/k8s/grammer.html#chart-grammer"
  },"192": {
    "doc": "How-to-write-helm-chart",
    "title": "Helm Chart 구조 다이어그램",
    "content": "graph TB subgraph \"Helm Chart\" ChartYaml[Chart.yaml] ValuesYaml[values.yaml] Templates[Templates/] Charts[Charts/] README[README.md] Helpers[helpers.tpl] end subgraph \"Templates Directory\" Deployment[deployment.yaml] Service[service.yaml] ConfigMap[configmap.yaml] Secret[secret.yaml] Ingress[ingress.yaml] Notes[NOTES.txt] end subgraph \"Dependencies\" SubChart1[Sub Chart 1] SubChart2[Sub Chart 2] SubChart3[Sub Chart 3] end ChartYaml --&gt; ValuesYaml ChartYaml --&gt; Templates ChartYaml --&gt; Charts Templates --&gt; Deployment Templates --&gt; Service Templates --&gt; ConfigMap Templates --&gt; Secret Templates --&gt; Ingress Templates --&gt; Notes Charts --&gt; SubChart1 Charts --&gt; SubChart2 Charts --&gt; SubChart3 . ",
    "url": "/docs/k8s/grammer.html#helm-chart-%EA%B5%AC%EC%A1%B0-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/k8s/grammer.html#helm-chart-구조-다이어그램"
  },"193": {
    "doc": "How-to-write-helm-chart",
    "title": "SemVersion",
    "content": " ",
    "url": "/docs/k8s/grammer.html#semversion",
    
    "relUrl": "/docs/k8s/grammer.html#semversion"
  },"194": {
    "doc": "How-to-write-helm-chart",
    "title": "version",
    "content": ". | major version.minor version.patches . | major . | 호환되지 않는 API 변경 | . | minor . | 하위 호환되는 기능 추가 | . | patch . | 하위 호환되는 기능 추가 | . | . | . ",
    "url": "/docs/k8s/grammer.html#version",
    
    "relUrl": "/docs/k8s/grammer.html#version"
  },"195": {
    "doc": "How-to-write-helm-chart",
    "title": "alpha",
    "content": ". | 하이픈(-) 사용 . | - 뒤에 오는 값은 정식 릴리즈 전의 버전을 나타낸다. | 정식 버전보다 낮은 버전 | 예시 . | 1.2.3-alpha | 1.2.3-beta.1 | 1.2.3-rc.2 | . | . | 플러스(+) 사용: 빌드 메타데이터 . | 빌드 메타데이터(Build Metadata) | 플러스 뒤에 오는 값은 빌드 정보를 나타냅니다. | 빌드 메타데이터는 버전 우선순위에 영향을 주지 않습니다 (동일 버전으로 간주). | 예시 . | 1.2.3+001 | 1.2.3-alpha+exp.sha.5114f85 | . | . | . ",
    "url": "/docs/k8s/grammer.html#alpha",
    
    "relUrl": "/docs/k8s/grammer.html#alpha"
  },"196": {
    "doc": "How-to-write-helm-chart",
    "title": "Semantic Versioning 다이어그램",
    "content": "graph LR subgraph \"Version Format\" Major[Major Version] Minor[Minor Version] Patch[Patch Version] PreRelease[Pre-release] Build[Build Metadata] end Major --&gt; Minor Minor --&gt; Patch Patch --&gt; PreRelease PreRelease --&gt; Build subgraph \"Examples\" Ex1[\"1.2.3\"] Ex2[\"1.2.3-alpha\"] Ex3[\"1.2.3-beta.1\"] Ex4[\"1.2.3-rc.2\"] Ex5[\"1.2.3+001\"] Ex6[\"1.2.3-alpha+exp.sha.5114f85\"] end . ",
    "url": "/docs/k8s/grammer.html#semantic-versioning-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/k8s/grammer.html#semantic-versioning-다이어그램"
  },"197": {
    "doc": "How-to-write-helm-chart",
    "title": "버전 우선순위 다이어그램",
    "content": "graph TD A[1.0.0] --&gt; B[1.0.1] B --&gt; C[1.1.0] C --&gt; D[1.1.1] D --&gt; E[1.2.0] E --&gt; F[2.0.0] G[1.0.0-alpha] --&gt; H[1.0.0-beta] H --&gt; I[1.0.0-rc.1] I --&gt; J[1.0.0-rc.2] J --&gt; A K[1.0.0+001] --&gt; L[1.0.0+002] L --&gt; A style A fill:#e1f5fe style F fill:#ffebee style G fill:#fff3e0 style J fill:#fff3e0 . ",
    "url": "/docs/k8s/grammer.html#%EB%B2%84%EC%A0%84-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8",
    
    "relUrl": "/docs/k8s/grammer.html#버전-우선순위-다이어그램"
  },"198": {
    "doc": "How-to-write-helm-chart",
    "title": "Helm Chart 생명주기",
    "content": "stateDiagram-v2 [*] --&gt; Development Development --&gt; Testing Testing --&gt; Alpha Alpha --&gt; Beta Beta --&gt; ReleaseCandidate ReleaseCandidate --&gt; Production Production --&gt; [*] Testing --&gt; Development : 버그 발견 Alpha --&gt; Development : 개선 필요 Beta --&gt; Development : 수정 필요 ReleaseCandidate --&gt; Development : 최종 수정 Production --&gt; Development : 새로운 기능 . ",
    "url": "/docs/k8s/grammer.html#helm-chart-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0",
    
    "relUrl": "/docs/k8s/grammer.html#helm-chart-생명주기"
  },"199": {
    "doc": "How-to-write-helm-chart",
    "title": "Chart.yaml 예시",
    "content": "graph TD A[Chart.yaml] --&gt; B[apiVersion: v2] A --&gt; C[name: my-app] A --&gt; D[version: 1.2.3] A --&gt; E[description: My application] A --&gt; F[appVersion: \"1.0.0\"] A --&gt; G[dependencies] G --&gt; H[name: nginx] G --&gt; I[version: \"1.2.3\"] G --&gt; J[repository: https://charts.bitnami.com/bitnami] style A fill:#e8f5e8 style B fill:#f0f8ff style C fill:#f0f8ff style D fill:#f0f8ff style E fill:#f0f8ff style F fill:#f0f8ff style G fill:#fff8dc . ",
    "url": "/docs/k8s/grammer.html#chartyaml-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/grammer.html#chartyaml-예시"
  },"200": {
    "doc": "How-to-write-helm-chart",
    "title": "How-to-write-helm-chart",
    "content": " ",
    "url": "/docs/k8s/grammer.html",
    
    "relUrl": "/docs/k8s/grammer.html"
  },"201": {
    "doc": "Deploy",
    "title": "배포 전략",
    "content": "배포 전략에 대한 설명이다. Rolling Update . 점진적으로 애플리케이션을 업데이트하는 배포 전략 . Read more → Blue/Green Deployment . 완전한 버전 전환을 통한 무중단 배포 전략 . Read more → Canary Deployment . 소규모 사용자 그룹을 대상으로 한 점진적 배포 전략 . Read more → ",
    "url": "/deploy/#%EB%B0%B0%ED%8F%AC-%EC%A0%84%EB%9E%B5",
    
    "relUrl": "/deploy/#배포-전략"
  },"202": {
    "doc": "Deploy",
    "title": "Deploy",
    "content": " ",
    "url": "/deploy/",
    
    "relUrl": "/deploy/"
  },"203": {
    "doc": "Helm",
    "title": "Helm",
    "content": "Helm에 대한 설명입니다. How-to-use-Helm . Command of helm . Read more → What-is-Helm . Description of helm . Read more → How-to-write-helm-chart . Grammer of helm . Read more → ",
    "url": "/helm/",
    
    "relUrl": "/helm/"
  },"204": {
    "doc": "Jekyll",
    "title": "Jekyll",
    "content": "Jekyll에 대한 소개 페이지입니다. git-command . git 개념 및 command에 대한 설명이다. Read more → Git 개념 . Git이란 무엇이고 어떻게 사용하는가에 대한 설명입니다. Read more → git-filter-repo . git-filter-repo에 대한 설명 . Read more → ",
    "url": "/jekyll/",
    
    "relUrl": "/jekyll/"
  },"205": {
    "doc": "Kubernetes Components",
    "title": "Kubernetes Components",
    "content": "Kubernetes의 주요 컴포넌트들에 대한 상세한 설명입니다. ClusterRole . ClusterRole component in Kubernetes . Read more → Pod . Pod component in Kubernetes . Read more → Deployment . Deployment component in Kubernetes . Read more → Service . Service component in Kubernetes . Read more → Ingress . Ingress component in Kubernetes . Read more → ConfigMap . ConfigMap component in Kubernetes . Read more → Role . Role component in Kubernetes . Read more → RoleBinding . RoleBinding component in Kubernetes . Read more → ClusterRoleBinding . ClusterRoleBinding component in Kubernetes . Read more → ServiceAccount . ServiceAccount component in Kubernetes . Read more → StatefulSet . StatefulSet component in Kubernetes . Read more → kube-system . kube-system namespace in Kubernetes . Read more → ",
    "url": "/k8s/componentes/",
    
    "relUrl": "/k8s/componentes/"
  },"206": {
    "doc": "Kubernetes",
    "title": "Kubernetes",
    "content": "K8s에 대한 설명입니다. How to use kubectl . Read more → What-is-Kubernetes . Description of Kubernetes . Read more → How-to-write-helm-chart . Grammer of helm . Read more → Kubernetes Components . Read more → ",
    "url": "/k8s/",
    
    "relUrl": "/k8s/"
  },"207": {
    "doc": "Spring",
    "title": "Spring",
    "content": "Spring 에 대한 소개 페이지입니다. Spring boot gateway . Read more → Spring WebFlux Overview . Read more → Spring WebFlux . Read more → Flux와 Mono 이해하기 . Read more → ",
    "url": "/spring/",
    
    "relUrl": "/spring/"
  },"208": {
    "doc": "Markdown",
    "title": "Markdown 에서 diagram 만드는 방법에 대한 페이지",
    "content": "Kubernetes 에 대한 소개 페이지입니다. How to make diagram in markdown . Read more → ",
    "url": "/diagram/#markdown-%EC%97%90%EC%84%9C-diagram-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%9C-%ED%8E%98%EC%9D%B4%EC%A7%80",
    
    "relUrl": "/diagram/#markdown-에서-diagram-만드는-방법에-대한-페이지"
  },"209": {
    "doc": "Markdown",
    "title": "Markdown",
    "content": " ",
    "url": "/diagram/",
    
    "relUrl": "/diagram/"
  },"210": {
    "doc": "Container",
    "title": "Container",
    "content": "Container 와 관련된 개념입니다. What-is-Container-Runtime . Description of container runtime . Read more → What-is-Container . Description of container . Read more → All-of-docker . Description of docker . Read more → Docker Registry . Description of docker registry . Read more → ",
    "url": "/all-container/",
    
    "relUrl": "/all-container/"
  },"211": {
    "doc": "Git",
    "title": "Git",
    "content": "Git에 대한 소개 페이지입니다. git-command . git 개념 및 command에 대한 설명이다. Read more → Git 개념 . Git이란 무엇이고 어떻게 사용하는가에 대한 설명입니다. Read more → git-filter-repo . git-filter-repo에 대한 설명 . Read more → ",
    "url": "/git/",
    
    "relUrl": "/git/"
  },"212": {
    "doc": "Network",
    "title": "Network",
    "content": "네트워크 프로토콜과 통신 방식에 대한 문서들입니다. 3-Way Handshake . TCP 연결을 위한 3-way handshake 과정에 대한 설명 . Read more → TCP vs UDP . TCP와 UDP 프로토콜의 작동 방식과 차이점에 대한 설명 . Read more → ",
    "url": "/network/",
    
    "relUrl": "/network/"
  },"213": {
    "doc": "문서 목록",
    "title": "👋 Seungeon의 개발 블로그",
    "content": "안녕하세요! 백엔드 개발자 Seungeon입니다. 아래는 제가 진행한 주요 프로젝트 목록입니다. My Awesome API . 사용자 인증, 게시글 CRUD, JWT 기반 로그인 기능이 포함된 API 서버입니다. | 기술 스택: Spring Boot, JPA, PostgreSQL | 사용 언어: Java | 주요 기능: 로그인, 회원가입, 게시글 | . Blog Front . Jekyll 기반 정적 블로그, GitHub Actions로 자동 배포 구성 . | 기술 스택: Jekyll, GitHub Pages | 사용 언어: Markdown, HTML, Liquid | 주요 기능: 사이드바, 검색, 문서 분류 | . ",
    "url": "/#-seungeon%EC%9D%98-%EA%B0%9C%EB%B0%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8",
    
    "relUrl": "/#-seungeon의-개발-블로그"
  },"214": {
    "doc": "문서 목록",
    "title": "문서 목록",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"215": {
    "doc": "Ingress",
    "title": "Ingress 개요",
    "content": "Ingress는 Kubernetes에서 HTTP/HTTPS 트래픽을 클러스터 내부 서비스로 라우팅하는 API 객체입니다. 외부에서 클러스터로 들어오는 트래픽을 관리하고, SSL/TLS 종료, 가상 호스팅, 로드 밸런싱을 제공합니다. Ingress의 특징 . | L7 로드 밸런싱: 애플리케이션 레이어에서 트래픽 분산 | SSL/TLS 종료: HTTPS 인증서 관리 | 가상 호스팅: 도메인 기반 라우팅 | Path 기반 라우팅: URL 경로에 따른 서비스 분기 | 인증서 관리: 자동 SSL 인증서 발급 및 갱신 | . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-개요"
  },"216": {
    "doc": "Ingress",
    "title": "Ingress 구조",
    "content": "graph TD A[Internet] --&gt; B[Load Balancer] B --&gt; C[Ingress Controller] C --&gt; D[Ingress Rules] D --&gt; E[Service 1] D --&gt; F[Service 2] D --&gt; G[Service 3] E --&gt; H[Pod 1] E --&gt; I[Pod 2] F --&gt; J[Pod 3] F --&gt; K[Pod 4] G --&gt; L[Pod 5] G --&gt; M[Pod 6] style A fill:#e3f2fd style B fill:#fff3e0 style C fill:#e1f5fe style D fill:#f3e5f5 style E fill:#e8f5e8 style F fill:#e8f5e8 style G fill:#e8f5e8 style H fill:#fff3e0 style I fill:#fff3e0 style J fill:#fff3e0 style K fill:#fff3e0 style L fill:#fff3e0 style M fill:#fff3e0 . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-구조"
  },"217": {
    "doc": "Ingress",
    "title": "Ingress Controller",
    "content": "Nginx Ingress Controller 설치 . # Helm을 사용한 설치 helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx helm repo update helm install ingress-nginx ingress-nginx/ingress-nginx # 또는 kubectl을 사용한 설치 kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml . AWS ALB Ingress Controller . apiVersion: apps/v1 kind: Deployment metadata: name: alb-ingress-controller namespace: kube-system spec: replicas: 1 selector: matchLabels: app: alb-ingress-controller template: metadata: labels: app: alb-ingress-controller spec: serviceAccountName: alb-ingress-controller containers: - name: alb-ingress-controller image: amazon/aws-alb-ingress-controller:v2.4.2 args: - --ingress-class=alb - --cluster-name=my-cluster . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-controller",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-controller"
  },"218": {
    "doc": "Ingress",
    "title": "Ingress 예시",
    "content": "기본 Ingress . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: basic-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: / spec: ingressClassName: nginx rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: web-service port: number: 80 . 다중 서비스 Ingress . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: multi-service-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: /$2 spec: ingressClassName: nginx rules: - host: example.com http: paths: - path: /api(/|$)(.*) pathType: Prefix backend: service: name: api-service port: number: 8080 - path: /web(/|$)(.*) pathType: Prefix backend: service: name: web-service port: number: 80 - path: /admin(/|$)(.*) pathType: Prefix backend: service: name: admin-service port: number: 8080 . SSL/TLS Ingress . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: tls-ingress annotations: cert-manager.io/cluster-issuer: \"letsencrypt-prod\" spec: ingressClassName: nginx tls: - hosts: - example.com - www.example.com secretName: example-tls rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: web-service port: number: 80 - host: www.example.com http: paths: - path: / pathType: Prefix backend: service: name: web-service port: number: 80 . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-예시"
  },"219": {
    "doc": "Ingress",
    "title": "Ingress 타입",
    "content": "1. 단일 서비스 Ingress . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: single-service-ingress spec: ingressClassName: nginx defaultBackend: service: name: default-service port: number: 80 . 2. 가상 호스팅 Ingress . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: virtual-hosting-ingress spec: ingressClassName: nginx rules: - host: foo.example.com http: paths: - path: / pathType: Prefix backend: service: name: foo-service port: number: 80 - host: bar.example.com http: paths: - path: / pathType: Prefix backend: service: name: bar-service port: number: 80 . 3. Path 기반 Ingress . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: path-based-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: /$2 spec: ingressClassName: nginx rules: - host: example.com http: paths: - path: /api(/|$)(.*) pathType: Prefix backend: service: name: api-service port: number: 8080 - path: /web(/|$)(.*) pathType: Prefix backend: service: name: web-service port: number: 80 - path: /admin(/|$)(.*) pathType: Prefix backend: service: name: admin-service port: number: 8080 . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%ED%83%80%EC%9E%85",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-타입"
  },"220": {
    "doc": "Ingress",
    "title": "Ingress Annotations",
    "content": "Nginx Ingress Annotations . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: annotated-ingress annotations: # 기본 설정 nginx.ingress.kubernetes.io/rewrite-target: / nginx.ingress.kubernetes.io/ssl-redirect: \"true\" # 로드 밸런싱 nginx.ingress.kubernetes.io/load-balance: \"round_robin\" nginx.ingress.kubernetes.io/upstream-hash-by: \"$remote_addr\" # 세션 어피니티 nginx.ingress.kubernetes.io/affinity: \"cookie\" nginx.ingress.kubernetes.io/session-cookie-name: \"route\" nginx.ingress.kubernetes.io/session-cookie-max-age: \"172800\" # 속도 제한 nginx.ingress.kubernetes.io/rate-limit: \"100\" nginx.ingress.kubernetes.io/rate-limit-window: \"1m\" # CORS nginx.ingress.kubernetes.io/cors-allow-origin: \"*\" nginx.ingress.kubernetes.io/cors-allow-methods: \"GET, POST, OPTIONS\" nginx.ingress.kubernetes.io/cors-allow-headers: \"DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization\" # 인증 nginx.ingress.kubernetes.io/auth-type: basic nginx.ingress.kubernetes.io/auth-secret: basic-auth nginx.ingress.kubernetes.io/auth-realm: \"Authentication Required\" spec: ingressClassName: nginx rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: web-service port: number: 80 . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-annotations",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-annotations"
  },"221": {
    "doc": "Ingress",
    "title": "SSL/TLS 설정",
    "content": "자동 SSL 인증서 (cert-manager) . apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: letsencrypt-prod spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: admin@example.com privateKeySecretRef: name: letsencrypt-prod solvers: - http01: ingress: class: nginx --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ssl-ingress annotations: cert-manager.io/cluster-issuer: \"letsencrypt-prod\" spec: ingressClassName: nginx tls: - hosts: - example.com secretName: example-tls rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: web-service port: number: 80 . 수동 SSL 인증서 . apiVersion: v1 kind: Secret metadata: name: tls-secret type: kubernetes.io/tls data: tls.crt: &lt;base64-encoded-certificate&gt; tls.key: &lt;base64-encoded-private-key&gt; --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: manual-ssl-ingress spec: ingressClassName: nginx tls: - hosts: - example.com secretName: tls-secret rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: web-service port: number: 80 . ",
    "url": "/docs/k8s/componentes/ingress.html#ssltls-%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ssltls-설정"
  },"222": {
    "doc": "Ingress",
    "title": "Ingress 관리 명령어",
    "content": "기본 명령어 . # Ingress 생성 kubectl apply -f ingress.yaml # Ingress 목록 확인 kubectl get ingress kubectl get ing # Ingress 상세 정보 확인 kubectl describe ingress &lt;ingress-name&gt; # Ingress 삭제 kubectl delete ingress &lt;ingress-name&gt; # Ingress 상태 확인 kubectl get ingress &lt;ingress-name&gt; -o yaml . 디버깅 명령어 . # Ingress Controller 로그 확인 kubectl logs -n ingress-nginx -l app.kubernetes.io/name=ingress-nginx # Ingress Controller 상태 확인 kubectl get pods -n ingress-nginx # SSL 인증서 확인 kubectl get secrets # DNS 확인 kubectl run test-dns --image=busybox --rm -it --restart=Never -- nslookup &lt;hostname&gt; . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-관리-명령어"
  },"223": {
    "doc": "Ingress",
    "title": "Ingress 사용 사례",
    "content": "1. 마이크로서비스 아키텍처 . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: microservices-ingress annotations: nginx.ingress.kubernetes.io/rewrite-target: /$2 spec: ingressClassName: nginx rules: - host: api.example.com http: paths: - path: /users(/|$)(.*) pathType: Prefix backend: service: name: user-service port: number: 8080 - path: /orders(/|$)(.*) pathType: Prefix backend: service: name: order-service port: number: 8080 - path: /products(/|$)(.*) pathType: Prefix backend: service: name: product-service port: number: 8080 . 2. 프론트엔드/백엔드 분리 . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: frontend-backend-ingress spec: ingressClassName: nginx rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: frontend-service port: number: 80 - host: api.example.com http: paths: - path: / pathType: Prefix backend: service: name: backend-service port: number: 8080 . 3. A/B 테스팅 . apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ab-testing-ingress annotations: nginx.ingress.kubernetes.io/canary: \"true\" nginx.ingress.kubernetes.io/canary-weight: \"20\" spec: ingressClassName: nginx rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: new-version-service port: number: 80 --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: stable-ingress spec: ingressClassName: nginx rules: - host: example.com http: paths: - path: / pathType: Prefix backend: service: name: stable-version-service port: number: 80 . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-사용-사례"
  },"224": {
    "doc": "Ingress",
    "title": "Ingress 보안",
    "content": "NetworkPolicy . apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: ingress-network-policy spec: podSelector: matchLabels: app: web policyTypes: - Ingress ingress: - from: - namespaceSelector: matchLabels: name: ingress-nginx ports: - protocol: TCP port: 80 . 인증 및 권한 부여 . apiVersion: v1 kind: Secret metadata: name: basic-auth type: Opaque data: auth: &lt;base64-encoded-htpasswd&gt; --- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: auth-ingress annotations: nginx.ingress.kubernetes.io/auth-type: basic nginx.ingress.kubernetes.io/auth-secret: basic-auth nginx.ingress.kubernetes.io/auth-realm: \"Authentication Required\" spec: ingressClassName: nginx rules: - host: secure.example.com http: paths: - path: / pathType: Prefix backend: service: name: secure-service port: number: 80 . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%EB%B3%B4%EC%95%88",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-보안"
  },"225": {
    "doc": "Ingress",
    "title": "Ingress 모니터링",
    "content": "메트릭 수집 . apiVersion: v1 kind: ConfigMap metadata: name: nginx-configuration namespace: ingress-nginx data: enable-real-ip: \"true\" use-proxy-protocol: \"true\" proxy-real-ip-cidr: \"0.0.0.0/0\" enable-vts-status: \"true\" . 로그 설정 . apiVersion: v1 kind: ConfigMap metadata: name: nginx-configuration namespace: ingress-nginx data: log-format-escape-json: \"true\" log-format-upstream: '{\"time\": \"$time_iso8601\", \"remote_addr\": \"$proxy_protocol_addr\", \"x_forward_for\": \"$proxy_add_x_forwarded_for\", \"request_id\": \"$req_id\", \"remote_user\": \"$remote_user\", \"bytes_sent\": $bytes_sent, \"request_time\": $request_time, \"status\": $status, \"vhost\": \"$host\", \"request_proto\": \"$server_protocol\", \"path\": \"$uri\", \"request_query\": \"$args\", \"request_length\": $request_length, \"duration\": $request_time,\"method\": \"$request_method\", \"http_referrer\": \"$http_referer\", \"http_user_agent\": \"$http_user_agent\" }' . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-모니터링"
  },"226": {
    "doc": "Ingress",
    "title": "Ingress vs Service",
    "content": "| 특징 | Ingress | Service | . | OSI 레이어 | L7 (Application) | L4 (Transport) | . | 로드 밸런싱 | 고급 로드 밸런싱 | 기본 로드 밸런싱 | . | SSL/TLS | 지원 | 지원 안함 | . | Path 기반 라우팅 | 지원 | 지원 안함 | . | Host 기반 라우팅 | 지원 | 지원 안함 | . | 사용 사례 | 외부 웹 트래픽 | 내부 서비스 | . ",
    "url": "/docs/k8s/componentes/ingress.html#ingress-vs-service",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#ingress-vs-service"
  },"227": {
    "doc": "Ingress",
    "title": "주의사항",
    "content": ". | Ingress Controller: Ingress를 사용하려면 Ingress Controller가 설치되어 있어야 합니다 | SSL 인증서: 자동 SSL 인증서를 사용하려면 cert-manager가 필요합니다 | 네트워크 정책: 보안을 위해 NetworkPolicy를 설정해야 합니다 | 모니터링: Ingress의 상태와 성능을 지속적으로 모니터링해야 합니다 | 리소스 제한: Ingress Controller에 적절한 리소스 제한을 설정해야 합니다 | . ",
    "url": "/docs/k8s/componentes/ingress.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/ingress.html#주의사항"
  },"228": {
    "doc": "Ingress",
    "title": "Ingress",
    "content": " ",
    "url": "/docs/k8s/componentes/ingress.html",
    
    "relUrl": "/docs/k8s/componentes/ingress.html"
  },"229": {
    "doc": "How to Install Jekyll",
    "title": "How to install jekyll in mac",
    "content": "brew install chruby ruby-install ruby-install ruby 3.4.1 echo \"source $(brew --prefix)/opt/chruby/share/chruby/chruby.sh\" &gt;&gt; ~/.zshrc echo \"source $(brew --prefix)/opt/chruby/share/chruby/auto.sh\" &gt;&gt; ~/.zshrc echo \"chruby ruby-3.4.1\" &gt;&gt; ~/.zshrc # run 'chruby' to see actual version gem install jekyll . ",
    "url": "/docs/jekyll/install-jekyll.html#how-to-install-jekyll-in-mac",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#how-to-install-jekyll-in-mac"
  },"230": {
    "doc": "How to Install Jekyll",
    "title": "Installing bundler",
    "content": "What is Bundler . | Bundler is tool managements dependencies. | . ",
    "url": "/docs/jekyll/install-jekyll.html#installing-bundler",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#installing-bundler"
  },"231": {
    "doc": "How to Install Jekyll",
    "title": "why use Bundler??",
    "content": ". | Ruby-based projects such jekyll and github pages require multiple gems (ruby packages), and Bundler allows you to install and manage all of those dependecies automatically | Benefit is creating a reproducible environment by unifying the gem version for each project | . ",
    "url": "/docs/jekyll/install-jekyll.html#why-use-bundler",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#why-use-bundler"
  },"232": {
    "doc": "How to Install Jekyll",
    "title": "How to install bundler",
    "content": "gem install bundler . ",
    "url": "/docs/jekyll/install-jekyll.html#how-to-install-bundler",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#how-to-install-bundler"
  },"233": {
    "doc": "How to Install Jekyll",
    "title": "How to set jekyll project",
    "content": " ",
    "url": "/docs/jekyll/install-jekyll.html#how-to-set-jekyll-project",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#how-to-set-jekyll-project"
  },"234": {
    "doc": "How to Install Jekyll",
    "title": "First step",
    "content": "mkdir docs cd docs git checkout --orphan gh-pages # this branch is called gh-pages does not create history or contents git rm -rf . # removes the contents from your default branch from the working directory jekyll new --skip-bundle . # creates a jekyll site in the current directory . ",
    "url": "/docs/jekyll/install-jekyll.html#first-step",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#first-step"
  },"235": {
    "doc": "How to Install Jekyll",
    "title": "Second step",
    "content": "Edit Gemfile . Add \"#\" to the beggining of the line that starts with \"gem \"jekyll\"\" to comment out this line Remove \"#\" to the beggining of the line that starts with `gem \"github-pages\"` to comment out this line . ",
    "url": "/docs/jekyll/install-jekyll.html#second-step",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#second-step"
  },"236": {
    "doc": "How to Install Jekyll",
    "title": "Thrid step",
    "content": "bundle install Add `Gemfile.lock` into .gitignore file . ",
    "url": "/docs/jekyll/install-jekyll.html#thrid-step",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#thrid-step"
  },"237": {
    "doc": "How to Install Jekyll",
    "title": "Fourth step",
    "content": ". | Optinally, make any necessary edits to the _config.yml file. This is required for relative paths when the repository is hosted in a subdirectory. # _config.yml baseurl # the subpath of you site url # the base hostname &amp; protocol for your site domain # if you want to force HTTPS, specify the domain without the http at the start . | . ",
    "url": "/docs/jekyll/install-jekyll.html#fourth-step",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#fourth-step"
  },"238": {
    "doc": "How to Install Jekyll",
    "title": "Notice",
    "content": ". | To make it appear in the text, Put it in the _posts folder | The front-meter is essential at the top --- layout: post title: \"How to Install Jekyll\" date: 2025-07-06 --- . | . ",
    "url": "/docs/jekyll/install-jekyll.html#notice",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#notice"
  },"239": {
    "doc": "How to Install Jekyll",
    "title": "How to start jekyll in local",
    "content": "bundle exec jekyll serve . ",
    "url": "/docs/jekyll/install-jekyll.html#how-to-start-jekyll-in-local",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#how-to-start-jekyll-in-local"
  },"240": {
    "doc": "How to Install Jekyll",
    "title": "Set the just-the-docs",
    "content": "# Gemfile gem \"just-the-docs\" . # _config.yml theme: just-the-docs . ",
    "url": "/docs/jekyll/install-jekyll.html#set-the-just-the-docs",
    
    "relUrl": "/docs/jekyll/install-jekyll.html#set-the-just-the-docs"
  },"241": {
    "doc": "How to Install Jekyll",
    "title": "How to Install Jekyll",
    "content": " ",
    "url": "/docs/jekyll/install-jekyll.html",
    
    "relUrl": "/docs/jekyll/install-jekyll.html"
  },"242": {
    "doc": "How to use just-the-docs docs",
    "title": "Just the docs guide",
    "content": "Go just the docs . ",
    "url": "/docs/jekyll/just-the-docs.html#just-the-docs-guide",
    
    "relUrl": "/docs/jekyll/just-the-docs.html#just-the-docs-guide"
  },"243": {
    "doc": "How to use just-the-docs docs",
    "title": "How to use just-the-docs docs",
    "content": " ",
    "url": "/docs/jekyll/just-the-docs.html",
    
    "relUrl": "/docs/jekyll/just-the-docs.html"
  },"244": {
    "doc": "kube-system",
    "title": "kube-system",
    "content": " ",
    "url": "/docs/k8s/componentes/kube-system.html",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html"
  },"245": {
    "doc": "kube-system",
    "title": "개요",
    "content": "kube-system은 Kubernetes 클러스터의 핵심 시스템 컴포넌트들이 실행되는 네임스페이스입니다. 클러스터의 정상적인 운영을 위해 필수적인 시스템 Pod, Service, ConfigMap 등이 이 네임스페이스에 위치합니다. 주요 특징 . | 시스템 전용: 클러스터 운영에 필수적인 컴포넌트들만 포함 | 보호된 네임스페이스: 일반 사용자의 접근이 제한됨 | 자동 생성: 클러스터 초기화 시 자동으로 생성 | 고가용성: 클러스터의 안정적인 운영을 보장 | 모니터링: 클러스터 상태 모니터링의 핵심 | . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#개요"
  },"246": {
    "doc": "kube-system",
    "title": "구조",
    "content": "graph TB subgraph \"kube-system 네임스페이스\" subgraph \"Control Plane\" API[API Server] Scheduler[Scheduler] Controller[Controller Manager] ETCD[etcd] end subgraph \"Node Components\" Kubelet[Kubelet] Proxy[Kube Proxy] CNI[CNI Plugin] end subgraph \"Add-ons\" DNS[CoreDNS] Dashboard[Dashboard] Metrics[Metrics Server] Ingress[Ingress Controller] end subgraph \"Monitoring\" Prometheus[Prometheus] Grafana[Grafana] AlertManager[Alert Manager] end end API --&gt; Scheduler API --&gt; Controller API --&gt; ETCD Kubelet --&gt; API Proxy --&gt; API DNS --&gt; API . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#구조"
  },"247": {
    "doc": "kube-system",
    "title": "주요 컴포넌트",
    "content": "1. Control Plane 컴포넌트 . API Server . apiVersion: v1 kind: Pod metadata: name: kube-apiserver-master namespace: kube-system labels: component: kube-apiserver tier: control-plane spec: containers: - name: kube-apiserver image: k8s.gcr.io/kube-apiserver:v1.24.0 command: - kube-apiserver - --advertise-address=192.168.1.100 - --allow-privileged=true - --authorization-mode=Node,RBAC - --client-ca-file=/etc/kubernetes/pki/ca.crt - --enable-admission-plugins=NodeRestriction - --enable-bootstrap-token-auth=true - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key - --etcd-servers=https://127.0.0.1:2379 - --kubelet-client-certificate=/etc/kubernetes/pki/apiserver-kubelet-client.crt - --kubelet-client-key=/etc/kubernetes/pki/apiserver-kubelet-client.key - --service-account-key-file=/etc/kubernetes/pki/sa.pub - --service-cluster-ip-range=10.96.0.0/12 - --tls-cert-file=/etc/kubernetes/pki/apiserver.crt - --tls-private-key-file=/etc/kubernetes/pki/apiserver.key ports: - containerPort: 6443 name: https - containerPort: 8080 name: http volumeMounts: - name: k8s-certs mountPath: /etc/kubernetes/pki readOnly: true - name: kubeconfig mountPath: /etc/kubernetes/ readOnly: true . Scheduler . apiVersion: v1 kind: Pod metadata: name: kube-scheduler-master namespace: kube-system labels: component: kube-scheduler tier: control-plane spec: containers: - name: kube-scheduler image: k8s.gcr.io/kube-scheduler:v1.24.0 command: - kube-scheduler - --authentication-kubeconfig=/etc/kubernetes/scheduler.conf - --authorization-kubeconfig=/etc/kubernetes/scheduler.conf - --bind-address=127.0.0.1 - --kubeconfig=/etc/kubernetes/scheduler.conf - --leader-elect=true - --port=0 volumeMounts: - name: kubeconfig mountPath: /etc/kubernetes readOnly: true . Controller Manager . apiVersion: v1 kind: Pod metadata: name: kube-controller-manager-master namespace: kube-system labels: component: kube-controller-manager tier: control-plane spec: containers: - name: kube-controller-manager image: k8s.gcr.io/kube-controller-manager:v1.24.0 command: - kube-controller-manager - --allocate-node-cidrs=true - --authentication-kubeconfig=/etc/kubernetes/controller-manager.conf - --authorization-kubeconfig=/etc/kubernetes/controller-manager.conf - --bind-address=127.0.0.1 - --client-ca-file=/etc/kubernetes/pki/ca.crt - --cluster-cidr=10.244.0.0/16 - --cluster-name=kubernetes - --cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt - --cluster-signing-key-file=/etc/kubernetes/pki/ca.key - --kubeconfig=/etc/kubernetes/controller-manager.conf - --leader-elect=true - --port=0 - --root-ca-file=/etc/kubernetes/pki/ca.crt - --service-account-private-key-file=/etc/kubernetes/pki/sa.key - --use-service-account-credentials=true volumeMounts: - name: kubeconfig mountPath: /etc/kubernetes readOnly: true - name: k8s-certs mountPath: /etc/kubernetes/pki readOnly: true . 2. Node 컴포넌트 . Kubelet . apiVersion: v1 kind: Pod metadata: name: kubelet namespace: kube-system spec: containers: - name: kubelet image: k8s.gcr.io/kubelet:v1.24.0 command: - kubelet - --config=/var/lib/kubelet/config.yaml - --container-runtime=remote - --container-runtime-endpoint=unix:///var/run/containerd/containerd.sock - --pod-infra-container-image=k8s.gcr.io/pause:3.6 - --kubeconfig=/etc/kubernetes/kubelet.conf - --register-node=true - --v=2 volumeMounts: - name: var-lib-kubelet mountPath: /var/lib/kubelet - name: etc-kubernetes mountPath: /etc/kubernetes readOnly: true - name: var-lib-docker mountPath: /var/lib/docker - name: dev-shm mountPath: /dev/shm - name: sys mountPath: /sys - name: proc mountPath: /proc . Kube Proxy . apiVersion: apps/v1 kind: DaemonSet metadata: name: kube-proxy namespace: kube-system labels: k8s-app: kube-proxy spec: selector: matchLabels: k8s-app: kube-proxy template: metadata: labels: k8s-app: kube-proxy spec: containers: - name: kube-proxy image: k8s.gcr.io/kube-proxy:v1.24.0 command: - /usr/local/bin/kube-proxy - --config=/var/lib/kube-proxy/config.conf - --hostname-override=$(NODE_NAME) env: - name: NODE_NAME valueFrom: fieldRef: fieldPath: spec.nodeName securityContext: privileged: true volumeMounts: - name: kube-proxy mountPath: /var/lib/kube-proxy - name: xtables-lock mountPath: /run/xtables.lock volumes: - name: kube-proxy configMap: name: kube-proxy - name: xtables-lock hostPath: path: /run/xtables.lock type: FileOrCreate . 3. Add-on 컴포넌트 . CoreDNS . apiVersion: v1 kind: ServiceAccount metadata: name: coredns namespace: kube-system labels: kubernetes.io/cluster-service: \"true\" addonmanager.kubernetes.io/mode: Reconcile --- apiVersion: v1 kind: ConfigMap metadata: name: coredns namespace: kube-system labels: addonmanager.kubernetes.io/mode: EnsureExists data: Corefile: | .:53 { errors health { lameduck 5s } ready kubernetes cluster.local in-addr.arpa ip6.arpa { pods insecure fallthrough in-addr.arpa ip6.arpa ttl 30 } prometheus :9153 forward . /etc/resolv.conf { max_concurrent 1000 } cache 30 loop reload loadbalance } --- apiVersion: apps/v1 kind: Deployment metadata: name: coredns namespace: kube-system labels: k8s-app: kube-dns kubernetes.io/cluster-service: \"true\" addonmanager.kubernetes.io/mode: Reconcile kubernetes.io/name: \"CoreDNS\" spec: replicas: 2 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 selector: matchLabels: k8s-app: kube-dns template: metadata: labels: k8s-app: kube-dns spec: priorityClassName: system-cluster-critical serviceAccountName: coredns tolerations: - key: \"CriticalAddonsOnly\" operator: \"Exists\" nodeSelector: beta.kubernetes.io/os: linux containers: - name: coredns image: coredns/coredns:1.8.6 imagePullPolicy: IfNotPresent resources: limits: memory: 170Mi requests: cpu: 100m memory: 70Mi args: [\"-conf\", \"/etc/coredns/Corefile\"] volumeMounts: - name: config-volume mountPath: /etc/coredns readOnly: true ports: - containerPort: 53 name: dns protocol: UDP - containerPort: 53 name: dns-tcp protocol: TCP - containerPort: 9153 name: metrics protocol: TCP livenessProbe: httpGet: path: /health port: 8080 scheme: HTTP readinessProbe: httpGet: path: /ready port: 8181 scheme: HTTP volumes: - name: config-volume configMap: name: coredns items: - key: Corefile path: Corefile --- apiVersion: v1 kind: Service metadata: name: kube-dns namespace: kube-system labels: k8s-app: kube-dns kubernetes.io/cluster-service: \"true\" addonmanager.kubernetes.io/mode: Reconcile kubernetes.io/name: \"CoreDNS\" spec: selector: k8s-app: kube-dns clusterIP: 10.96.0.10 ports: - name: dns port: 53 protocol: UDP - name: dns-tcp port: 53 protocol: TCP - name: metrics port: 9153 protocol: TCP . Metrics Server . apiVersion: v1 kind: ServiceAccount metadata: name: metrics-server namespace: kube-system --- apiVersion: apps/v1 kind: Deployment metadata: name: metrics-server namespace: kube-system labels: k8s-app: metrics-server spec: selector: matchLabels: k8s-app: metrics-server template: metadata: labels: k8s-app: metrics-server spec: serviceAccountName: metrics-server containers: - name: metrics-server image: k8s.gcr.io/metrics-server/metrics-server:v0.6.1 args: - --cert-dir=/tmp - --secure-port=4443 - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname - --kubelet-insecure-tls ports: - name: main-port containerPort: 4443 protocol: TCP securityContext: readOnlyRootFilesystem: true runAsNonRoot: true runAsUser: 1000 volumeMounts: - name: tmp-dir mountPath: /tmp volumes: - name: tmp-dir emptyDir: {} --- apiVersion: v1 kind: Service metadata: name: metrics-server namespace: kube-system labels: kubernetes.io/name: \"Metrics-server\" kubernetes.io/cluster-service: \"true\" spec: selector: k8s-app: metrics-server ports: - port: 443 protocol: TCP targetPort: main-port . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EC%A3%BC%EC%9A%94-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#주요-컴포넌트"
  },"248": {
    "doc": "kube-system",
    "title": "관리 명령어",
    "content": "kube-system 네임스페이스 조회 . # kube-system 네임스페이스의 모든 리소스 조회 kubectl get all -n kube-system # Pod 목록 조회 kubectl get pods -n kube-system # Service 목록 조회 kubectl get services -n kube-system # ConfigMap 목록 조회 kubectl get configmaps -n kube-system . 시스템 컴포넌트 상태 확인 . # Control Plane 컴포넌트 상태 확인 kubectl get pods -n kube-system -l tier=control-plane # Node 컴포넌트 상태 확인 kubectl get pods -n kube-system -l k8s-app=kube-proxy # DNS 상태 확인 kubectl get pods -n kube-system -l k8s-app=kube-dns # Metrics Server 상태 확인 kubectl get pods -n kube-system -l k8s-app=metrics-server . 로그 확인 . # API Server 로그 확인 kubectl logs kube-apiserver-master -n kube-system # Scheduler 로그 확인 kubectl logs kube-scheduler-master -n kube-system # Controller Manager 로그 확인 kubectl logs kube-controller-manager-master -n kube-system # CoreDNS 로그 확인 kubectl logs -l k8s-app=kube-dns -n kube-system . 시스템 컴포넌트 디버깅 . # API Server 상세 정보 kubectl describe pod kube-apiserver-master -n kube-system # CoreDNS 상세 정보 kubectl describe pod -l k8s-app=kube-dns -n kube-system # Metrics Server 상세 정보 kubectl describe pod -l k8s-app=metrics-server -n kube-system . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#관리-명령어"
  },"249": {
    "doc": "kube-system",
    "title": "모니터링",
    "content": "클러스터 상태 확인 . # 노드 상태 확인 kubectl get nodes # 클러스터 정보 확인 kubectl cluster-info # API 서버 상태 확인 kubectl get --raw='/readyz?verbose' # 클러스터 버전 확인 kubectl version --short . 시스템 리소스 사용량 . # kube-system 네임스페이스 리소스 사용량 kubectl top pods -n kube-system # 노드별 리소스 사용량 kubectl top nodes # 특정 Pod 리소스 사용량 kubectl top pod kube-apiserver-master -n kube-system . 이벤트 확인 . # kube-system 네임스페이스 이벤트 kubectl get events -n kube-system # 특정 Pod 이벤트 kubectl get events -n kube-system --field-selector involvedObject.name=kube-apiserver-master . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#모니터링"
  },"250": {
    "doc": "kube-system",
    "title": "보안 고려사항",
    "content": "1. 접근 제어 . # kube-system 네임스페이스 접근 제한 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: kube-system-reader rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\"] verbs: [\"get\", \"list\", \"watch\"] resourceNames: [\"kube-system\"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: kube-system-reader-binding subjects: - kind: ServiceAccount name: monitoring-sa namespace: monitoring roleRef: kind: ClusterRole name: kube-system-reader apiGroup: rbac.authorization.k8s.io . 2. 네트워크 정책 . # kube-system 네임스페이스 네트워크 정책 apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: kube-system-network-policy namespace: kube-system spec: podSelector: {} policyTypes: - Ingress - Egress ingress: - from: - namespaceSelector: matchLabels: name: kube-system ports: - protocol: TCP port: 53 - protocol: UDP port: 53 egress: - to: - namespaceSelector: matchLabels: name: kube-system ports: - protocol: TCP port: 53 - protocol: UDP port: 53 . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EB%B3%B4%EC%95%88-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#보안-고려사항"
  },"251": {
    "doc": "kube-system",
    "title": "문제 해결",
    "content": "1. API Server 문제 . # API Server 상태 확인 kubectl get pods -n kube-system -l component=kube-apiserver # API Server 로그 확인 kubectl logs kube-apiserver-master -n kube-system --tail=100 # API Server 설정 확인 kubectl describe pod kube-apiserver-master -n kube-system . 2. DNS 문제 . # CoreDNS Pod 상태 확인 kubectl get pods -n kube-system -l k8s-app=kube-dns # DNS 서비스 확인 kubectl get service kube-dns -n kube-system # DNS 로그 확인 kubectl logs -l k8s-app=kube-dns -n kube-system # DNS 테스트 kubectl run test-dns --image=busybox --rm -it --restart=Never -- nslookup kubernetes.default . 3. Metrics Server 문제 . # Metrics Server 상태 확인 kubectl get pods -n kube-system -l k8s-app=metrics-server # Metrics Server 로그 확인 kubectl logs -l k8s-app=metrics-server -n kube-system # Metrics API 테스트 kubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#문제-해결"
  },"252": {
    "doc": "kube-system",
    "title": "주의사항",
    "content": "1. 수동 수정 금지 . | kube-system 네임스페이스의 리소스는 수동으로 수정하지 않음 | 클러스터 관리 도구를 통해서만 관리 | 직접적인 Pod 삭제나 수정은 클러스터 장애를 야기할 수 있음 | . 2. 리소스 모니터링 . | 시스템 컴포넌트의 리소스 사용량 정기 확인 | 메모리나 CPU 부족 시 클러스터 성능 저하 가능 | 적절한 리소스 제한 설정 | . 3. 백업 및 복구 . | etcd 데이터 정기 백업 | 클러스터 설정 파일 백업 | 재해 복구 계획 수립 | . 4. 보안 업데이트 . | 정기적인 Kubernetes 버전 업데이트 | 보안 패치 적용 | 취약점 스캔 및 모니터링 | . ",
    "url": "/docs/k8s/componentes/kube-system.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#주의사항"
  },"253": {
    "doc": "kube-system",
    "title": "결론",
    "content": "kube-system 네임스페이스는 Kubernetes 클러스터의 핵심 시스템 컴포넌트들이 위치하는 중요한 네임스페이스입니다. 클러스터의 안정적인 운영을 위해 Control Plane 컴포넌트, Node 컴포넌트, 그리고 다양한 Add-on들이 이 네임스페이스에서 실행됩니다. 적절한 모니터링과 보안 설정을 통해 클러스터의 안정성을 보장하는 것이 중요합니다. ",
    "url": "/docs/k8s/componentes/kube-system.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/k8s/componentes/kube-system.html#결론"
  },"254": {
    "doc": "Spring WebFlux Overview",
    "title": "Spring WebFlux Overview",
    "content": " ",
    "url": "/docs/spring/overview.html",
    
    "relUrl": "/docs/spring/overview.html"
  },"255": {
    "doc": "Spring WebFlux Overview",
    "title": "개요",
    "content": "Spring WebFlux는 Spring Framework 5에서 도입된 반응형 웹 프레임워크로, 논블로킹 I/O와 리액티브 스트림을 기반으로 한다. 기존 Spring MVC와 함께 사용하거나 독립적으로 사용할 수 있으며, 고성능, 확장 가능한 웹 애플리케이션을 구축할 수 있습니다. ",
    "url": "/docs/spring/overview.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/spring/overview.html#개요"
  },"256": {
    "doc": "Spring WebFlux Overview",
    "title": "WebFlux가 생성된 이유",
    "content": "1. 논블로킹 웹 스택의 필요성 . | 적은 수의 스레드로 동시성 처리: 이벤트 루프 모델을 통해 적은 하드웨어 리소스로 확장 가능 | Servlet API의 한계: Servlet의 논블로킹 I/O가 기존 동기식 API와 충돌 | 새로운 공통 API 필요: 다양한 논블로킹 런타임을 지원하는 기반 API 필요 | Netty 등 비동기 서버 지원: 이미 확립된 비동기, 논블로킹 서버들과의 호환성 | . 2. 함수형 프로그래밍의 도입 . | Java 8 Lambda 표현식: 함수형 API 구현의 기회 창출 | 선언적 비동기 로직: CompletableFuture와 ReactiveX 스타일의 연속성 API | 함수형 웹 엔드포인트: 어노테이션 기반 컨트롤러와 함께 함수형 엔드포인트 제공 | . ",
    "url": "/docs/spring/overview.html#webflux%EA%B0%80-%EC%83%9D%EC%84%B1%EB%90%9C-%EC%9D%B4%EC%9C%A0",
    
    "relUrl": "/docs/spring/overview.html#webflux가-생성된-이유"
  },"257": {
    "doc": "Spring WebFlux Overview",
    "title": "“Reactive”의 정의",
    "content": "1. 반응형 프로그래밍 모델 . | 변화에 대한 반응: 네트워크 컴포넌트가 I/O 이벤트에 반응, UI 컨트롤러가 마우스 이벤트에 반응 | 논블로킹의 반응형 특성: 블로킹 대신 작업 완료나 데이터 가용성에 대한 알림에 반응 | . 2. 논블로킹 백프레셔 . | 동기식 코드의 자연스러운 백프레셔: 블로킹 호출이 호출자를 대기시키는 자연스러운 형태 | 논블로킹 코드의 백프레셔 제어: 빠른 생산자가 목적지를 압도하지 않도록 이벤트 속도 제어 | Reactive Streams: Java 9에서 채택된 작은 스펙으로 비동기 컴포넌트 간 상호작용 정의 | . 3. Reactive Streams의 목적 . graph LR Publisher[Publisher&lt;br/&gt;데이터 생산자] --&gt; Subscriber[Subscriber&lt;br/&gt;데이터 구독자] Subscriber --&gt; Backpressure[Backpressure&lt;br/&gt;흐름 제어] subgraph \"Reactive Streams\" Publisher Subscriber Backpressure end . | 구독자가 속도 제어: 구독자가 생산자의 데이터 생산 속도를 제어 | 상호운용성: 라이브러리와 인프라 컴포넌트 간의 상호운용성 제공 | 애플리케이션 API: 높은 수준의 함수형 API 필요 | . ",
    "url": "/docs/spring/overview.html#reactive%EC%9D%98-%EC%A0%95%EC%9D%98",
    
    "relUrl": "/docs/spring/overview.html#reactive의-정의"
  },"258": {
    "doc": "Spring WebFlux Overview",
    "title": "Reactive API",
    "content": "1. Reactor 라이브러리 . | Spring WebFlux의 선택된 리액티브 라이브러리 | Mono와 Flux API: 0..1 (Mono) 및 0..N (Flux) 데이터 시퀀스 처리 | ReactiveX 연산자: 풍부한 연산자 세트 제공 | 서버 사이드 Java: Spring과 긴밀한 협력으로 개발 | . 2. 상호운용성 . // WebFlux는 일반 Publisher를 입력으로 받아 Reactor 타입으로 내부 변환 // 출력은 Flux 또는 Mono로 반환 Mono&lt;String&gt; result = webFluxApi.accept(publisher); . | Reactive Streams 통한 상호운용: 다른 리액티브 라이브러리와 호환 | 투명한 적응: RxJava 등 다른 리액티브 라이브러리와 투명하게 적응 | Kotlin Coroutines: Kotlin에서 더 명령형 스타일의 프로그래밍 제공 | . ",
    "url": "/docs/spring/overview.html#reactive-api",
    
    "relUrl": "/docs/spring/overview.html#reactive-api"
  },"259": {
    "doc": "Spring WebFlux Overview",
    "title": "프로그래밍 모델",
    "content": "1. 어노테이션 기반 컨트롤러 . @RestController public class UserController { @GetMapping(\"/users/{id}\") public Mono&lt;User&gt; getUser(@PathVariable String id) { return userService.findById(id); } @GetMapping(\"/users\") public Flux&lt;User&gt; getAllUsers() { return userService.findAll(); } } . | Spring MVC와 일관성: spring-web 모듈의 동일한 어노테이션 기반 | 리액티브 반환 타입: Reactor와 RxJava 반환 타입 지원 | 리액티브 @RequestBody: WebFlux만의 리액티브 요청 본문 인수 지원 | . 2. 함수형 엔드포인트 . @Configuration public class RouterConfig { @Bean public RouterFunction&lt;ServerResponse&gt; userRoutes(UserHandler userHandler) { return RouterFunctions .route(GET(\"/users/{id}\"), userHandler::getUser) .andRoute(GET(\"/users\"), userHandler::getAllUsers); } } . | Lambda 기반: 경량화된 함수형 프로그래밍 모델 | 애플리케이션 제어: 어노테이션 선언 대신 애플리케이션이 요청 처리 전체 과정 제어 | 작은 라이브러리: 라우팅과 요청 처리를 위한 유틸리티 세트 | . ",
    "url": "/docs/spring/overview.html#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A8%EB%8D%B8",
    
    "relUrl": "/docs/spring/overview.html#프로그래밍-모델"
  },"260": {
    "doc": "Spring WebFlux Overview",
    "title": "적용 가능성: Spring MVC vs WebFlux",
    "content": "1. 선택 가이드 . graph TB subgraph \"Spring MVC\" MVC[기존 MVC 애플리케이션&lt;br/&gt;정상 작동] Imperative[명령형 프로그래밍&lt;br/&gt;쉬운 작성/이해/디버깅] Libraries[최대 라이브러리 선택&lt;br/&gt;대부분 블로킹] end subgraph \"Spring WebFlux\" NonBlocking[논블로킹 웹 스택&lt;br/&gt;필요] Functional[함수형 웹 프레임워크&lt;br/&gt;Java 8 Lambda/Kotlin] Microservices[마이크로서비스&lt;br/&gt;혼합 아키텍처] end style MVC fill:#e1f5fe style NonBlocking fill:#e8f5e8 style Functional fill:#fff3e0 . 2. 구체적인 고려사항 . Spring MVC를 선택해야 하는 경우: . | 기존 Spring MVC 애플리케이션: 정상 작동하는 경우 변경 불필요 | 명령형 프로그래밍: 코드 작성, 이해, 디버깅이 가장 쉬운 방법 | 최대 라이브러리 선택: 역사적으로 대부분이 블로킹 라이브러리 | 블로킹 지속성 API: JPA, JDBC 등 블로킹 API 사용 시 | . Spring WebFlux를 선택해야 하는 경우: . | 논블로킹 웹 스택 필요: 다른 논블로킹 스택과 동일한 실행 모델 이점 | 서버 선택: Netty, Tomcat, Jetty, Undertow, Servlet 컨테이너 | 프로그래밍 모델 선택: 어노테이션 컨트롤러와 함수형 웹 엔드포인트 | 리액티브 라이브러리 선택: Reactor, RxJava 또는 기타 | 경량 함수형 웹 프레임워크: Java 8 Lambda나 Kotlin 사용 | 마이크로서비스 아키텍처: Spring MVC와 WebFlux 혼합 사용 | . 3. 실용적 접근 방법 . 점진적 도입: . | 기존 Spring MVC + WebClient: 원격 서비스 호출에 반응형 WebClient 사용 | 리액티브 타입 반환: Spring MVC 컨트롤러에서 직접 리액티브 타입 반환 | 작은 규모로 시작: 전체 전환 없이 작은 규모로 시작하고 이점 측정 | 학습 곡선 고려: 대규모 팀의 경우 논블로킹, 함수형, 선언적 프로그래밍의 가파른 학습 곡선 고려 | . ",
    "url": "/docs/spring/overview.html#%EC%A0%81%EC%9A%A9-%EA%B0%80%EB%8A%A5%EC%84%B1-spring-mvc-vs-webflux",
    
    "relUrl": "/docs/spring/overview.html#적용-가능성-spring-mvc-vs-webflux"
  },"261": {
    "doc": "Spring WebFlux Overview",
    "title": "서버 지원",
    "content": "1. 지원 서버 . | Servlet 컨테이너: Tomcat, Jetty | 비Servlet 런타임: Netty, Undertow | 공통 API: 모든 서버가 저수준 공통 API로 적응 | . 2. 서버별 특성 . graph TB subgraph \"Spring MVC\" MVCTomcat[Tomcat - Servlet 블로킹 I/O] MVCJetty[Jetty - Servlet 블로킹 I/O] MVCServlet[Servlet API 직접 사용] end subgraph \"Spring WebFlux\" FluxNetty[Netty - 비Servlet 런타임] FluxUndertow[Undertow - 직접 API 사용] FluxServlet[Servlet 논블로킹 I/O&lt;br/&gt;저수준 어댑터 사용] end style MVCServlet fill:#ffebee style FluxServlet fill:#e8f5e8 . 3. 주의사항 . | Servlet 필터 매핑 금지: WebFlux 애플리케이션에서 Servlet 필터 매핑 금지 | Servlet API 직접 조작 금지: 블로킹 I/O와 논블로킹 I/O 혼합 시 런타임 이슈 발생 | Spring Boot 기본값: Netty를 기본으로 사용 (비동기, 논블로킹 공간에서 널리 사용) | . ",
    "url": "/docs/spring/overview.html#%EC%84%9C%EB%B2%84-%EC%A7%80%EC%9B%90",
    
    "relUrl": "/docs/spring/overview.html#서버-지원"
  },"262": {
    "doc": "Spring WebFlux Overview",
    "title": "Netty vs Tomcat 서버 비교",
    "content": "1. 아키텍처 차이점 . graph TB subgraph \"Tomcat (Servlet Container)\" TomcatRequest[HTTP Request] --&gt; TomcatConnector[Connector] TomcatConnector --&gt; TomcatThreadPool[Thread Pool&lt;br/&gt;Request-per-Thread] TomcatThreadPool --&gt; TomcatServlet[Servlet Container] TomcatServlet --&gt; TomcatApp[Spring MVC Application] TomcatApp --&gt; TomcatResponse[HTTP Response] end subgraph \"Netty (Event Loop)\" NettyRequest[HTTP Request] --&gt; NettyEventLoop[Event Loop] NettyEventLoop --&gt; NettyChannel[Channel Pipeline] NettyChannel --&gt; NettyHandler[Channel Handler] NettyHandler --&gt; NettyApp[Spring WebFlux Application] NettyApp --&gt; NettyResponse[HTTP Response] end style TomcatThreadPool fill:#ffebee style NettyEventLoop fill:#e8f5e8 . 2. 핵심 차이점 . | 특성 | Tomcat | Netty | . | 스레드 모델 | Thread-per-request | Event Loop | . | 동시성 처리 | 스레드 풀 기반 | 이벤트 루프 기반 | . | 메모리 사용량 | 높음 (스레드당 ~1MB) | 낮음 | . | 확장성 | 제한적 (스레드 풀 크기) | 높음 | . | 블로킹 작업 | 적합 | 부적합 | . | 학습 곡선 | 낮음 | 높음 | . | Servlet API | 직접 사용 | 사용하지 않음 | . 3. Netty 상세 설명 . Netty란? . Netty는 비동기 이벤트 기반 네트워크 애플리케이션 프레임워크로, 고성능 서버와 클라이언트를 빠르고 쉽게 개발할 수 있도록 도와주는 Java 라이브러리입니다. Netty의 핵심 구성 요소 . graph TB subgraph \"Netty Architecture\" Bootstrap[Bootstrap&lt;br/&gt;서버/클라이언트 시작] EventLoopGroup[EventLoopGroup&lt;br/&gt;이벤트 루프 그룹] Channel[Channel&lt;br/&gt;네트워크 연결] ChannelPipeline[ChannelPipeline&lt;br/&gt;핸들러 체인] ChannelHandler[ChannelHandler&lt;br/&gt;비즈니스 로직] end Bootstrap --&gt; EventLoopGroup EventLoopGroup --&gt; Channel Channel --&gt; ChannelPipeline ChannelPipeline --&gt; ChannelHandler subgraph \"Event Loop Model\" EventLoop1[Event Loop 1] EventLoop2[Event Loop 2] EventLoop3[Event Loop 3] EventLoop4[Event Loop 4] end EventLoopGroup --&gt; EventLoop1 EventLoopGroup --&gt; EventLoop2 EventLoopGroup --&gt; EventLoop3 EventLoopGroup --&gt; EventLoop4 . 1. Bootstrap . // 서버 Bootstrap 예제 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() { @Override protected void initChannel(SocketChannel ch) { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new HttpServerCodec()); pipeline.addLast(new HttpObjectAggregator(65536)); pipeline.addLast(new CustomHandler()); } }); . 2. EventLoopGroup . // 이벤트 루프 그룹 설정 EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 연결 수락용 EventLoopGroup workerGroup = new NioEventLoopGroup(); // 요청 처리용 // CPU 코어 수에 따른 최적화 int cores = Runtime.getRuntime().availableProcessors(); EventLoopGroup workerGroup = new NioEventLoopGroup(cores); . 3. Channel과 ChannelPipeline . // 채널 파이프라인 구성 public class CustomChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; { @Override protected void initChannel(SocketChannel ch) { ChannelPipeline pipeline = ch.pipeline(); // HTTP 코덱 추가 pipeline.addLast(\"httpCodec\", new HttpServerCodec()); pipeline.addLast(\"httpAggregator\", new HttpObjectAggregator(65536)); // 커스텀 핸들러 추가 pipeline.addLast(\"customHandler\", new CustomHttpHandler()); // 압축 핸들러 추가 pipeline.addLast(\"deflater\", new HttpContentCompressor()); } } . 4. ChannelHandler . // 커스텀 HTTP 핸들러 예제 public class CustomHttpHandler extends SimpleChannelInboundHandler&lt;FullHttpRequest&gt; { @Override protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) { // HTTP 요청 처리 FullHttpResponse response = new DefaultFullHttpResponse( HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.copiedBuffer(\"Hello, Netty!\", CharsetUtil.UTF_8) ); response.headers().set(HttpHeaderNames.CONTENT_TYPE, \"text/plain\"); response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes()); ctx.writeAndFlush(response); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { cause.printStackTrace(); ctx.close(); } } . 4. Netty의 이벤트 루프 모델 . graph TB subgraph \"Event Loop Processing\" Accept[Accept Event&lt;br/&gt;연결 수락] Read[Read Event&lt;br/&gt;데이터 읽기] Process[Process Event&lt;br/&gt;비즈니스 로직] Write[Write Event&lt;br/&gt;응답 쓰기] end subgraph \"Non-blocking I/O\" NIO[NIO Channels] Selector[Selector&lt;br/&gt;이벤트 선택] Buffer[ByteBuffer&lt;br/&gt;데이터 버퍼] end Accept --&gt; Read Read --&gt; Process Process --&gt; Write NIO --&gt; Selector Selector --&gt; Buffer . 이벤트 루프 동작 원리 . | 연결 수락: 클라이언트 연결을 수락하고 새로운 Channel 생성 | 이벤트 등록: Channel을 Selector에 등록하여 관심 이벤트 모니터링 | 이벤트 처리: Selector가 준비된 이벤트를 감지하면 해당 Channel의 핸들러 호출 | 비동기 처리: 블로킹 없이 이벤트를 순차적으로 처리 | . 5. Netty의 장점 . 1. 높은 성능 . // Netty의 비동기 처리 예제 public class AsyncHandler extends SimpleChannelInboundHandler&lt;HttpRequest&gt; { @Override protected void channelRead0(ChannelHandlerContext ctx, HttpRequest request) { // 비동기 데이터베이스 조회 CompletableFuture.supplyAsync(() -&gt; { return databaseService.query(request.getUri()); }).thenAccept(result -&gt; { // 결과를 비동기로 응답 ctx.writeAndFlush(createResponse(result)); }); } } . 2. 메모리 효율성 . | 적은 스레드: CPU 코어 수만큼의 이벤트 루프 스레드 | 낮은 메모리 사용량: 스레드당 메모리 사용량이 적음 | 버퍼 풀링: ByteBuf 풀링으로 메모리 재사용 | . 3. 확장성 . // 수천 개의 동시 연결 처리 ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 10000) // 백로그 큐 크기 .childOption(ChannelOption.SO_KEEPALIVE, true) .childOption(ChannelOption.TCP_NODELAY, true); . 6. Spring WebFlux에서의 Netty 사용 . 1. Spring Boot WebFlux 기본 설정 . # application.yml spring: webflux: base-path: /api # Netty 설정 netty: connection-timeout: 30s read-timeout: 30s write-timeout: 30s . 2. Netty 커스텀 설정 . @Configuration public class NettyConfig { @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { return new NettyReactiveWebServerFactory() { @Override public WebServer getWebServer(HttpHandler httpHandler) { HttpServer httpServer = HttpServer.create() .port(8080) .option(ChannelOption.SO_BACKLOG, 1000) .option(ChannelOption.SO_REUSEADDR, true) .childOption(ChannelOption.SO_KEEPALIVE, true) .childOption(ChannelOption.TCP_NODELAY, true); return super.getWebServer(httpHandler); } }; } } . 3. Netty 이벤트 루프 모니터링 . @Component public class NettyMetrics { private final MeterRegistry meterRegistry; public NettyMetrics(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } @EventListener public void handleNettyEvent(NettyEvent event) { // Netty 이벤트 메트릭 수집 Timer.Sample sample = Timer.start(meterRegistry); event.getChannel().closeFuture().addListener(future -&gt; { sample.stop(Timer.builder(\"netty.connection.duration\") .tag(\"channel\", event.getChannel().id().asLongText()) .register(meterRegistry)); }); } } . 7. Tomcat vs Netty 성능 비교 . graph TB subgraph \"동시 연결 처리\" TomcatConnections[Tomcat&lt;br/&gt;제한적 (스레드 풀 크기)] NettyConnections[Netty&lt;br/&gt;높음 (이벤트 루프)] end subgraph \"메모리 사용량\" TomcatMemory[Tomcat&lt;br/&gt;높음 (스레드당 ~1MB)] NettyMemory[Netty&lt;br/&gt;낮음 (이벤트 루프)] end subgraph \"응답 시간\" TomcatLatency[Tomcat&lt;br/&gt;일정함] NettyLatency[Netty&lt;br/&gt;빠름 (비동기)] end subgraph \"리소스 효율성\" TomcatEfficiency[Tomcat&lt;br/&gt;낮음] NettyEfficiency[Netty&lt;br/&gt;높음] end . 8. 언제 어떤 서버를 선택할까? . Netty를 선택해야 하는 경우: . | 고성능 요구: 대용량 트래픽 처리 필요 | 실시간 애플리케이션: WebSocket, Server-Sent Events 사용 | 마이크로서비스: Spring Cloud Gateway와 함께 사용 | IoT 애플리케이션: 많은 동시 연결 처리 | 리소스 제약: 제한된 메모리와 CPU 환경 | . Tomcat을 선택해야 하는 경우: . | 기존 Spring MVC: 이미 Servlet 기반 애플리케이션 | 블로킹 작업: 많은 블로킹 I/O 작업 | 팀 역량: Netty 학습 곡선이 높음 | 안정성: 검증된 Servlet 컨테이너 | 서드파티 라이브러리: 블로킹 라이브러리 의존성 | . 9. 마이그레이션 전략 . Tomcat에서 Netty로 전환: . | 점진적 전환: 새로운 기능은 WebFlux + Netty로 구현 | 하이브리드 접근: 기존 MVC는 Tomcat, 새로운 API는 Netty | 성능 테스트: 각 단계에서 성능 측정 | 팀 교육: Netty와 리액티브 프로그래밍 학습 | . // 하이브리드 설정 예제 @Configuration public class HybridConfig { @Bean @ConditionalOnProperty(name = \"server.type\", havingValue = \"tomcat\") public TomcatServletWebServerFactory tomcatFactory() { return new TomcatServletWebServerFactory(); } @Bean @ConditionalOnProperty(name = \"server.type\", havingValue = \"netty\") public NettyReactiveWebServerFactory nettyFactory() { return new NettyReactiveWebServerFactory(); } } . 10. 결론 . Netty는 현대적인 고성능 웹 애플리케이션에 최적화된 서버로, 이벤트 루프 모델을 통해 높은 동시성과 낮은 메모리 사용량을 제공합니다. Spring WebFlux와 함께 사용할 때 특히 강력한 조합을 만들어내며, 대용량 트래픽 처리와 실시간 애플리케이션에 이상적입니다. 하지만 모든 상황에서 Netty가 최선의 선택은 아니므로, 프로젝트의 요구사항, 팀의 기술 역량, 그리고 기존 인프라를 고려하여 신중하게 선택해야 합니다. ",
    "url": "/docs/spring/overview.html#netty-vs-tomcat-%EC%84%9C%EB%B2%84-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/spring/overview.html#netty-vs-tomcat-서버-비교"
  },"263": {
    "doc": "Spring WebFlux Overview",
    "title": "성능 특성",
    "content": "1. 성능의 의미 . | 실행 속도: 반응형과 논블로킹이 항상 애플리케이션을 더 빠르게 만들지는 않음 | 병렬 처리: WebClient로 원격 호출을 병렬로 실행하는 경우 등 일부 경우에만 속도 향상 | 처리 시간: 논블로킹 방식은 더 많은 작업이 필요하여 처리 시간이 약간 증가할 수 있음 | . 2. 주요 이점 . graph TB subgraph \"확장성 이점\" Threads[적은 수의 고정 스레드] Memory[적은 메모리 사용량] Predictable[예측 가능한 확장] Resilient[부하 하에서 견고함] end subgraph \"적용 조건\" Latency[지연 시간 필요] Network[느리고 예측 불가능한 네트워크 I/O] Mixed[혼합된 지연 시간] end Threads --&gt; Latency Memory --&gt; Network Predictable --&gt; Mixed Resilient --&gt; Latency . 3. 동시성 모델 . Spring MVC (Servlet 애플리케이션): . | 블로킹 가정: 애플리케이션이 현재 스레드를 블로킹할 수 있다고 가정 | 대용량 스레드 풀: 요청 처리 중 잠재적 블로킹을 흡수하기 위해 대용량 스레드 풀 사용 | . Spring WebFlux (논블로킹 서버): . | 논블로킹 가정: 애플리케이션이 블로킹하지 않는다고 가정 | 작은 고정 크기 스레드 풀: 이벤트 루프 워커를 사용하여 요청 처리 | 콜백 의존: 현재 스레드를 절대 블로킹하지 않고 콜백에 의존 | . 4. 블로킹 API 호출 . // Reactor와 RxJava의 publishOn 연산자 사용 Flux&lt;String&gt; result = blockingApiCall() .publishOn(Schedulers.elastic()) // 다른 스레드에서 처리 .map(data -&gt; processData(data)); . | publishOn 연산자: 다른 스레드에서 처리 계속 | 쉬운 탈출구: 블로킹 라이브러리 사용 시 쉬운 해결책 제공 | 적합하지 않음: 블로킹 API는 이 동시성 모델에 적합하지 않음 | . ",
    "url": "/docs/spring/overview.html#%EC%84%B1%EB%8A%A5-%ED%8A%B9%EC%84%B1",
    
    "relUrl": "/docs/spring/overview.html#성능-특성"
  },"264": {
    "doc": "Spring WebFlux Overview",
    "title": "스레딩 모델",
    "content": "1. 예상되는 스레드 . “바닐라” Spring WebFlux 서버: . | 서버 스레드: 1개 | 요청 처리 스레드: CPU 코어 수만큼 (일반적으로) | . Servlet 컨테이너: . | 더 많은 스레드: Tomcat의 경우 10개 등 | Servlet 블로킹 I/O: 지원 | Servlet 3.1 논블로킹 I/O: 지원 | . 2. WebClient 스레딩 . graph TB subgraph \"WebClient 이벤트 루프\" EventLoop[이벤트 루프 스타일] ProcessingThreads[작은 고정 수의 처리 스레드] ReactorNetty[reactor-http-nio- 스레드] end subgraph \"공유 리소스\" ClientServer[클라이언트와 서버 공유] EventLoopResources[이벤트 루프 리소스 공유] end EventLoop --&gt; ProcessingThreads ProcessingThreads --&gt; ReactorNetty ClientServer --&gt; EventLoopResources . 3. 스케줄러 . | parallel: CPU 바운드 작업용 제한된 스레드 수 | elastic: I/O 바운드 작업용 대용량 스레드 수 | 특정 스레드 풀 전략: 스케줄러 이름으로 특정 동시성 전략 제안 | . 4. 가변 상태 . // Reactor와 RxJava에서 연산자를 통해 로직 선언 // 런타임에 리액티브 파이프라인 형성 // 애플리케이션 코드는 동시에 호출되지 않음 Flux&lt;String&gt; pipeline = source .map(data -&gt; process(data)) .filter(data -&gt; validate(data)) .doOnNext(data -&gt; log(data)); . | 순차적 처리: 데이터가 순차적으로, 구별된 단계에서 처리 | 가변 상태 보호 불필요: 파이프라인 내 애플리케이션 코드는 동시에 호출되지 않음 | . ",
    "url": "/docs/spring/overview.html#%EC%8A%A4%EB%A0%88%EB%94%A9-%EB%AA%A8%EB%8D%B8",
    
    "relUrl": "/docs/spring/overview.html#스레딩-모델"
  },"265": {
    "doc": "Spring WebFlux Overview",
    "title": "설정",
    "content": "1. 서버 설정 . | Spring Framework: 서버 시작/중지 지원 없음 | 서버별 설정 API: 서버별 설정 API 사용 필요 | Spring Boot: 각 서버의 Spring Boot 설정 옵션 확인 | . 2. WebClient 설정 . @Configuration public class WebClientConfig { @Bean public WebClient webClient() { return WebClient.builder() .baseUrl(\"https://api.example.com\") .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .build(); } } . 3. 기타 라이브러리 . | 데이터 액세스 라이브러리: 자체 스레드 생성 및 사용 | 서드파티 의존성: 각각의 문서 참조 | . ",
    "url": "/docs/spring/overview.html#%EC%84%A4%EC%A0%95",
    
    "relUrl": "/docs/spring/overview.html#설정"
  },"266": {
    "doc": "Spring WebFlux Overview",
    "title": "결론",
    "content": "Spring WebFlux는 현대적인 웹 애플리케이션에서 높은 성능과 확장성을 요구하는 시스템에 적합한 프레임워크입니다. 특히 다음과 같은 상황에서 큰 장점을 보입니다: . 적합한 사용 사례: . | 대용량 트래픽 처리: 이벤트 루프 모델로 높은 동시성 지원 | 실시간 데이터 스트리밍: Server-Sent Events, WebSocket 지원 | 마이크로서비스 게이트웨이: Spring Cloud Gateway의 기반 | IoT 데이터 처리: 센서 데이터의 실시간 처리 | 실시간 채팅 시스템: WebSocket을 통한 양방향 통신 | 고성능 API 서버: 대용량 트래픽을 처리하는 REST API | . 기술 선택 가이드: . WebFlux를 선택해야 하는 경우: . | 높은 동시성 요구: 초당 수만 개의 요청을 처리해야 하는 경우 | 실시간 데이터 처리: 실시간 스트리밍이나 이벤트 기반 아키텍처 | 마이크로서비스 환경: Spring Cloud Gateway와 함께 사용 | 메모리 효율성: 제한된 리소스 환경에서 최대 성능 필요 | . Spring MVC를 선택해야 하는 경우: . | 기존 코드베이스: 이미 동기식 코드로 구성된 프로젝트 | 간단한 CRUD 애플리케이션: 복잡한 비동기 처리가 필요 없는 경우 | 팀 역량: 리액티브 프로그래밍 경험이 부족한 팀 | 서드파티 라이브러리 의존성: 블로킹 라이브러리를 많이 사용하는 경우 | . 성능 고려사항: . graph TB subgraph \"성능 비교\" MVC[Spring MVC&lt;br/&gt;Thread-per-request] WebFlux[WebFlux&lt;br/&gt;Event Loop] end subgraph \"메모리 사용량\" MVCMemory[높음&lt;br/&gt;스레드당 ~1MB] WebFluxMemory[낮음&lt;br/&gt;이벤트 루프] end subgraph \"동시성\" MVCConcurrency[제한적&lt;br/&gt;스레드 풀 크기] WebFluxConcurrency[높음&lt;br/&gt;이벤트 루프] end MVC --&gt; MVCMemory WebFlux --&gt; WebFluxMemory MVC --&gt; MVCConcurrency WebFlux --&gt; WebFluxConcurrency . 학습 로드맵: . | 기초 단계: Reactive Streams 스펙 이해, Mono와 Flux 개념 학습 | 중급 단계: WebFlux 컨트롤러 구현, WebClient 사용법, 백프레셔 처리 | 고급 단계: 복잡한 리액티브 스트림 조합, 성능 최적화 및 모니터링 | . 마이그레이션 전략: . 기존 Spring MVC 애플리케이션을 WebFlux로 마이그레이션할 때는 점진적 접근이 권장됩니다: . | 하이브리드 접근: MVC와 WebFlux를 함께 사용 | 새로운 기능: 새로운 기능은 WebFlux로 구현 | 점진적 전환: 기존 코드를 단계적으로 리팩토링 | 성능 테스트: 각 단계에서 성능 측정 및 검증 | . WebFlux의 학습 곡선이 높고, 모든 상황에서 적합하지 않을 수 있으므로, 프로젝트의 요구사항을 잘 분석하여 적절한 기술을 선택하는 것이 중요합니다. 특히 팀의 기술 역량과 프로젝트의 복잡성을 고려한 신중한 결정이 필요합니다. ",
    "url": "/docs/spring/overview.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/spring/overview.html#결론"
  },"267": {
    "doc": "Pod",
    "title": "Pod 개요",
    "content": "Pod는 Kubernetes에서 가장 작은 배포 가능한 컴퓨팅 단위입니다. Pod는 하나 이상의 컨테이너를 포함할 수 있으며, 이러한 컨테이너들은 네트워크와 스토리지를 공유합니다. Pod의 특징 . | 최소 배포 단위: Kubernetes에서 관리하는 가장 작은 단위 | 컨테이너 그룹: 하나 이상의 컨테이너를 포함 | 공유 리소스: 네트워크, 스토리지, IPC 공유 | 수명 주기: 생성, 실행, 종료의 생명주기를 가짐 | . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-개요"
  },"268": {
    "doc": "Pod",
    "title": "Pod 구조",
    "content": "graph TD A[Pod] --&gt; B[Container 1] A --&gt; C[Container 2] A --&gt; D[Container 3] A --&gt; E[Shared Network] A --&gt; F[Shared Storage] A --&gt; G[Shared IPC] B --&gt; H[Process 1] C --&gt; I[Process 2] D --&gt; J[Process 3] style A fill:#e3f2fd style B fill:#f3e5f5 style C fill:#f3e5f5 style D fill:#f3e5f5 style E fill:#e8f5e8 style F fill:#e8f5e8 style G fill:#e8f5e8 . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-구조"
  },"269": {
    "doc": "Pod",
    "title": "Pod 예시",
    "content": "단일 컨테이너 Pod . apiVersion: v1 kind: Pod metadata: name: nginx-pod labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 resources: requests: memory: \"64Mi\" cpu: \"250m\" limits: memory: \"128Mi\" cpu: \"500m\" . 다중 컨테이너 Pod (Sidecar 패턴) . apiVersion: v1 kind: Pod metadata: name: web-app labels: app: web spec: containers: - name: web image: nginx:1.14.2 ports: - containerPort: 80 volumeMounts: - name: shared-data mountPath: /usr/share/nginx/html - name: log-collector image: busybox command: [ \"sh\", \"-c\", 'while true; do echo \"$(date) - Log entry\" &gt;&gt; /logs/app.log; sleep 10; done', ] volumeMounts: - name: shared-data mountPath: /logs volumes: - name: shared-data emptyDir: {} . Init Container가 있는 Pod . apiVersion: v1 kind: Pod metadata: name: init-demo spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 volumeMounts: - name: workdir mountPath: /usr/share/nginx/html initContainers: - name: init-myservice image: busybox command: [ \"sh\", \"-c\", \"until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done\", ] - name: init-mydb image: busybox command: [ \"sh\", \"-c\", \"until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done\", ] volumes: - name: workdir emptyDir: {} . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-예시"
  },"270": {
    "doc": "Pod",
    "title": "Pod 생명주기",
    "content": "graph LR A[Pending] --&gt; B[Running] B --&gt; C[Succeeded] B --&gt; D[Failed] B --&gt; E[Unknown] style A fill:#fff3e0 style B fill:#e8f5e8 style C fill:#e3f2fd style D fill:#ffebee style E fill:#f3e5f5 . Pod 상태 설명 . | 상태 | 설명 | . | Pending | Pod가 Kubernetes 시스템에 수락되었지만, 하나 이상의 컨테이너가 설정되지 않았거나 실행되지 않음 | . | Running | Pod가 노드에 바인딩되었고, 모든 컨테이너가 생성되었으며, 최소 하나의 컨테이너가 실행 중이거나 시작/재시작 중 | . | Succeeded | Pod의 모든 컨테이너가 성공적으로 종료되었고 재시작되지 않음 | . | Failed | Pod의 모든 컨테이너가 종료되었고, 최소 하나의 컨테이너가 실패로 종료됨 | . | Unknown | Pod의 상태를 확인할 수 없음 | . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-생명주기"
  },"271": {
    "doc": "Pod",
    "title": "Pod 네트워킹",
    "content": "Pod 네트워크 모델 . graph TD A[Pod] --&gt; B[Container Network Namespace] B --&gt; C[eth0 - Pod IP] B --&gt; D[lo - localhost] E[Node Network] --&gt; F[Node IP] G[Service Network] --&gt; H[Service IP] style A fill:#e3f2fd style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#e8f5e8 . Pod 간 통신 . apiVersion: v1 kind: Pod metadata: name: pod-1 labels: app: frontend spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 --- apiVersion: v1 kind: Pod metadata: name: pod-2 labels: app: backend spec: containers: - name: app image: myapp:1.0 ports: - containerPort: 8080 . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-네트워킹"
  },"272": {
    "doc": "Pod",
    "title": "Pod 스토리지",
    "content": "볼륨 마운트 예시 . apiVersion: v1 kind: Pod metadata: name: storage-pod spec: containers: - name: app image: nginx:1.14.2 volumeMounts: - name: config-volume mountPath: /etc/nginx/conf.d - name: data-volume mountPath: /var/www/html - name: secret-volume mountPath: /etc/secrets readOnly: true volumes: - name: config-volume configMap: name: nginx-config - name: data-volume persistentVolumeClaim: claimName: data-pvc - name: secret-volume secret: secretName: app-secret . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-스토리지"
  },"273": {
    "doc": "Pod",
    "title": "Pod 리소스 관리",
    "content": "리소스 요청과 제한 . apiVersion: v1 kind: Pod metadata: name: resource-pod spec: containers: - name: app image: nginx:1.14.2 resources: requests: memory: \"64Mi\" cpu: \"250m\" ephemeral-storage: \"2Gi\" limits: memory: \"128Mi\" cpu: \"500m\" ephemeral-storage: \"4Gi\" ports: - containerPort: 80 . QoS 클래스 . | QoS 클래스 | 조건 | 설명 | . | Guaranteed | requests = limits (모든 리소스) | 가장 높은 우선순위 | . | Burstable | requests &lt; limits | 중간 우선순위 | . | BestEffort | requests와 limits 모두 설정 안함 | 가장 낮은 우선순위 | . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EA%B4%80%EB%A6%AC",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-리소스-관리"
  },"274": {
    "doc": "Pod",
    "title": "Pod 관리 명령어",
    "content": "# Pod 생성 kubectl apply -f pod.yaml # Pod 목록 확인 kubectl get pods kubectl get pods -o wide # Pod 상세 정보 확인 kubectl describe pod &lt;pod-name&gt; # Pod 로그 확인 kubectl logs &lt;pod-name&gt; kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt; # Pod에 접속 kubectl exec -it &lt;pod-name&gt; -- /bin/bash kubectl exec -it &lt;pod-name&gt; -c &lt;container-name&gt; -- /bin/bash # Pod 삭제 kubectl delete pod &lt;pod-name&gt; # Pod 복사 kubectl cp &lt;pod-name&gt;:/path/to/file /local/path . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-관리-명령어"
  },"275": {
    "doc": "Pod",
    "title": "Pod 보안",
    "content": "Security Context 예시 . apiVersion: v1 kind: Pod metadata: name: security-pod spec: securityContext: runAsUser: 1000 runAsGroup: 3000 fsGroup: 2000 containers: - name: app image: nginx:1.14.2 securityContext: allowPrivilegeEscalation: false readOnlyRootFilesystem: true runAsNonRoot: true capabilities: drop: - ALL volumeMounts: - name: tmp mountPath: /tmp volumes: - name: tmp emptyDir: {} . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EB%B3%B4%EC%95%88",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-보안"
  },"276": {
    "doc": "Pod",
    "title": "Pod 디버깅",
    "content": "일반적인 Pod 문제 해결 . | Pod가 Pending 상태인 경우 . kubectl describe pod &lt;pod-name&gt; kubectl get events --sort-by='.lastTimestamp' . | Pod가 Running이지만 애플리케이션이 응답하지 않는 경우 . kubectl logs &lt;pod-name&gt; kubectl exec -it &lt;pod-name&gt; -- /bin/bash . | Pod가 계속 재시작되는 경우 . kubectl logs &lt;pod-name&gt; --previous kubectl describe pod &lt;pod-name&gt; . | . ",
    "url": "/docs/k8s/componentes/pod.html#pod-%EB%94%94%EB%B2%84%EA%B9%85",
    
    "relUrl": "/docs/k8s/componentes/pod.html#pod-디버깅"
  },"277": {
    "doc": "Pod",
    "title": "주의사항",
    "content": ". | Pod는 일시적: Pod는 재시작되면 새로운 IP를 받습니다 | 리소스 제한: 적절한 리소스 요청과 제한을 설정해야 합니다 | 보안: Security Context를 사용하여 보안을 강화해야 합니다 | 모니터링: Pod의 상태와 리소스 사용량을 지속적으로 모니터링해야 합니다 | . ",
    "url": "/docs/k8s/componentes/pod.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/pod.html#주의사항"
  },"278": {
    "doc": "Pod",
    "title": "Pod",
    "content": " ",
    "url": "/docs/k8s/componentes/pod.html",
    
    "relUrl": "/docs/k8s/componentes/pod.html"
  },"279": {
    "doc": "Docker Registry",
    "title": "What is Docker registry",
    "content": ". | Docker Registry는 컨테이너 이미지를 저장하고 배포하는 중앙 저장소입니다. 개발자는 이미지를 registry에 업로드(push)하고, 필요할 때 다운로드(pull)하여 컨테이너를 실행할 수 있습니다. | 이미지 버전 관리 및 공유 | CI/CD 파이프라인에서 이미지 배포 자동화에 필수 | 사설/공용 registry 모두 존재 | . | . ",
    "url": "/docs/all-container/registry.html#what-is-docker-registry",
    
    "relUrl": "/docs/all-container/registry.html#what-is-docker-registry"
  },"280": {
    "doc": "Docker Registry",
    "title": "Kind of docker registry",
    "content": ". | 공식 Docker Hub: hub.docker.com, 가장 널리 사용되는 공개 registry | Harbor: 오픈소스 기반의 엔터프라이즈용 프라이빗 registry, 보안/정책/감사 기능 강화 | Google Container Registry(GCR), Amazon ECR, GitHub Container Registry 등 다양한 클라우드 기반 registry | . ",
    "url": "/docs/all-container/registry.html#kind-of-docker-registry",
    
    "relUrl": "/docs/all-container/registry.html#kind-of-docker-registry"
  },"281": {
    "doc": "Docker Registry",
    "title": "Docker registry",
    "content": ". | Docker에서 기본적으로 사용하는 공개 registry(hub.docker.com) | 무료로 이미지 업로드/다운로드 가능(공개/비공개 저장소 지원) | 전 세계적으로 가장 많이 사용됨 | 인증, 자동 빌드, 웹 UI 제공 | . ",
    "url": "/docs/all-container/registry.html#docker-registry",
    
    "relUrl": "/docs/all-container/registry.html#docker-registry"
  },"282": {
    "doc": "Docker Registry",
    "title": "Harbor",
    "content": ". | CNCF에서 관리하는 오픈소스 프라이빗 registry | 엔터프라이즈 환경에 적합(사용자/권한 관리, 이미지 서명, 취약점 스캔, 감사 로그 등 지원) | 자체 서버에 설치하여 운영 가능 | LDAP, AD 등 외부 인증 연동 지원 | . ",
    "url": "/docs/all-container/registry.html#harbor",
    
    "relUrl": "/docs/all-container/registry.html#harbor"
  },"283": {
    "doc": "Docker Registry",
    "title": "Registry 비교",
    "content": "| 항목 | Docker Hub | Harbor | . | 공개/비공개 | 모두 지원 | 모두 지원 | . | 설치 방식 | 클라우드(공식) | 온프레미스(직접 설치) | . | 보안/정책 | 기본 제공 | 고급(정책, 감사, 서명) | . | 취약점 스캔 | 일부 제공 | 기본 제공 | . | 사용자/권한 관리 | 제한적 | 세분화/강력 | . | 외부 인증 | 제한적 | LDAP/AD 등 지원 | . | 커뮤니티/지원 | 매우 활발 | 활발 | . ",
    "url": "/docs/all-container/registry.html#registry-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/all-container/registry.html#registry-비교"
  },"284": {
    "doc": "Docker Registry",
    "title": "이미지 올리기(push)와 받기(pull)",
    "content": "이미지 push (업로드) . | Docker Hub/Harbor에 로그인 docker login [registry 주소] . | 이미지 태그 지정(예: myrepo/myimage:tag) docker tag [이미지명] [registry 주소]/[저장소]/[이미지명]:[태그] . | 이미지 push docker push [registry 주소]/[저장소]/[이미지명]:[태그] . | . 이미지 pull (다운로드) . docker pull [registry 주소]/[저장소]/[이미지명]:[태그] . | 공식 Docker Hub는 registry 주소 생략 가능(예: docker pull nginx:latest) | Harbor 등 사설 registry는 주소 명시 필요(예: docker pull harbor.example.com/myrepo/myimage:tag) | . ",
    "url": "/docs/all-container/registry.html#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%98%AC%EB%A6%AC%EA%B8%B0push%EC%99%80-%EB%B0%9B%EA%B8%B0pull",
    
    "relUrl": "/docs/all-container/registry.html#이미지-올리기push와-받기pull"
  },"285": {
    "doc": "Docker Registry",
    "title": "Docker Registry",
    "content": " ",
    "url": "/docs/all-container/registry.html",
    
    "relUrl": "/docs/all-container/registry.html"
  },"286": {
    "doc": "Role",
    "title": "Role 개요",
    "content": "Role은 Kubernetes에서 네임스페이스 범위의 권한을 정의하는 리소스입니다. 특정 네임스페이스 내에서 리소스에 대한 권한을 세밀하게 제어할 수 있으며, RBAC(Role-Based Access Control)의 핵심 구성 요소입니다. Role의 특징 . | 네임스페이스 범위: 특정 네임스페이스 내에서만 유효 | 세밀한 권한 제어: 리소스별, 동작별 권한 정의 | RBAC 기반: Role-Based Access Control 시스템의 일부 | 조합 가능: 여러 Role을 하나의 사용자에게 할당 가능 | . ",
    "url": "/docs/k8s/componentes/role.html#role-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-개요"
  },"287": {
    "doc": "Role",
    "title": "Role 구조",
    "content": "graph TD A[Role] --&gt; B[Rules] B --&gt; C[API Groups] B --&gt; D[Resources] B --&gt; E[Verbs] C --&gt; F[apps/v1] C --&gt; G[core/v1] C --&gt; H[networking.k8s.io/v1] D --&gt; I[Pods] D --&gt; J[Services] D --&gt; K[Deployments] E --&gt; L[get] E --&gt; M[list] E --&gt; N[create] E --&gt; O[update] E --&gt; P[delete] style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#e8f5e8 style E fill:#e8f5e8 . ",
    "url": "/docs/k8s/componentes/role.html#role-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-구조"
  },"288": {
    "doc": "Role",
    "title": "Role 예시",
    "content": "기본 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: pod-reader rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\", \"watch\"] . 복합 권한 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: production name: app-admin rules: # Pod 관리 권한 - apiGroups: [\"\"] resources: [\"pods\", \"pods/log\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # Service 관리 권한 - apiGroups: [\"\"] resources: [\"services\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # Deployment 관리 권한 - apiGroups: [\"apps\"] resources: [\"deployments\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # ConfigMap 관리 권한 - apiGroups: [\"\"] resources: [\"configmaps\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . 특정 리소스만 접근하는 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: monitoring name: metrics-reader rules: # Pod 메트릭 읽기 권한 - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\", \"watch\"] # Pod 로그 읽기 권한 - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] # ConfigMap 읽기 권한 (설정 파일용) - apiGroups: [\"\"] resources: [\"configmaps\"] verbs: [\"get\", \"list\", \"watch\"] . ",
    "url": "/docs/k8s/componentes/role.html#role-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-예시"
  },"289": {
    "doc": "Role",
    "title": "Role 타입",
    "content": "1. 읽기 전용 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: read-only rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\", \"secrets\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\"] verbs: [\"get\", \"list\", \"watch\"] . 2. 개발자 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: development name: developer rules: # Pod 관리 - apiGroups: [\"\"] resources: [\"pods\", \"pods/log\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # Service 관리 - apiGroups: [\"\"] resources: [\"services\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # Deployment 관리 - apiGroups: [\"apps\"] resources: [\"deployments\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # ConfigMap 관리 - apiGroups: [\"\"] resources: [\"configmaps\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # Secret 읽기 (민감한 정보는 읽기만) - apiGroups: [\"\"] resources: [\"secrets\"] verbs: [\"get\", \"list\", \"watch\"] . 3. 운영자 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: production name: operator rules: # 모든 리소스 관리 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\", \"secrets\", \"persistentvolumeclaims\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] - apiGroups: [\"networking.k8s.io\"] resources: [\"ingresses\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # 이벤트 읽기 - apiGroups: [\"\"] resources: [\"events\"] verbs: [\"get\", \"list\", \"watch\"] . ",
    "url": "/docs/k8s/componentes/role.html#role-%ED%83%80%EC%9E%85",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-타입"
  },"290": {
    "doc": "Role",
    "title": "Role과 RoleBinding 조합",
    "content": "RoleBinding 예시 . apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: default subjects: - kind: User name: jane apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: pod-reader apiGroup: rbac.authorization.k8s.io . 여러 Role을 하나의 사용자에게 할당 . # 첫 번째 Role apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: pod-reader rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\", \"watch\"] --- # 두 번째 Role apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: service-reader rules: - apiGroups: [\"\"] resources: [\"services\"] verbs: [\"get\", \"list\", \"watch\"] --- # 첫 번째 RoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: default subjects: - kind: User name: john apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: pod-reader apiGroup: rbac.authorization.k8s.io --- # 두 번째 RoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-services namespace: default subjects: - kind: User name: john apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: service-reader apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/role.html#role%EA%B3%BC-rolebinding-%EC%A1%B0%ED%95%A9",
    
    "relUrl": "/docs/k8s/componentes/role.html#role과-rolebinding-조합"
  },"291": {
    "doc": "Role",
    "title": "Role 관리 명령어",
    "content": "기본 명령어 . # Role 생성 kubectl apply -f role.yaml # Role 목록 확인 kubectl get roles kubectl get roles -n &lt;namespace&gt; # Role 상세 정보 확인 kubectl describe role &lt;role-name&gt; -n &lt;namespace&gt; # Role 삭제 kubectl delete role &lt;role-name&gt; -n &lt;namespace&gt; # Role YAML 확인 kubectl get role &lt;role-name&gt; -n &lt;namespace&gt; -o yaml . 권한 테스트 . # 사용자 권한 확인 kubectl auth can-i get pods --as=user@example.com -n default # 특정 동작 권한 확인 kubectl auth can-i create deployments --as=user@example.com -n default # 모든 권한 확인 kubectl auth can-i --list --as=user@example.com -n default . ",
    "url": "/docs/k8s/componentes/role.html#role-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-관리-명령어"
  },"292": {
    "doc": "Role",
    "title": "Role 사용 사례",
    "content": "1. 개발팀 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: development name: developer rules: # 애플리케이션 리소스 관리 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # 로그 읽기 - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] # 이벤트 읽기 - apiGroups: [\"\"] resources: [\"events\"] verbs: [\"get\", \"list\", \"watch\"] . 2. QA팀 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: testing name: qa-tester rules: # 테스트 환경 리소스 읽기 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\"] verbs: [\"get\", \"list\", \"watch\"] # 로그 읽기 - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] # 테스트용 Pod 생성/삭제 - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"create\", \"delete\"] . 3. 모니터링팀 Role . apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: monitoring name: monitoring rules: # 모든 리소스 읽기 - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"nodes\", \"events\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"apps\"] resources: [\"deployments\", \"replicasets\", \"statefulsets\"] verbs: [\"get\", \"list\", \"watch\"] # 메트릭 수집용 ConfigMap 관리 - apiGroups: [\"\"] resources: [\"configmaps\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] # Pod 로그 읽기 - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] . ",
    "url": "/docs/k8s/componentes/role.html#role-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-사용-사례"
  },"293": {
    "doc": "Role",
    "title": "Role vs ClusterRole",
    "content": "| 특징 | Role | ClusterRole | . | 범위 | 네임스페이스 | 클러스터 전체 | . | 네임스페이스 | 특정 네임스페이스 | 모든 네임스페이스 | . | 사용 사례 | 일반적인 권한 관리 | 클러스터 관리자 권한 | . | 바인딩 | RoleBinding | ClusterRoleBinding | . ",
    "url": "/docs/k8s/componentes/role.html#role-vs-clusterrole",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-vs-clusterrole"
  },"294": {
    "doc": "Role",
    "title": "Role 모범 사례",
    "content": "1. 최소 권한 원칙 . # 필요한 권한만 부여 apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: minimal-pod-reader rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\"] # watch 권한 제거 . 2. 명확한 네이밍 . # 역할을 명확히 하는 이름 사용 apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: production name: production-app-deployer # 명확한 역할 rules: - apiGroups: [\"apps\"] resources: [\"deployments\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\"] . 3. 리소스별 분리 . # Pod 관리 Role apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: pod-manager rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] --- # Service 관리 Role apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: service-manager rules: - apiGroups: [\"\"] resources: [\"services\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] . ",
    "url": "/docs/k8s/componentes/role.html#role-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/role.html#role-모범-사례"
  },"295": {
    "doc": "Role",
    "title": "주의사항",
    "content": ". | 최소 권한: 필요한 최소한의 권한만 부여해야 합니다 | 정기 검토: Role과 권한을 정기적으로 검토해야 합니다 | 네임스페이스 분리: 환경별로 네임스페이스를 분리하여 권한을 제한해야 합니다 | 테스트: 권한 설정 후 실제 테스트를 통해 검증해야 합니다 | 문서화: Role의 목적과 권한을 명확히 문서화해야 합니다 | . ",
    "url": "/docs/k8s/componentes/role.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/role.html#주의사항"
  },"296": {
    "doc": "Role",
    "title": "Role",
    "content": " ",
    "url": "/docs/k8s/componentes/role.html",
    
    "relUrl": "/docs/k8s/componentes/role.html"
  },"297": {
    "doc": "RoleBinding",
    "title": "RoleBinding 개요",
    "content": "RoleBinding은 Kubernetes에서 Role과 사용자/그룹/서비스 계정을 연결하는 리소스입니다. RBAC(Role-Based Access Control) 시스템에서 권한을 실제 주체에게 할당하는 역할을 합니다. RoleBinding의 특징 . | 권한 연결: Role과 주체(Subject)를 연결 | 네임스페이스 범위: 특정 네임스페이스 내에서만 유효 | 다중 주체: 하나의 Role을 여러 주체에게 할당 가능 | 동적 권한: Role 변경 시 바인딩된 모든 주체에게 자동 적용 | . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-개요"
  },"298": {
    "doc": "RoleBinding",
    "title": "RoleBinding 구조",
    "content": "graph TD A[RoleBinding] --&gt; B[Subjects] A --&gt; C[RoleRef] B --&gt; D[User] B --&gt; E[Group] B --&gt; F[ServiceAccount] C --&gt; G[Role] C --&gt; H[ClusterRole] D --&gt; I[user@example.com] E --&gt; J[developers] F --&gt; K[app-service-account] G --&gt; L[pod-reader] H --&gt; M[admin] style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#f3e5f5 style D fill:#e8f5e8 style E fill:#e8f5e8 style F fill:#e8f5e8 style G fill:#fff3e0 style H fill:#fff3e0 . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-구조"
  },"299": {
    "doc": "RoleBinding",
    "title": "RoleBinding 예시",
    "content": "기본 RoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-pods namespace: default subjects: - kind: User name: jane@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: pod-reader apiGroup: rbac.authorization.k8s.io . 다중 주체 RoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: app-admin namespace: production subjects: # 사용자 - kind: User name: admin@example.com apiGroup: rbac.authorization.k8s.io # 그룹 - kind: Group name: developers apiGroup: rbac.authorization.k8s.io # 서비스 계정 - kind: ServiceAccount name: app-service-account namespace: production roleRef: kind: Role name: app-admin apiGroup: rbac.authorization.k8s.io . ClusterRole을 사용하는 RoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: admin-binding namespace: default subjects: - kind: User name: cluster-admin@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: ClusterRole name: admin apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-예시"
  },"300": {
    "doc": "RoleBinding",
    "title": "RoleBinding 타입",
    "content": "1. 사용자 RoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: developer-binding namespace: development subjects: - kind: User name: developer@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: developer apiGroup: rbac.authorization.k8s.io . 2. 그룹 RoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: qa-team-binding namespace: testing subjects: - kind: Group name: qa-team apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: qa-tester apiGroup: rbac.authorization.k8s.io . 3. 서비스 계정 RoleBinding . apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: monitoring-binding namespace: monitoring subjects: - kind: ServiceAccount name: prometheus namespace: monitoring roleRef: kind: Role name: monitoring apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-%ED%83%80%EC%9E%85",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-타입"
  },"301": {
    "doc": "RoleBinding",
    "title": "RoleBinding 관리 명령어",
    "content": "기본 명령어 . # RoleBinding 생성 kubectl apply -f rolebinding.yaml # RoleBinding 목록 확인 kubectl get rolebindings kubectl get rolebindings -n &lt;namespace&gt; # RoleBinding 상세 정보 확인 kubectl describe rolebinding &lt;rolebinding-name&gt; -n &lt;namespace&gt; # RoleBinding 삭제 kubectl delete rolebinding &lt;rolebinding-name&gt; -n &lt;namespace&gt; # RoleBinding YAML 확인 kubectl get rolebinding &lt;rolebinding-name&gt; -n &lt;namespace&gt; -o yaml . 권한 확인 명령어 . # 사용자 권한 확인 kubectl auth can-i get pods --as=user@example.com -n default # 특정 동작 권한 확인 kubectl auth can-i create deployments --as=user@example.com -n default # 모든 권한 확인 kubectl auth can-i --list --as=user@example.com -n default # 서비스 계정 권한 확인 kubectl auth can-i get pods --as=system:serviceaccount:default:app-sa -n default . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-관리-명령어"
  },"302": {
    "doc": "RoleBinding",
    "title": "RoleBinding 사용 사례",
    "content": "1. 개발팀 권한 관리 . # 개발자 Role apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: development name: developer rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"configmaps\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] - apiGroups: [\"apps\"] resources: [\"deployments\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] --- # 개발팀 RoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: developer-binding namespace: development subjects: - kind: Group name: developers apiGroup: rbac.authorization.k8s.io - kind: User name: lead-developer@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: developer apiGroup: rbac.authorization.k8s.io . 2. 애플리케이션 서비스 계정 . # 애플리케이션 Role apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: production name: app-role rules: - apiGroups: [\"\"] resources: [\"configmaps\", \"secrets\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] --- # 서비스 계정 apiVersion: v1 kind: ServiceAccount metadata: name: app-service-account namespace: production --- # 애플리케이션 RoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: app-binding namespace: production subjects: - kind: ServiceAccount name: app-service-account namespace: production roleRef: kind: Role name: app-role apiGroup: rbac.authorization.k8s.io . 3. 모니터링 시스템 . # 모니터링 Role apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: monitoring name: monitoring-role rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\", \"nodes\"] verbs: [\"get\", \"list\", \"watch\"] - apiGroups: [\"\"] resources: [\"pods/log\"] verbs: [\"get\", \"list\"] - apiGroups: [\"\"] resources: [\"configmaps\"] verbs: [\"get\", \"list\", \"watch\", \"create\", \"update\", \"patch\", \"delete\"] --- # Prometheus 서비스 계정 apiVersion: v1 kind: ServiceAccount metadata: name: prometheus namespace: monitoring --- # 모니터링 RoleBinding apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: monitoring-binding namespace: monitoring subjects: - kind: ServiceAccount name: prometheus namespace: monitoring roleRef: kind: Role name: monitoring-role apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-사용-사례"
  },"303": {
    "doc": "RoleBinding",
    "title": "RoleBinding vs ClusterRoleBinding",
    "content": "| 특징 | RoleBinding | ClusterRoleBinding | . | 범위 | 네임스페이스 | 클러스터 전체 | . | Role 타입 | Role, ClusterRole | ClusterRole만 | . | 사용 사례 | 일반적인 권한 관리 | 클러스터 관리자 권한 | . | 네임스페이스 | 특정 네임스페이스 | 모든 네임스페이스 | . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-vs-clusterrolebinding",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-vs-clusterrolebinding"
  },"304": {
    "doc": "RoleBinding",
    "title": "RoleBinding 모범 사례",
    "content": "1. 명확한 네이밍 . # 역할과 주체를 명확히 하는 이름 사용 apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: developer-team-binding # 명확한 역할 namespace: development subjects: - kind: Group name: developers apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: developer apiGroup: rbac.authorization.k8s.io . 2. 최소 권한 원칙 . # 필요한 최소한의 권한만 부여 apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: read-only-binding namespace: production subjects: - kind: User name: auditor@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: read-only # 읽기 전용 권한만 apiGroup: rbac.authorization.k8s.io . 3. 환경별 분리 . # 개발 환경 apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: dev-team-binding namespace: development subjects: - kind: Group name: developers apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: developer apiGroup: rbac.authorization.k8s.io --- # 프로덕션 환경 apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: prod-admin-binding namespace: production subjects: - kind: User name: admin@example.com apiGroup: rbac.authorization.k8s.io roleRef: kind: Role name: production-admin apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/rolebinding.html#rolebinding-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#rolebinding-모범-사례"
  },"305": {
    "doc": "RoleBinding",
    "title": "주의사항",
    "content": ". | 최소 권한: 필요한 최소한의 권한만 부여해야 합니다 | 정기 검토: RoleBinding을 정기적으로 검토하고 정리해야 합니다 | 네임스페이스 분리: 환경별로 네임스페이스를 분리하여 권한을 제한해야 합니다 | 테스트: 권한 설정 후 실제 테스트를 통해 검증해야 합니다 | 문서화: RoleBinding의 목적과 권한을 명확히 문서화해야 합니다 | . ",
    "url": "/docs/k8s/componentes/rolebinding.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html#주의사항"
  },"306": {
    "doc": "RoleBinding",
    "title": "RoleBinding",
    "content": " ",
    "url": "/docs/k8s/componentes/rolebinding.html",
    
    "relUrl": "/docs/k8s/componentes/rolebinding.html"
  },"307": {
    "doc": "Rolling Update",
    "title": "Rolling Update 배포 전략",
    "content": "Rolling Update는 새로운 버전을 점진적으로 배포하여 서비스 중단을 최소화하는 배포 전략입니다. ",
    "url": "/docs/deploy/rolling-update.html#rolling-update-%EB%B0%B0%ED%8F%AC-%EC%A0%84%EB%9E%B5",
    
    "relUrl": "/docs/deploy/rolling-update.html#rolling-update-배포-전략"
  },"308": {
    "doc": "Rolling Update",
    "title": "개요",
    "content": "Rolling Update는 기존 파드들을 하나씩 새로운 버전으로 교체하는 방식입니다. 이 과정에서 항상 일정 수의 파드가 서비스를 제공하므로 무중단 배포가 가능합니다. ",
    "url": "/docs/deploy/rolling-update.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/deploy/rolling-update.html#개요"
  },"309": {
    "doc": "Rolling Update",
    "title": "작동 원리",
    "content": "graph TB subgraph \"Step 1: 초기 상태\" A1[\"Pod v1.0&lt;br/&gt;🟢\"] --&gt; S1[\"Service&lt;br/&gt;🌐\"] A2[\"Pod v1.0&lt;br/&gt;🟢\"] --&gt; S1 A3[\"Pod v1.0&lt;br/&gt;🟢\"] --&gt; S1 end subgraph \"Step 2: 첫 번째 교체\" B1[\"Pod v1.0&lt;br/&gt;🟢\"] --&gt; S2[\"Service&lt;br/&gt;🌐\"] B2[\"Pod v1.0&lt;br/&gt;🟢\"] --&gt; S2 B3[\"Pod v2.0&lt;br/&gt;🔵\"] --&gt; S2 end subgraph \"Step 3: 두 번째 교체\" C1[\"Pod v1.0&lt;br/&gt;🟢\"] --&gt; S3[\"Service&lt;br/&gt;🌐\"] C2[\"Pod v2.0&lt;br/&gt;🔵\"] --&gt; S3 C3[\"Pod v2.0&lt;br/&gt;🔵\"] --&gt; S3 end subgraph \"Step 4: 완료\" D1[\"Pod v2.0&lt;br/&gt;🔵\"] --&gt; S4[\"Service&lt;br/&gt;🌐\"] D2[\"Pod v2.0&lt;br/&gt;🔵\"] --&gt; S4 D3[\"Pod v2.0&lt;br/&gt;🔵\"] --&gt; S4 end Step1 --&gt; Step2 --&gt; Step3 --&gt; Step4 style A1 fill:#90EE90 style A2 fill:#90EE90 style A3 fill:#90EE90 style B1 fill:#90EE90 style B2 fill:#90EE90 style B3 fill:#87CEEB style C1 fill:#90EE90 style C2 fill:#87CEEB style C3 fill:#87CEEB style D1 fill:#87CEEB style D2 fill:#87CEEB style D3 fill:#87CEEB . ",
    "url": "/docs/deploy/rolling-update.html#%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC",
    
    "relUrl": "/docs/deploy/rolling-update.html#작동-원리"
  },"310": {
    "doc": "Rolling Update",
    "title": "장점",
    "content": ". | 무중단 배포: 서비스 중단 없이 업데이트 가능 | 점진적 배포: 한 번에 모든 인스턴스를 교체하지 않음 | 자동 롤백: 문제 발생 시 이전 버전으로 자동 복구 | 리소스 효율성: 추가 인프라 없이 배포 가능 | . ",
    "url": "/docs/deploy/rolling-update.html#%EC%9E%A5%EC%A0%90",
    
    "relUrl": "/docs/deploy/rolling-update.html#장점"
  },"311": {
    "doc": "Rolling Update",
    "title": "단점",
    "content": ". | 배포 시간: 점진적 배포로 인한 긴 배포 시간 | 버전 혼재: 배포 중에는 여러 버전이 동시에 실행 | 데이터베이스 호환성: 스키마 변경 시 주의 필요 | . ",
    "url": "/docs/deploy/rolling-update.html#%EB%8B%A8%EC%A0%90",
    
    "relUrl": "/docs/deploy/rolling-update.html#단점"
  },"312": {
    "doc": "Rolling Update",
    "title": "Kubernetes에서의 구현",
    "content": "Deployment 설정 . apiVersion: apps/v1 kind: Deployment metadata: name: my-app spec: replicas: 3 strategy: type: RollingUpdate rollingUpdate: maxSurge: 1 # 최대 추가 파드 수 maxUnavailable: 1 # 최대 사용 불가 파드 수 selector: matchLabels: app: my-app template: metadata: labels: app: my-app spec: containers: - name: my-app image: my-app:v1.0 . 배포 명령어 . # 이미지 업데이트로 Rolling Update 시작 kubectl set image deployment/my-app my-app=my-app:v2.0 # 배포 상태 확인 kubectl rollout status deployment/my-app # 배포 진행 상황 모니터링 kubectl get pods -l app=my-app -w # 배포 일시정지 kubectl rollout pause deployment/my-app # 배포 재개 kubectl rollout resume deployment/my-app # 롤백 kubectl rollout undo deployment/my-app . ",
    "url": "/docs/deploy/rolling-update.html#kubernetes%EC%97%90%EC%84%9C%EC%9D%98-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/deploy/rolling-update.html#kubernetes에서의-구현"
  },"313": {
    "doc": "Rolling Update",
    "title": "배포 과정 상세",
    "content": "stateDiagram-v2 [*] --&gt; Initial Initial --&gt; Step1: kubectl set image Step1 --&gt; Step2: Pod v2.0 생성 Step2 --&gt; Step3: Pod v1.0 삭제 Step3 --&gt; Step4: Pod v2.0 생성 Step4 --&gt; Step5: Pod v1.0 삭제 Step5 --&gt; Step6: Pod v2.0 생성 Step6 --&gt; Complete: Pod v1.0 삭제 Complete --&gt; [*] note right of Step1: 3개 Pod v1.0 실행 중 note right of Step2: 3개 v1.0 + 1개 v2.0 note right of Step3: 2개 v1.0 + 1개 v2.0 note right of Step4: 2개 v1.0 + 2개 v2.0 note right of Step5: 1개 v1.0 + 2개 v2.0 note right of Step6: 1개 v1.0 + 3개 v2.0 note right of Complete: 3개 Pod v2.0 실행 중 . ",
    "url": "/docs/deploy/rolling-update.html#%EB%B0%B0%ED%8F%AC-%EA%B3%BC%EC%A0%95-%EC%83%81%EC%84%B8",
    
    "relUrl": "/docs/deploy/rolling-update.html#배포-과정-상세"
  },"314": {
    "doc": "Rolling Update",
    "title": "설정 옵션",
    "content": "maxSurge . | 배포 중 생성할 수 있는 최대 추가 파드 수 | 기본값: 25% (최소 1개) | . maxUnavailable . | 배포 중 사용 불가능한 최대 파드 수 | 기본값: 25% (최소 1개) | . strategy: type: RollingUpdate rollingUpdate: maxSurge: 2 # 최대 2개 추가 파드 허용 maxUnavailable: 0 # 사용 불가 파드 없음 (100% 가용성) . ",
    "url": "/docs/deploy/rolling-update.html#%EC%84%A4%EC%A0%95-%EC%98%B5%EC%85%98",
    
    "relUrl": "/docs/deploy/rolling-update.html#설정-옵션"
  },"315": {
    "doc": "Rolling Update",
    "title": "모니터링 및 디버깅",
    "content": "# 배포 상태 확인 kubectl rollout status deployment/my-app # 배포 히스토리 kubectl rollout history deployment/my-app # ReplicaSet 확인 kubectl get rs -l app=my-app # 파드 상태 확인 kubectl get pods -l app=my-app # 이벤트 확인 kubectl get events --sort-by='.lastTimestamp' . ",
    "url": "/docs/deploy/rolling-update.html#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%B0%8F-%EB%94%94%EB%B2%84%EA%B9%85",
    
    "relUrl": "/docs/deploy/rolling-update.html#모니터링-및-디버깅"
  },"316": {
    "doc": "Rolling Update",
    "title": "베스트 프랙티스",
    "content": ". | 적절한 replica 수: 최소 2개 이상의 replica 유지 | Health Check: Readiness/Liveness Probe 설정 | 점진적 배포: maxSurge와 maxUnavailable 조정 | 모니터링: 배포 후 메트릭과 로그 확인 | 롤백 준비: 문제 발생 시 빠른 롤백 계획 | . ",
    "url": "/docs/deploy/rolling-update.html#%EB%B2%A0%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%9E%99%ED%8B%B0%EC%8A%A4",
    
    "relUrl": "/docs/deploy/rolling-update.html#베스트-프랙티스"
  },"317": {
    "doc": "Rolling Update",
    "title": "사용 시나리오",
    "content": ". | ✅ 웹 애플리케이션: 무중단 서비스가 중요한 경우 | ✅ API 서비스: 지속적인 가용성이 필요한 경우 | ✅ 마이크로서비스: 각 서비스의 독립적 배포 | ✅ 개발/스테이징 환경: 안전한 배포 테스트 | . Rolling Update는 Kubernetes의 기본 배포 전략으로, 대부분의 애플리케이션에 적합한 안전하고 효율적인 배포 방식을 제공합니다. ",
    "url": "/docs/deploy/rolling-update.html#%EC%82%AC%EC%9A%A9-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4",
    
    "relUrl": "/docs/deploy/rolling-update.html#사용-시나리오"
  },"318": {
    "doc": "Rolling Update",
    "title": "Rolling Update",
    "content": " ",
    "url": "/docs/deploy/rolling-update.html",
    
    "relUrl": "/docs/deploy/rolling-update.html"
  },"319": {
    "doc": "Service",
    "title": "Service 개요",
    "content": "Service는 Kubernetes에서 Pod 집합에 대한 네트워크 엔드포인트를 제공하는 리소스입니다. Pod의 IP는 일시적이므로, Service를 통해 안정적인 네트워크 접근을 제공합니다. Service의 특징 . | 안정적인 엔드포인트: Pod가 재시작되어도 동일한 IP와 포트로 접근 가능 | 로드 밸런싱: 여러 Pod에 트래픽을 분산 | 서비스 디스커버리: DNS를 통한 자동 서비스 발견 | 다양한 타입: ClusterIP, NodePort, LoadBalancer, ExternalName | . ",
    "url": "/docs/k8s/componentes/service.html#service-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-개요"
  },"320": {
    "doc": "Service",
    "title": "Service 구조",
    "content": "graph TD A[Client] --&gt; B[Service] B --&gt; C[Pod 1] B --&gt; D[Pod 2] B --&gt; E[Pod 3] F[External Client] --&gt; G[LoadBalancer] G --&gt; H[NodePort] H --&gt; I[ClusterIP] I --&gt; C I --&gt; D I --&gt; E style A fill:#e3f2fd style B fill:#e1f5fe style C fill:#f3e5f5 style D fill:#f3e5f5 style E fill:#f3e5f5 style F fill:#e3f2fd style G fill:#fff3e0 style H fill:#fff3e0 style I fill:#e1f5fe . ",
    "url": "/docs/k8s/componentes/service.html#service-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-구조"
  },"321": {
    "doc": "Service",
    "title": "Service 타입",
    "content": "1. ClusterIP (기본값) . apiVersion: v1 kind: Service metadata: name: my-service labels: app: myapp spec: type: ClusterIP ports: - port: 80 # Service 포트 targetPort: 8080 # Pod 포트 protocol: TCP name: http - port: 443 targetPort: 8443 protocol: TCP name: https selector: app: myapp . 2. NodePort . apiVersion: v1 kind: Service metadata: name: my-nodeport-service spec: type: NodePort ports: - port: 80 targetPort: 8080 nodePort: 30080 # 노드 포트 (30000-32767) protocol: TCP name: http selector: app: myapp . 3. LoadBalancer . apiVersion: v1 kind: Service metadata: name: my-loadbalancer-service spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 protocol: TCP name: http selector: app: myapp externalTrafficPolicy: Local # 노드 로컬 트래픽 정책 . 4. ExternalName . apiVersion: v1 kind: Service metadata: name: my-external-service spec: type: ExternalName externalName: api.example.com ports: - port: 80 protocol: TCP name: http . ",
    "url": "/docs/k8s/componentes/service.html#service-%ED%83%80%EC%9E%85",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-타입"
  },"322": {
    "doc": "Service",
    "title": "Service 네트워킹",
    "content": "Service IP 할당 . graph TD A[Service] --&gt; B[ClusterIP: 10.96.1.100] B --&gt; C[Endpoints] C --&gt; D[Pod 1: 172.16.1.10:8080] C --&gt; E[Pod 2: 172.16.1.11:8080] C --&gt; F[Pod 3: 172.16.1.12:8080] G[DNS Resolution] --&gt; H[my-service.default.svc.cluster.local] H --&gt; B style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#e8f5e8 style D fill:#fff3e0 style E fill:#fff3e0 style F fill:#fff3e0 style G fill:#e3f2fd style H fill:#e3f2fd . DNS 서비스 디스커버리 . # Service DNS 이름 형식 &lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt; # 예시 my-service.default.svc.cluster.local web-app.production.svc.cluster.local . ",
    "url": "/docs/k8s/componentes/service.html#service-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-네트워킹"
  },"323": {
    "doc": "Service",
    "title": "Service 예시",
    "content": "기본 웹 서비스 . apiVersion: v1 kind: Service metadata: name: web-service labels: app: web spec: ports: - port: 80 targetPort: 8080 protocol: TCP name: http selector: app: web . 다중 포트 서비스 . apiVersion: v1 kind: Service metadata: name: multi-port-service spec: ports: - name: http port: 80 targetPort: 8080 protocol: TCP - name: https port: 443 targetPort: 8443 protocol: TCP - name: metrics port: 9090 targetPort: 9090 protocol: TCP selector: app: myapp . 세션 어피니티가 있는 서비스 . apiVersion: v1 kind: Service metadata: name: session-service spec: ports: - port: 80 targetPort: 8080 protocol: TCP selector: app: session-app sessionAffinity: ClientIP sessionAffinityConfig: clientIP: timeoutSeconds: 3600 . ",
    "url": "/docs/k8s/componentes/service.html#service-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-예시"
  },"324": {
    "doc": "Service",
    "title": "Endpoints",
    "content": "자동 생성되는 Endpoints . apiVersion: v1 kind: Endpoints metadata: name: my-service subsets: - addresses: - ip: 172.16.1.10 nodeName: node-1 - ip: 172.16.1.11 nodeName: node-2 - ip: 172.16.1.12 nodeName: node-3 ports: - port: 8080 protocol: TCP . 수동 Endpoints . apiVersion: v1 kind: Service metadata: name: external-service spec: ports: - port: 80 protocol: TCP --- apiVersion: v1 kind: Endpoints metadata: name: external-service subsets: - addresses: - ip: 192.168.1.100 ports: - port: 80 protocol: TCP . ",
    "url": "/docs/k8s/componentes/service.html#endpoints",
    
    "relUrl": "/docs/k8s/componentes/service.html#endpoints"
  },"325": {
    "doc": "Service",
    "title": "Service 관리 명령어",
    "content": "기본 명령어 . # Service 생성 kubectl apply -f service.yaml # Service 목록 확인 kubectl get services kubectl get svc # Service 상세 정보 확인 kubectl describe service &lt;service-name&gt; # Service 삭제 kubectl delete service &lt;service-name&gt; # Service IP 확인 kubectl get service &lt;service-name&gt; -o wide . 디버깅 명령어 . # Endpoints 확인 kubectl get endpoints &lt;service-name&gt; # Service DNS 확인 kubectl run test-dns --image=busybox --rm -it --restart=Never -- nslookup &lt;service-name&gt; # Service 연결 테스트 kubectl run test-connection --image=busybox --rm -it --restart=Never -- wget -O- &lt;service-name&gt;:&lt;port&gt; # Service 로그 확인 kubectl logs -l app=&lt;app-label&gt; . ",
    "url": "/docs/k8s/componentes/service.html#service-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-관리-명령어"
  },"326": {
    "doc": "Service",
    "title": "Service 사용 사례",
    "content": "1. 웹 애플리케이션 . apiVersion: v1 kind: Service metadata: name: web-app-service labels: app: web-app spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 protocol: TCP name: http - port: 443 targetPort: 8443 protocol: TCP name: https selector: app: web-app sessionAffinity: ClientIP . 2. 데이터베이스 서비스 . apiVersion: v1 kind: Service metadata: name: database-service spec: type: ClusterIP ports: - port: 5432 targetPort: 5432 protocol: TCP name: postgresql selector: app: database sessionAffinity: None . 3. API 서비스 . apiVersion: v1 kind: Service metadata: name: api-service annotations: service.beta.kubernetes.io/aws-load-balancer-type: \"nlb\" spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 protocol: TCP name: http - port: 443 targetPort: 8443 protocol: TCP name: https selector: app: api externalTrafficPolicy: Local . ",
    "url": "/docs/k8s/componentes/service.html#service-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-사용-사례"
  },"327": {
    "doc": "Service",
    "title": "Service 네트워크 정책",
    "content": "NetworkPolicy 예시 . apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: api-network-policy spec: podSelector: matchLabels: app: api policyTypes: - Ingress - Egress ingress: - from: - podSelector: matchLabels: app: web ports: - protocol: TCP port: 8080 egress: - to: - podSelector: matchLabels: app: database ports: - protocol: TCP port: 5432 . ",
    "url": "/docs/k8s/componentes/service.html#service-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%A0%95%EC%B1%85",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-네트워크-정책"
  },"328": {
    "doc": "Service",
    "title": "Service 모니터링",
    "content": "헬스 체크 . apiVersion: v1 kind: Service metadata: name: health-check-service annotations: service.beta.kubernetes.io/aws-load-balancer-health-check-path: \"/health\" service.beta.kubernetes.io/aws-load-balancer-health-check-port: \"8080\" spec: type: LoadBalancer ports: - port: 80 targetPort: 8080 protocol: TCP selector: app: web . 메트릭 수집 . apiVersion: v1 kind: Service metadata: name: metrics-service spec: ports: - port: 9090 targetPort: 9090 protocol: TCP name: metrics selector: app: myapp . ",
    "url": "/docs/k8s/componentes/service.html#service-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-모니터링"
  },"329": {
    "doc": "Service",
    "title": "Service vs Ingress",
    "content": "| 특징 | Service | Ingress | . | OSI 레이어 | L4 (Transport) | L7 (Application) | . | 로드 밸런싱 | 기본 로드 밸런싱 | 고급 로드 밸런싱 | . | SSL/TLS | 지원 안함 | 지원 | . | Path 기반 라우팅 | 지원 안함 | 지원 | . | Host 기반 라우팅 | 지원 안함 | 지원 | . | 사용 사례 | 내부 서비스 | 외부 웹 트래픽 | . ",
    "url": "/docs/k8s/componentes/service.html#service-vs-ingress",
    
    "relUrl": "/docs/k8s/componentes/service.html#service-vs-ingress"
  },"330": {
    "doc": "Service",
    "title": "주의사항",
    "content": ". | 포트 매핑: Service 포트와 Pod 포트를 올바르게 매핑해야 합니다 | 세션 어피니티: 필요한 경우 세션 어피니티를 설정해야 합니다 | 네트워크 정책: 보안을 위해 NetworkPolicy를 설정해야 합니다 | 모니터링: Service의 상태와 성능을 지속적으로 모니터링해야 합니다 | DNS 캐싱: DNS 캐싱으로 인한 문제를 고려해야 합니다 | . ",
    "url": "/docs/k8s/componentes/service.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/service.html#주의사항"
  },"331": {
    "doc": "Service",
    "title": "Service",
    "content": " ",
    "url": "/docs/k8s/componentes/service.html",
    
    "relUrl": "/docs/k8s/componentes/service.html"
  },"332": {
    "doc": "ServiceAccount",
    "title": "ServiceAccount",
    "content": " ",
    "url": "/docs/k8s/componentes/serviceaccount.html",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html"
  },"333": {
    "doc": "ServiceAccount",
    "title": "개요",
    "content": "ServiceAccount는 Kubernetes에서 Pod가 클러스터 내에서 인증할 때 사용하는 계정입니다. Pod가 API 서버와 통신하거나 다른 서비스에 접근할 때 필요한 권한을 제공합니다. 주요 특징 . | Pod 인증: Pod가 Kubernetes API 서버에 인증할 때 사용 | 자동 마운트: Pod에 자동으로 토큰과 인증서 마운트 | 네임스페이스 스코프: 기본적으로 네임스페이스 내에서만 유효 | RBAC 연동: Role/ClusterRole과 결합하여 세밀한 권한 제어 | 토큰 기반: JWT 토큰을 통한 인증 | . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#개요"
  },"334": {
    "doc": "ServiceAccount",
    "title": "구조",
    "content": "graph TB subgraph \"ServiceAccount\" SA[ServiceAccount] SA --&gt; Token[토큰 생성] Token --&gt; Mount[Pod에 마운트] end subgraph \"Pod\" Pod[Pod] Mount --&gt; Pod Pod --&gt; API[API 서버] end subgraph \"RBAC\" RB[RoleBinding] RB --&gt; SA RB --&gt; Role[Role/ClusterRole] end API --&gt; Auth[인증] Auth --&gt; RB . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#구조"
  },"335": {
    "doc": "ServiceAccount",
    "title": "예시",
    "content": "기본 ServiceAccount . apiVersion: v1 kind: ServiceAccount metadata: name: my-app-sa namespace: default . Pod에서 ServiceAccount 사용 . apiVersion: v1 kind: Pod metadata: name: my-pod spec: serviceAccountName: my-app-sa containers: - name: my-container image: nginx:1.14.2 ports: - containerPort: 80 . RBAC과 결합 . # ServiceAccount 생성 apiVersion: v1 kind: ServiceAccount metadata: name: app-sa namespace: default --- # Role 생성 apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: app-role rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\", \"watch\"] --- # RoleBinding 생성 apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: app-binding namespace: default subjects: - kind: ServiceAccount name: app-sa namespace: default roleRef: kind: Role name: app-role apiGroup: rbac.authorization.k8s.io . 클러스터 레벨 권한 . # ClusterRole 생성 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: cluster-reader rules: - apiGroups: [\"\"] resources: [\"pods\", \"services\"] verbs: [\"get\", \"list\", \"watch\"] --- # ClusterRoleBinding 생성 apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: cluster-reader-binding subjects: - kind: ServiceAccount name: cluster-reader-sa namespace: default roleRef: kind: ClusterRole name: cluster-reader apiGroup: rbac.authorization.k8s.io . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#예시"
  },"336": {
    "doc": "ServiceAccount",
    "title": "ServiceAccount 타입",
    "content": "| 타입 | 설명 | 사용 사례 | . | 기본 ServiceAccount | 네임스페이스별로 자동 생성 | 모든 Pod에 기본 제공 | . | 애플리케이션 ServiceAccount | 특정 애플리케이션용 | 마이크로서비스별 권한 분리 | . | 시스템 ServiceAccount | 시스템 컴포넌트용 | kube-system 네임스페이스 | . | 관리자 ServiceAccount | 관리 작업용 | 클러스터 관리 도구 | . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#serviceaccount-%ED%83%80%EC%9E%85",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#serviceaccount-타입"
  },"337": {
    "doc": "ServiceAccount",
    "title": "관리 명령어",
    "content": "ServiceAccount 생성 . # 기본 ServiceAccount 생성 kubectl create serviceaccount my-sa # YAML 파일로 생성 kubectl apply -f serviceaccount.yaml # 네임스페이스 지정 kubectl create serviceaccount my-sa -n my-namespace . ServiceAccount 조회 . # ServiceAccount 목록 조회 kubectl get serviceaccounts # 특정 ServiceAccount 상세 정보 kubectl describe serviceaccount my-sa # YAML 형태로 출력 kubectl get serviceaccount my-sa -o yaml . ServiceAccount 삭제 . # ServiceAccount 삭제 kubectl delete serviceaccount my-sa # 네임스페이스 지정 kubectl delete serviceaccount my-sa -n my-namespace . 토큰 관리 . # ServiceAccount 토큰 생성 kubectl create token my-sa # 토큰 만료 시간 지정 kubectl create token my-sa --duration=1h # 토큰 정보 확인 kubectl get secret my-sa-token-xxxxx -o yaml . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#관리-명령어"
  },"338": {
    "doc": "ServiceAccount",
    "title": "사용 사례",
    "content": "1. 마이크로서비스 권한 분리 . # 각 서비스별 ServiceAccount apiVersion: v1 kind: ServiceAccount metadata: name: frontend-sa namespace: frontend --- apiVersion: v1 kind: ServiceAccount metadata: name: backend-sa namespace: backend --- apiVersion: v1 kind: ServiceAccount metadata: name: database-sa namespace: database . 2. CI/CD 파이프라인 . apiVersion: v1 kind: ServiceAccount metadata: name: ci-cd-sa namespace: ci-cd . 3. 모니터링 시스템 . apiVersion: v1 kind: ServiceAccount metadata: name: monitoring-sa namespace: monitoring . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#사용-사례"
  },"339": {
    "doc": "ServiceAccount",
    "title": "보안 고려사항",
    "content": "1. 최소 권한 원칙 . # 필요한 최소 권한만 부여 apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: default name: minimal-role rules: - apiGroups: [\"\"] resources: [\"pods\"] verbs: [\"get\", \"list\"] resourceNames: [\"specific-pod\"] . 2. 토큰 보안 . # 토큰 자동 마운트 비활성화 apiVersion: v1 kind: ServiceAccount metadata: name: no-token-sa automountServiceAccountToken: false . 3. 네임스페이스 격리 . # 네임스페이스별 ServiceAccount 분리 apiVersion: v1 kind: ServiceAccount metadata: name: app-sa namespace: app-namespace . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EB%B3%B4%EC%95%88-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#보안-고려사항"
  },"340": {
    "doc": "ServiceAccount",
    "title": "모니터링",
    "content": "ServiceAccount 사용량 확인 . # ServiceAccount별 Pod 수 확인 kubectl get pods --all-namespaces -o jsonpath='{range .items[*]}{.spec.serviceAccountName}{\"\\n\"}{end}' | sort | uniq -c # 토큰 사용량 확인 kubectl get secrets --all-namespaces | grep token . 권한 확인 . # ServiceAccount 권한 확인 kubectl auth can-i --as=system:serviceaccount:default:my-sa get pods # 특정 네임스페이스에서 권한 확인 kubectl auth can-i --as=system:serviceaccount:default:my-sa --namespace=kube-system get pods . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#모니터링"
  },"341": {
    "doc": "ServiceAccount",
    "title": "ServiceAccount vs User",
    "content": "| 특징 | ServiceAccount | User | . | 스코프 | 네임스페이스 | 클러스터 | . | 생성 | 자동/수동 | 외부 시스템 | . | 토큰 | 자동 생성 | 수동 관리 | . | 권한 | RBAC 기반 | RBAC 기반 | . | 사용 | Pod 인증 | 사용자 인증 | . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#serviceaccount-vs-user",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#serviceaccount-vs-user"
  },"342": {
    "doc": "ServiceAccount",
    "title": "주의사항",
    "content": "1. 토큰 보안 . | ServiceAccount 토큰은 민감한 정보 | 토큰 만료 시간 설정 권장 | 불필요한 토큰 자동 마운트 비활성화 | . 2. 권한 관리 . | 최소 권한 원칙 적용 | 정기적인 권한 검토 | 네임스페이스별 권한 분리 | . 3. 네이밍 규칙 . | 명확하고 일관된 이름 사용 | 팀/프로젝트별 접두사 사용 | 환경별 구분 | . 4. 리소스 정리 . | 사용하지 않는 ServiceAccount 정리 | 관련 Role/RoleBinding 함께 삭제 | 정기적인 리소스 정리 | . ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#주의사항"
  },"343": {
    "doc": "ServiceAccount",
    "title": "결론",
    "content": "ServiceAccount는 Kubernetes에서 Pod의 인증과 권한 관리를 위한 핵심 컴포넌트입니다. RBAC과 결합하여 세밀한 권한 제어가 가능하며, 마이크로서비스 아키텍처에서 각 서비스별 권한 분리를 구현할 수 있습니다. 보안을 고려한 적절한 권한 설정과 정기적인 관리가 중요합니다. ",
    "url": "/docs/k8s/componentes/serviceaccount.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/k8s/componentes/serviceaccount.html#결론"
  },"344": {
    "doc": "StatefulSet",
    "title": "StatefulSet 개요",
    "content": "StatefulSet은 Kubernetes에서 상태가 있는 애플리케이션을 관리하기 위한 워크로드 리소스입니다. Deployment와 달리 StatefulSet은 각 Pod에 고유한 식별자를 제공하고, 순서대로 배포 및 확장됩니다. StatefulSet의 특징 . | 고유한 네트워크 식별자: 각 Pod는 고유한 DNS 이름을 가집니다 | 순서가 있는 배포: Pod는 순서대로 생성되고 삭제됩니다 | 안정적인 스토리지: 각 Pod는 고유한 PersistentVolumeClaim을 가집니다 | 순서가 있는 확장: 확장 시에도 순서를 유지합니다 | . ",
    "url": "/docs/k8s/componentes/statefulset.html#statefulset-%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#statefulset-개요"
  },"345": {
    "doc": "StatefulSet",
    "title": "StatefulSet 구조",
    "content": "graph TD A[StatefulSet Controller] --&gt; B[Pod 0] A --&gt; C[Pod 1] A --&gt; D[Pod 2] B --&gt; E[PVC-0] C --&gt; F[PVC-1] D --&gt; G[PVC-2] B --&gt; H[app-0.example.com] C --&gt; I[app-1.example.com] D --&gt; J[app-2.example.com] style A fill:#e1f5fe style B fill:#f3e5f5 style C fill:#f3e5f5 style D fill:#f3e5f5 style E fill:#e8f5e8 style F fill:#e8f5e8 style G fill:#e8f5e8 . ",
    "url": "/docs/k8s/componentes/statefulset.html#statefulset-%EA%B5%AC%EC%A1%B0",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#statefulset-구조"
  },"346": {
    "doc": "StatefulSet",
    "title": "StatefulSet 예시",
    "content": "기본 StatefulSet 정의 . apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: serviceName: \"nginx\" replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [\"ReadWriteOnce\"] resources: requests: storage: 1Gi . Headless Service 정의 . apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - port: 80 name: web clusterIP: None selector: app: nginx . ",
    "url": "/docs/k8s/componentes/statefulset.html#statefulset-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#statefulset-예시"
  },"347": {
    "doc": "StatefulSet",
    "title": "StatefulSet vs Deployment",
    "content": "| 특징 | StatefulSet | Deployment | . | Pod 식별자 | 고유한 이름 (web-0, web-1, …) | 임의의 이름 | . | 스토리지 | 각 Pod마다 고유한 PVC | 공유 스토리지 | . | 네트워크 | 고유한 DNS 이름 | 공통 서비스 이름 | . | 확장 순서 | 순서대로 확장/축소 | 무작위 순서 | . | 용도 | 데이터베이스, 메시징 시스템 | 웹 애플리케이션 | . ",
    "url": "/docs/k8s/componentes/statefulset.html#statefulset-vs-deployment",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#statefulset-vs-deployment"
  },"348": {
    "doc": "StatefulSet",
    "title": "StatefulSet 사용 사례",
    "content": "1. 데이터베이스 (MySQL, PostgreSQL) . apiVersion: apps/v1 kind: StatefulSet metadata: name: mysql spec: serviceName: mysql replicas: 3 selector: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - name: mysql image: mysql:8.0 env: - name: MYSQL_ROOT_PASSWORD value: \"password\" ports: - containerPort: 3306 volumeMounts: - name: mysql-data mountPath: /var/lib/mysql volumeClaimTemplates: - metadata: name: mysql-data spec: accessModes: [\"ReadWriteOnce\"] resources: requests: storage: 10Gi . 2. 메시징 시스템 (RabbitMQ) . apiVersion: apps/v1 kind: StatefulSet metadata: name: rabbitmq spec: serviceName: rabbitmq replicas: 3 selector: matchLabels: app: rabbitmq template: metadata: labels: app: rabbitmq spec: containers: - name: rabbitmq image: rabbitmq:3-management ports: - containerPort: 5672 - containerPort: 15672 volumeMounts: - name: rabbitmq-data mountPath: /var/lib/rabbitmq volumeClaimTemplates: - metadata: name: rabbitmq-data spec: accessModes: [\"ReadWriteOnce\"] resources: requests: storage: 5Gi . ",
    "url": "/docs/k8s/componentes/statefulset.html#statefulset-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#statefulset-사용-사례"
  },"349": {
    "doc": "StatefulSet",
    "title": "StatefulSet 관리 명령어",
    "content": "# StatefulSet 생성 kubectl apply -f statefulset.yaml # StatefulSet 상태 확인 kubectl get statefulset kubectl describe statefulset web # Pod 확인 (순서대로 생성됨) kubectl get pods -l app=nginx # StatefulSet 확장 kubectl scale statefulset web --replicas=5 # StatefulSet 삭제 kubectl delete statefulset web # 특정 Pod만 삭제 (자동으로 재생성됨) kubectl delete pod web-1 . ",
    "url": "/docs/k8s/componentes/statefulset.html#statefulset-%EA%B4%80%EB%A6%AC-%EB%AA%85%EB%A0%B9%EC%96%B4",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#statefulset-관리-명령어"
  },"350": {
    "doc": "StatefulSet",
    "title": "StatefulSet의 네트워크 식별자",
    "content": "StatefulSet의 각 Pod는 다음과 같은 DNS 이름을 가집니다: . | Pod DNS: web-0.nginx.default.svc.cluster.local | Pod DNS: web-1.nginx.default.svc.cluster.local | Pod DNS: web-2.nginx.default.svc.cluster.local | . 이를 통해 각 Pod는 고유한 네트워크 식별자를 가지게 되어, 클러스터 내에서 안정적인 통신이 가능합니다. ",
    "url": "/docs/k8s/componentes/statefulset.html#statefulset%EC%9D%98-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%8B%9D%EB%B3%84%EC%9E%90",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#statefulset의-네트워크-식별자"
  },"351": {
    "doc": "StatefulSet",
    "title": "주의사항",
    "content": ". | 스토리지 비용: 각 Pod마다 별도의 PVC가 생성되므로 스토리지 비용이 증가할 수 있습니다. | 복잡성: Deployment보다 복잡한 설정이 필요합니다. | 순서 의존성: Pod가 순서대로 생성되므로 초기 배포 시간이 길어질 수 있습니다. | 스케일링 제한: 축소 시에도 순서를 지켜야 하므로 즉시 축소되지 않을 수 있습니다. | . ",
    "url": "/docs/k8s/componentes/statefulset.html#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html#주의사항"
  },"352": {
    "doc": "StatefulSet",
    "title": "StatefulSet",
    "content": " ",
    "url": "/docs/k8s/componentes/statefulset.html",
    
    "relUrl": "/docs/k8s/componentes/statefulset.html"
  },"353": {
    "doc": "TCP vs UDP",
    "title": "TCP vs UDP",
    "content": " ",
    "url": "/docs/network/tcp-udp.html",
    
    "relUrl": "/docs/network/tcp-udp.html"
  },"354": {
    "doc": "TCP vs UDP",
    "title": "개요",
    "content": "TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 인터넷에서 데이터를 전송하는 두 가지 주요 전송 계층 프로토콜입니다. 각각의 특성과 사용 사례가 다르며, 애플리케이션의 요구사항에 따라 적절한 프로토콜을 선택해야 합니다. ",
    "url": "/docs/network/tcp-udp.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/network/tcp-udp.html#개요"
  },"355": {
    "doc": "TCP vs UDP",
    "title": "프로토콜 비교",
    "content": "graph TB subgraph \"TCP (Transmission Control Protocol)\" A[연결 지향적] B[신뢰성 보장] C[순서 보장] D[흐름 제어] E[혼잡 제어] F[오버헤드 높음] end subgraph \"UDP (User Datagram Protocol)\" G[비연결형] H[신뢰성 없음] I[순서 보장 없음] J[흐름 제어 없음] K[혼잡 제어 없음] L[오버헤드 낮음] end . ",
    "url": "/docs/network/tcp-udp.html#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/network/tcp-udp.html#프로토콜-비교"
  },"356": {
    "doc": "TCP vs UDP",
    "title": "TCP (Transmission Control Protocol)",
    "content": "TCP의 특징 . graph LR A[연결 설정] --&gt; B[데이터 전송] B --&gt; C[연결 종료] subgraph \"신뢰성 보장\" D[재전송] E[순서 보장] F[흐름 제어] end . 1. 연결 지향적 (Connection-Oriented) . | 통신 전에 연결을 설정 (3-Way Handshake) | 통신 후 연결을 종료 (4-Way Handshake) | 양방향 통신 지원 | . 2. 신뢰성 보장 . | 데이터 손실 감지 및 재전송 | 체크섬을 통한 데이터 무결성 검증 | ACK(Acknowledgment)를 통한 수신 확인 | . 3. 순서 보장 . | 시퀀스 번호를 통한 패킷 순서 관리 | 순서가 바뀐 패킷을 올바른 순서로 재조립 | . 4. 흐름 제어 (Flow Control) . | 수신자의 처리 능력을 고려한 데이터 전송 속도 조절 | 슬라이딩 윈도우 기법 사용 | . 5. 혼잡 제어 (Congestion Control) . | 네트워크 상황에 따른 전송 속도 조절 | 네트워크 혼잡을 방지 | . TCP 헤더 구조 . graph LR subgraph \"TCP 헤더 (20-60 bytes)\" A[Source Port&lt;br/&gt;16 bits] B[Destination Port&lt;br/&gt;16 bits] C[Sequence Number&lt;br/&gt;32 bits] D[Acknowledgment Number&lt;br/&gt;32 bits] E[Data Offset&lt;br/&gt;4 bits] F[Reserved&lt;br/&gt;6 bits] G[Flags&lt;br/&gt;6 bits] H[Window Size&lt;br/&gt;16 bits] I[Checksum&lt;br/&gt;16 bits] J[Urgent Pointer&lt;br/&gt;16 bits] K[Options&lt;br/&gt;0-40 bytes] end . TCP 상태 머신 . stateDiagram-v2 [*] --&gt; CLOSED CLOSED --&gt; LISTEN : 서버 시작 CLOSED --&gt; SYN_SENT : 클라이언트 연결 요청 SYN_SENT --&gt; ESTABLISHED : SYN+ACK 수신 후 ACK 전송 LISTEN --&gt; SYN_RECEIVED : SYN 수신 SYN_RECEIVED --&gt; ESTABLISHED : ACK 수신 ESTABLISHED --&gt; FIN_WAIT_1 : FIN 전송 ESTABLISHED --&gt; CLOSE_WAIT : FIN 수신 FIN_WAIT_1 --&gt; FIN_WAIT_2 : ACK 수신 FIN_WAIT_2 --&gt; TIME_WAIT : FIN 수신 CLOSE_WAIT --&gt; LAST_ACK : FIN 전송 LAST_ACK --&gt; CLOSED : ACK 수신 TIME_WAIT --&gt; CLOSED : 2MSL 대기 후 . TCP 사용 사례 . graph TB subgraph \"TCP 사용 사례\" A[웹 브라우징&lt;br/&gt;HTTP/HTTPS] B[이메일&lt;br/&gt;SMTP/POP3/IMAP] C[파일 전송&lt;br/&gt;FTP/SFTP] D[원격 접속&lt;br/&gt;SSH/Telnet] E[데이터베이스&lt;br/&gt;MySQL/PostgreSQL] end . ",
    "url": "/docs/network/tcp-udp.html#tcp-transmission-control-protocol",
    
    "relUrl": "/docs/network/tcp-udp.html#tcp-transmission-control-protocol"
  },"357": {
    "doc": "TCP vs UDP",
    "title": "UDP (User Datagram Protocol)",
    "content": "UDP의 특징 . graph LR A[데이터 전송] --&gt; B[완료] subgraph \"비연결형\" C[연결 설정 없음] D[연결 종료 없음] E[단방향 통신] end . 1. 비연결형 (Connectionless) . | 통신 전 연결 설정 과정 없음 | 각 패킷이 독립적으로 전송 | 빠른 전송 속도 | . 2. 신뢰성 없음 . | 데이터 손실에 대한 재전송 없음 | 수신 확인(ACK) 없음 | 애플리케이션에서 신뢰성 처리 | . 3. 순서 보장 없음 . | 패킷 순서가 바뀔 수 있음 | 애플리케이션에서 순서 처리 | . 4. 흐름 제어 없음 . | 수신자 처리 능력 고려하지 않음 | 전송 속도 제한 없음 | . 5. 혼잡 제어 없음 . | 네트워크 상황 고려하지 않음 | 네트워크 혼잡 가능성 | . UDP 헤더 구조 . graph LR subgraph \"UDP 헤더 (8 bytes)\" A[Source Port&lt;br/&gt;16 bits] B[Destination Port&lt;br/&gt;16 bits] C[Length&lt;br/&gt;16 bits] D[Checksum&lt;br/&gt;16 bits] end . UDP 사용 사례 . graph TB subgraph \"UDP 사용 사례\" A[실시간 스트리밍&lt;br/&gt;영상/음성] B[온라인 게임&lt;br/&gt;실시간 데이터] C[DNS 조회&lt;br/&gt;도메인 이름 해석] D[DHCP&lt;br/&gt;IP 주소 할당] E[SNMP&lt;br/&gt;네트워크 관리] end . ",
    "url": "/docs/network/tcp-udp.html#udp-user-datagram-protocol",
    
    "relUrl": "/docs/network/tcp-udp.html#udp-user-datagram-protocol"
  },"358": {
    "doc": "TCP vs UDP",
    "title": "상세 비교",
    "content": "1. 연결 방식 . sequenceDiagram participant Client as 클라이언트 participant Server as 서버 Note over Client,Server: TCP 연결 과정 Client-&gt;&gt;Server: SYN Server-&gt;&gt;Client: SYN+ACK Client-&gt;&gt;Server: ACK Note over Client,Server: 데이터 전송 Client-&gt;&gt;Server: 데이터 Server-&gt;&gt;Client: ACK Note over Client,Server: 연결 종료 Client-&gt;&gt;Server: FIN Server-&gt;&gt;Client: ACK Server-&gt;&gt;Client: FIN Client-&gt;&gt;Server: ACK Note over Client,Server: UDP 통신 Client-&gt;&gt;Server: 데이터 (연결 없음) Server-&gt;&gt;Client: 응답 (연결 없음) . 2. 데이터 전송 방식 . graph TB subgraph \"TCP 데이터 전송\" A[연결 설정] --&gt; B[데이터 전송] B --&gt; C[수신 확인] C --&gt; D[재전송 필요시] D --&gt; E[연결 종료] end subgraph \"UDP 데이터 전송\" F[데이터 전송] --&gt; G[완료] end . 3. 오버헤드 비교 . graph LR subgraph \"TCP 오버헤드\" A[연결 설정: 3 패킷] B[데이터 전송: N 패킷] C[수신 확인: N 패킷] D[연결 종료: 4 패킷] end subgraph \"UDP 오버헤드\" E[데이터 전송: N 패킷] end . ",
    "url": "/docs/network/tcp-udp.html#%EC%83%81%EC%84%B8-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/network/tcp-udp.html#상세-비교"
  },"359": {
    "doc": "TCP vs UDP",
    "title": "실제 사용 예시",
    "content": "1. 웹 브라우징 (TCP) . sequenceDiagram participant Browser as 웹 브라우저 participant WebServer as 웹 서버 Note over Browser,WebServer: TCP 연결 설정 Browser-&gt;&gt;WebServer: SYN WebServer-&gt;&gt;Browser: SYN+ACK Browser-&gt;&gt;WebServer: ACK Note over Browser,WebServer: HTTP 요청/응답 Browser-&gt;&gt;WebServer: HTTP GET /index.html WebServer-&gt;&gt;Browser: HTTP 200 OK + HTML 데이터 Note over Browser,WebServer: 연결 종료 Browser-&gt;&gt;WebServer: FIN WebServer-&gt;&gt;Browser: ACK WebServer-&gt;&gt;Browser: FIN Browser-&gt;&gt;WebServer: ACK . 2. 실시간 게임 (UDP) . sequenceDiagram participant GameClient as 게임 클라이언트 participant GameServer as 게임 서버 Note over GameClient,GameServer: UDP 통신 (연결 없음) GameClient-&gt;&gt;GameServer: 플레이어 위치 데이터 GameServer-&gt;&gt;GameClient: 다른 플레이어 정보 GameClient-&gt;&gt;GameServer: 액션 데이터 GameServer-&gt;&gt;GameClient: 게임 상태 업데이트 . 3. DNS 조회 (UDP) . sequenceDiagram participant Client as 클라이언트 participant DNSServer as DNS 서버 Note over Client,DNSServer: DNS 조회 (UDP) Client-&gt;&gt;DNSServer: DNS Query (www.example.com) DNSServer-&gt;&gt;Client: DNS Response (192.168.1.1) . ",
    "url": "/docs/network/tcp-udp.html#%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%98%88%EC%8B%9C",
    
    "relUrl": "/docs/network/tcp-udp.html#실제-사용-예시"
  },"360": {
    "doc": "TCP vs UDP",
    "title": "성능 비교",
    "content": "1. 속도 . graph LR A[UDP] --&gt; B[빠름&lt;br/&gt;연결 설정 없음&lt;br/&gt;오버헤드 적음] C[TCP] --&gt; D[상대적으로 느림&lt;br/&gt;연결 설정 필요&lt;br/&gt;오버헤드 많음] . 2. 신뢰성 . graph LR A[TCP] --&gt; B[높음&lt;br/&gt;재전송 보장&lt;br/&gt;순서 보장] C[UDP] --&gt; D[낮음&lt;br/&gt;재전송 없음&lt;br/&gt;순서 보장 없음] . 3. 리소스 사용량 . graph LR A[UDP] --&gt; B[적음&lt;br/&gt;연결 상태 관리 없음&lt;br/&gt;버퍼 적음] C[TCP] --&gt; D[많음&lt;br/&gt;연결 상태 관리&lt;br/&gt;버퍼 많음] . ",
    "url": "/docs/network/tcp-udp.html#%EC%84%B1%EB%8A%A5-%EB%B9%84%EA%B5%90",
    
    "relUrl": "/docs/network/tcp-udp.html#성능-비교"
  },"361": {
    "doc": "TCP vs UDP",
    "title": "프로토콜 선택 가이드",
    "content": "TCP를 선택해야 하는 경우 . graph TB subgraph \"TCP 선택 기준\" A[데이터 무결성이 중요한 경우] B[순서가 중요한 경우] C[신뢰성이 중요한 경우] D[대용량 데이터 전송] E[파일 전송] end . UDP를 선택해야 하는 경우 . graph TB subgraph \"UDP 선택 기준\" A[실시간성이 중요한 경우] B[속도가 중요한 경우] C[간단한 요청/응답] D[스트리밍 서비스] E[게임 데이터] end . ",
    "url": "/docs/network/tcp-udp.html#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%84%A0%ED%83%9D-%EA%B0%80%EC%9D%B4%EB%93%9C",
    
    "relUrl": "/docs/network/tcp-udp.html#프로토콜-선택-가이드"
  },"362": {
    "doc": "TCP vs UDP",
    "title": "결론",
    "content": "TCP와 UDP는 각각의 장단점이 있으며, 애플리케이션의 요구사항에 따라 적절한 프로토콜을 선택해야 합니다. TCP는 신뢰성이 중요한 웹 서비스, 파일 전송 등에 적합하고, UDP는 실시간성이 중요한 스트리밍, 게임 등에 적합합니다. 현대의 네트워크 애플리케이션에서는 두 프로토콜을 상황에 맞게 혼용하여 사용하는 경우가 많습니다. ",
    "url": "/docs/network/tcp-udp.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/network/tcp-udp.html#결론"
  },"363": {
    "doc": "Spring WebFlux",
    "title": "Spring WebFlux",
    "content": " ",
    "url": "/docs/spring/webflux.html",
    
    "relUrl": "/docs/spring/webflux.html"
  },"364": {
    "doc": "Spring WebFlux",
    "title": "개요",
    "content": "Spring WebFlux는 Spring Framework 5에서 도입된 반응형 웹 프레임워크로, 논블로킹 I/O와 리액티브 스트림을 기반으로 합니다. 이를 통해 고성능, 확장 가능한 웹 애플리케이션을 구축할 수 있으며, 특히 마이크로서비스 아키텍처에 적합합니다. WebFlux는 기존 Spring MVC와 함께 사용하거나 독립적으로 사용할 수 있습니다. 주요 특징 . 1. 반응형 프로그래밍 . | 리액티브 스트림을 기반으로 하며, 비동기 및 논블로킹 방식으로 데이터를 처리합니다. | Mono&lt;T&gt;와 Flux&lt;T&gt;를 통해 0개 또는 1개, 그리고 0개 이상의 요소를 처리합니다. | . 2. 논블로킹 I/O . | 쓰레드 풀을 효율적으로 사용하여 적은 수의 쓰레드로도 많은 요청을 처리할 수 있습니다. | 이벤트 루프 모델을 통해 높은 동시성을 달성합니다. | . 3. 서버 지원 . | Netty, Undertow, Servlet 컨테이너 등 다양한 서버를 지원합니다. | 각 서버의 특성에 맞는 최적화된 설정이 가능합니다. | . 4. WebClient . | 비동기 HTTP 요청을 위한 클라이언트 라이브러리를 제공합니다. | 리액티브 스트림 기반의 HTTP 클라이언트입니다. | . 5. Reactor . | 리액티브 프로그래밍을 위한 핵심 라이브러리인 Reactor를 사용합니다. | Project Reactor는 Reactive Streams 스펙의 구현체입니다. | . 장점 . 1. 높은 성능과 확장성 . | 많은 동시 요청을 처리할 수 있어 높은 트래픽 환경에 적합합니다. | 이벤트 루프 모델로 인해 스레드당 메모리 사용량이 적습니다. | . 2. 자원 효율성 . | 적은 수의 쓰레드로도 효율적인 처리가 가능하여 자원 사용을 최적화합니다. | 메모리 사용량이 낮아 대용량 트래픽 처리에 유리합니다. | . 3. 실시간 데이터 처리 . | 반응형 스트림을 통해 실시간 데이터를 효율적으로 처리할 수 있습니다. | Server-Sent Events, WebSocket 등을 통한 실시간 통신을 지원합니다. | . 단점 . 1. 복잡성 . | 기존의 동기 방식보다 학습 곡선이 높고, 디버깅이 어려울 수 있습니다. | 리액티브 프로그래밍 패러다임에 대한 이해가 필요합니다. | . 2. 호환성 . | 모든 서드파티 라이브러리와 호환되지 않을 수 있습니다. | 블로킹 작업이 포함된 기존 코드와의 통합이 복잡할 수 있습니다. | . 사용 예시 . | 실시간 데이터 스트리밍 서비스: 센서 데이터, 주식 시세 등 실시간 정보 전송 | 고성능 API 서버: 대용량 트래픽을 처리하는 REST API | 마이크로서비스 아키텍처: Spring Cloud Gateway의 기반 기술 | IoT 데이터 처리: 센서 데이터의 실시간 수집 및 처리 | 실시간 채팅 시스템: WebSocket을 통한 양방향 통신 | . ",
    "url": "/docs/spring/webflux.html#%EA%B0%9C%EC%9A%94",
    
    "relUrl": "/docs/spring/webflux.html#개요"
  },"365": {
    "doc": "Spring WebFlux",
    "title": "WebFlux vs Spring MVC",
    "content": "1. 아키텍처 비교 . graph TB subgraph \"Spring MVC (Synchronous)\" MVCClient[Client] --&gt; MVCServer[Tomcat/Jetty] MVCServer --&gt; MVCThread[Thread Pool] MVCThread --&gt; MVCController[Controller] MVCController --&gt; MVCService[Service] MVCService --&gt; MVCDB[Database] end subgraph \"Spring WebFlux (Asynchronous)\" FluxClient[Client] --&gt; FluxServer[Netty] FluxServer --&gt; FluxEventLoop[Event Loop] FluxEventLoop --&gt; FluxController[Controller] FluxController --&gt; FluxService[Service] FluxService --&gt; FluxDB[Database] end style MVCThread fill:#ffcccc style FluxEventLoop fill:#ccffcc . 2. 성능 특성 비교 . | 특성 | Spring MVC | Spring WebFlux | . | 스레드 모델 | Thread-per-request | Event Loop | . | 동시성 | 제한적 (스레드 풀 크기에 의존) | 높음 (이벤트 루프) | . | 메모리 사용량 | 높음 (스레드당 ~1MB) | 낮음 | . | 블로킹 작업 | 적합 | 부적합 | . | 학습 곡선 | 낮음 | 높음 | . | 기존 코드 호환성 | 높음 | 제한적 | . ",
    "url": "/docs/spring/webflux.html#webflux-vs-spring-mvc",
    
    "relUrl": "/docs/spring/webflux.html#webflux-vs-spring-mvc"
  },"366": {
    "doc": "Spring WebFlux",
    "title": "Reactive Streams 핵심 개념",
    "content": "1. Publisher, Subscriber, Subscription . graph LR Publisher[Publisher&lt;br/&gt;데이터 발행자] --&gt; Subscription[Subscription&lt;br/&gt;구독 관계] Subscription --&gt; Subscriber[Subscriber&lt;br/&gt;데이터 구독자] subgraph \"Reactive Streams\" Backpressure[Backpressure&lt;br/&gt;흐름 제어] Error[Error Handling&lt;br/&gt;에러 처리] Complete[Complete&lt;br/&gt;완료 신호] end Publisher --&gt; Backpressure Subscriber --&gt; Error Subscription --&gt; Complete . 2. Mono와 Flux . Mono - 단일 요소 스트림 . Mono는 0개 또는 1개의 요소를 발행하는 리액티브 스트림입니다. 주로 단일 결과를 반환하는 작업에 사용됩니다. graph TB subgraph \"Mono&lt;T&gt; - 단일 요소\" MonoEmpty[Mono.empty()&lt;br/&gt;0개 요소 - 완료] MonoJust[Mono.just(item)&lt;br/&gt;1개 요소 - 성공] MonoError[Mono.error()&lt;br/&gt;에러 발생] MonoDefer[Mono.defer()&lt;br/&gt;지연 실행] MonoFromCallable[Mono.fromCallable()&lt;br/&gt;Callable에서 생성] end subgraph \"Mono 생성 패턴\" MonoCreate[Mono.create()&lt;br/&gt;수동 생성] MonoFromSupplier[Mono.fromSupplier()&lt;br/&gt;Supplier에서 생성] MonoFromFuture[Mono.fromFuture()&lt;br/&gt;Future에서 생성] end style MonoJust fill:#e1f5fe style MonoError fill:#ffebee style MonoDefer fill:#f3e5f5 . Mono 사용 예제 . // 1. 기본 Mono 생성 Mono&lt;String&gt; mono1 = Mono.just(\"Hello World\"); Mono&lt;String&gt; mono2 = Mono.empty(); Mono&lt;String&gt; mono3 = Mono.error(new RuntimeException(\"Error\")); // 2. 지연 실행 Mono Mono&lt;String&gt; lazyMono = Mono.defer(() -&gt; { System.out.println(\"Executing...\"); return Mono.just(\"Lazy result\"); }); // 3. Callable에서 Mono 생성 Mono&lt;String&gt; callableMono = Mono.fromCallable(() -&gt; { // 복잡한 계산이나 I/O 작업 return \"Result from callable\"; }); // 4. Supplier에서 Mono 생성 Mono&lt;String&gt; supplierMono = Mono.fromSupplier(() -&gt; { return \"Result from supplier\"; }); // 5. 수동으로 Mono 생성 Mono&lt;String&gt; manualMono = Mono.create(sink -&gt; { // 비동기 작업 수행 CompletableFuture.runAsync(() -&gt; { try { Thread.sleep(1000); sink.success(\"Manual result\"); } catch (InterruptedException e) { sink.error(e); } }); }); . Mono 조작 메서드 . // 1. 변환 (map) Mono&lt;String&gt; original = Mono.just(\"Hello\"); Mono&lt;String&gt; transformed = original.map(str -&gt; str + \" World\"); // 2. 평면화 (flatMap) Mono&lt;User&gt; userMono = Mono.just(new User(\"john\")); Mono&lt;String&gt; emailMono = userMono.flatMap(user -&gt; Mono.just(user.getEmail())); // 3. 필터링 (filter) Mono&lt;Integer&gt; numberMono = Mono.just(10); Mono&lt;Integer&gt; filteredMono = numberMono.filter(n -&gt; n &gt; 5); // 4. 에러 처리 Mono&lt;String&gt; errorHandledMono = Mono.just(\"test\") .map(str -&gt; { if (str.equals(\"error\")) { throw new RuntimeException(\"Error occurred\"); } return str; }) .onErrorReturn(\"Default value\") .onErrorResume(throwable -&gt; Mono.just(\"Recovered\")); // 5. 타임아웃 처리 Mono&lt;String&gt; timeoutMono = Mono.just(\"Slow operation\") .delayElement(Duration.ofSeconds(5)) .timeout(Duration.ofSeconds(3)) .onErrorReturn(\"Timeout occurred\"); . Flux - 다중 요소 스트림 . Flux는 0개 이상의 요소를 발행하는 리액티브 스트림입니다. 여러 데이터를 순차적으로 처리할 때 사용됩니다. graph TB subgraph \"Flux&lt;T&gt; - 다중 요소\" FluxEmpty[Flux.empty()&lt;br/&gt;0개 요소] FluxJust[Flux.just(items)&lt;br/&gt;여러 요소] FluxRange[Flux.range(1,10)&lt;br/&gt;범위 생성] FluxInterval[Flux.interval()&lt;br/&gt;주기적 생성] FluxGenerate[Flux.generate()&lt;br/&gt;상태 기반 생성] end subgraph \"Flux 생성 패턴\" FluxCreate[Flux.create()&lt;br/&gt;수동 생성] FluxFromIterable[Flux.fromIterable()&lt;br/&gt;Iterable에서 생성] FluxFromStream[Flux.fromStream()&lt;br/&gt;Stream에서 생성] end style FluxJust fill:#e8f5e8 style FluxInterval fill:#fff3e0 style FluxGenerate fill:#fce4ec . Flux 사용 예제 . // 1. 기본 Flux 생성 Flux&lt;String&gt; flux1 = Flux.just(\"A\", \"B\", \"C\"); Flux&lt;Integer&gt; flux2 = Flux.range(1, 10); Flux&lt;Long&gt; flux3 = Flux.interval(Duration.ofSeconds(1)); // 2. Iterable에서 Flux 생성 List&lt;String&gt; list = Arrays.asList(\"Apple\", \"Banana\", \"Cherry\"); Flux&lt;String&gt; fluxFromList = Flux.fromIterable(list); // 3. Stream에서 Flux 생성 Flux&lt;Integer&gt; fluxFromStream = Flux.fromStream( Stream.of(1, 2, 3, 4, 5) ); // 4. 수동으로 Flux 생성 Flux&lt;String&gt; manualFlux = Flux.create(sink -&gt; { sink.next(\"First\"); sink.next(\"Second\"); sink.next(\"Third\"); sink.complete(); }); // 5. 상태 기반 Flux 생성 Flux&lt;Integer&gt; statefulFlux = Flux.generate( () -&gt; 0, // 초기 상태 (state, sink) -&gt; { if (state &lt; 5) { sink.next(state); return state + 1; } else { sink.complete(); return state; } } ); . Mono와 Flux의 차이점 . | 특성 | Mono | Flux | . | 요소 개수 | 0개 또는 1개 | 0개 이상 | . | 사용 사례 | 단일 결과 반환 | 다중 데이터 처리 | . | 완료 신호 | 항상 완료 | 완료 또는 무한 | . | 에러 처리 | 단일 에러 | 스트림 중단 | . | 백프레셔 | 단순함 | 복잡함 | . Mono와 Flux 변환 . // Flux에서 Mono로 변환 Flux&lt;String&gt; flux = Flux.just(\"A\", \"B\", \"C\"); Mono&lt;String&gt; firstElement = flux.next(); // 첫 번째 요소만 Mono&lt;List&lt;String&gt;&gt; allElements = flux.collectList(); // 모든 요소를 리스트로 // Mono에서 Flux로 변환 Mono&lt;String&gt; mono = Mono.just(\"Hello\"); Flux&lt;String&gt; fluxFromMono = mono.flux(); // 단일 요소를 Flux로 // Mono를 Flux로 확장 Mono&lt;List&lt;String&gt;&gt; listMono = Mono.just(Arrays.asList(\"A\", \"B\", \"C\")); Flux&lt;String&gt; expandedFlux = listMono.flatMapMany(Flux::fromIterable); . 실제 사용 사례 - Mono와 Flux 컨트롤러 . @RestController @RequestMapping(\"/api/reactive\") public class ReactiveExamplesController { private final UserService userService; public ReactiveExamplesController(UserService userService) { this.userService = userService; } // Mono 사용 예제 - 단일 사용자 조회 @GetMapping(\"/users/{id}\") public Mono&lt;User&gt; getUserById(@PathVariable String id) { return userService.findById(id) .doOnNext(user -&gt; log.info(\"Found user: {}\", user.getName())) .doOnError(error -&gt; log.error(\"Error finding user: {}\", error.getMessage())) .switchIfEmpty(Mono.error(new UserNotFoundException(id))); } // Mono 사용 예제 - 사용자 생성 @PostMapping(\"/users\") public Mono&lt;User&gt; createUser(@RequestBody User user) { return Mono.just(user) .filter(u -&gt; u.getEmail() != null &amp;&amp; !u.getEmail().isEmpty()) .flatMap(u -&gt; userService.save(u)) .doOnSuccess(savedUser -&gt; log.info(\"User created: {}\", savedUser.getId())) .doOnError(error -&gt; log.error(\"Error creating user: {}\", error.getMessage())); } // Flux 사용 예제 - 모든 사용자 조회 @GetMapping(\"/users\") public Flux&lt;User&gt; getAllUsers() { return userService.findAll() .filter(User::isActive) .doOnNext(user -&gt; log.debug(\"Processing user: {}\", user.getName())) .doOnComplete(() -&gt; log.info(\"All users processed\")); } // Flux 사용 예제 - 사용자 검색 @GetMapping(\"/users/search\") public Flux&lt;User&gt; searchUsers(@RequestParam String query) { return userService.findByEmailContaining(query) .take(10) // 최대 10개만 반환 .doOnNext(user -&gt; log.debug(\"Found matching user: {}\", user.getEmail())); } // Mono와 Flux 조합 예제 - 사용자 통계 @GetMapping(\"/users/stats\") public Mono&lt;UserStats&gt; getUserStats() { return userService.findAll() .collectList() .map(users -&gt; { long activeCount = users.stream().filter(User::isActive).count(); long inactiveCount = users.size() - activeCount; return new UserStats(users.size(), activeCount, inactiveCount); }); } // Flux 스트리밍 예제 - 실시간 사용자 이벤트 @GetMapping(value = \"/users/events\", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux&lt;ServerSentEvent&lt;UserEvent&gt;&gt; getUserEvents() { return Flux.interval(Duration.ofSeconds(2)) .flatMap(tick -&gt; userService.findRandomUser()) .map(user -&gt; ServerSentEvent.&lt;UserEvent&gt;builder() .id(String.valueOf(System.currentTimeMillis())) .event(\"user-activity\") .data(new UserEvent(user.getId(), \"User logged in\", Instant.now())) .build()) .take(10); // 10개 이벤트만 전송 } // Mono 에러 처리 예제 @GetMapping(\"/users/{id}/profile\") public Mono&lt;UserProfile&gt; getUserProfile(@PathVariable String id) { return userService.findById(id) .flatMap(user -&gt; userService.getUserProfile(user.getId())) .onErrorReturn(new UserProfile(id, \"Default Profile\")) .onErrorResume(UserNotFoundException.class, error -&gt; Mono.just(new UserProfile(id, \"Profile not found\"))); } // Flux 백프레셔 처리 예제 @GetMapping(\"/users/stream\") public Flux&lt;User&gt; streamUsers() { return userService.findAll() .onBackpressureBuffer(100) // 최대 100개 버퍼 .doOnNext(user -&gt; log.debug(\"Streaming user: {}\", user.getName())) .doOnError(error -&gt; log.error(\"Error in stream: {}\", error.getMessage())); } } . Mono와 Flux의 생명주기 . graph TB subgraph \"Mono 생명주기\" MonoStart[Mono 시작] --&gt; MonoSubscribe[구독] MonoSubscribe --&gt; MonoNext[요소 발행] MonoNext --&gt; MonoComplete[완료] MonoSubscribe --&gt; MonoError[에러] MonoError --&gt; MonoComplete end subgraph \"Flux 생명주기\" FluxStart[Flux 시작] --&gt; FluxSubscribe[구독] FluxSubscribe --&gt; FluxNext[요소 발행] FluxNext --&gt; FluxNext FluxNext --&gt; FluxComplete[완료] FluxSubscribe --&gt; FluxError[에러] FluxError --&gt; FluxComplete end style MonoNext fill:#e1f5fe style FluxNext fill:#e8f5e8 style MonoError fill:#ffebee style FluxError fill:#ffebee . ",
    "url": "/docs/spring/webflux.html#reactive-streams-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90",
    
    "relUrl": "/docs/spring/webflux.html#reactive-streams-핵심-개념"
  },"367": {
    "doc": "Spring WebFlux",
    "title": "WebFlux 이벤트 루프 모델",
    "content": "1. 이벤트 루프 동작 원리 . graph TB Request[HTTP Request] --&gt; EventLoop[Event Loop Thread] subgraph \"Event Loop Processing\" Accept[Accept Event&lt;br/&gt;연결 수락] Read[Read Event&lt;br/&gt;데이터 읽기] Process[Process Event&lt;br/&gt;비즈니스 로직] Write[Write Event&lt;br/&gt;응답 쓰기] end EventLoop --&gt; Accept Accept --&gt; Read Read --&gt; Process Process --&gt; Write Write --&gt; Response[HTTP Response] subgraph \"Non-blocking I/O\" NIO[NIO Channels] Selector[Selector&lt;br/&gt;이벤트 선택] Buffer[ByteBuffer&lt;br/&gt;데이터 버퍼] end EventLoop --&gt; NIO NIO --&gt; Selector Selector --&gt; Buffer . 2. 스레드 모델 . graph TB subgraph \"Event Loop Threads\" EL1[Event Loop 1] EL2[Event Loop 2] EL3[Event Loop 3] EL4[Event Loop 4] end subgraph \"Worker Threads\" WT1[Worker Thread 1] WT2[Worker Thread 2] WT3[Worker Thread 3] end Client[Client Requests] --&gt; EL1 Client --&gt; EL2 Client --&gt; EL3 Client --&gt; EL4 EL1 --&gt; WT1 EL2 --&gt; WT2 EL3 --&gt; WT3 EL4 --&gt; WT1 . ",
    "url": "/docs/spring/webflux.html#webflux-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EB%AA%A8%EB%8D%B8",
    
    "relUrl": "/docs/spring/webflux.html#webflux-이벤트-루프-모델"
  },"368": {
    "doc": "Spring WebFlux",
    "title": "WebFlux 컨트롤러 구현",
    "content": "1. 기본 컨트롤러 예제 . @RestController @RequestMapping(\"/api\") public class ReactiveController { private final UserService userService; public ReactiveController(UserService userService) { this.userService = userService; } // 단일 사용자 조회 @GetMapping(\"/users/{id}\") public Mono&lt;User&gt; getUser(@PathVariable String id) { return userService.findById(id) .switchIfEmpty(Mono.error(new UserNotFoundException(id))); } // 모든 사용자 조회 @GetMapping(\"/users\") public Flux&lt;User&gt; getAllUsers() { return userService.findAll() .filter(user -&gt; user.isActive()); } // 사용자 생성 @PostMapping(\"/users\") public Mono&lt;User&gt; createUser(@RequestBody User user) { return userService.save(user) .doOnSuccess(savedUser -&gt; log.info(\"User created: {}\", savedUser.getId())); } // 사용자 업데이트 @PutMapping(\"/users/{id}\") public Mono&lt;User&gt; updateUser(@PathVariable String id, @RequestBody User user) { return userService.findById(id) .flatMap(existingUser -&gt; { user.setId(id); return userService.save(user); }) .switchIfEmpty(Mono.error(new UserNotFoundException(id))); } // 사용자 삭제 @DeleteMapping(\"/users/{id}\") public Mono&lt;Void&gt; deleteUser(@PathVariable String id) { return userService.findById(id) .flatMap(user -&gt; userService.deleteById(id)) .switchIfEmpty(Mono.error(new UserNotFoundException(id))); } } . 2. 스트리밍 응답 예제 . @RestController @RequestMapping(\"/api/stream\") public class StreamingController { // Server-Sent Events (SSE) @GetMapping(value = \"/events\", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux&lt;ServerSentEvent&lt;String&gt;&gt; streamEvents() { return Flux.interval(Duration.ofSeconds(1)) .map(sequence -&gt; ServerSentEvent.&lt;String&gt;builder() .id(String.valueOf(sequence)) .event(\"periodic-event\") .data(\"SSE - \" + LocalTime.now().toString()) .build()); } // 실시간 데이터 스트리밍 @GetMapping(value = \"/data\", produces = MediaType.APPLICATION_NDJSON_VALUE) public Flux&lt;DataPoint&gt; streamData() { return Flux.interval(Duration.ofMillis(100)) .map(tick -&gt; new DataPoint( tick, Math.random() * 100, Instant.now() )) .take(100); // 100개 데이터 포인트만 전송 } // 파일 업로드 처리 @PostMapping(\"/upload\") public Mono&lt;String&gt; uploadFile(@RequestPart(\"file\") Flux&lt;DataBuffer&gt; file) { return file .map(dataBuffer -&gt; { // 파일 데이터 처리 byte[] bytes = new byte[dataBuffer.readableByteCount()]; dataBuffer.read(bytes); DataBufferUtils.release(dataBuffer); return bytes; }) .collectList() .map(bytesList -&gt; { // 전체 파일 데이터 조합 byte[] allBytes = bytesList.stream() .flatMapToInt(bytes -&gt; IntStream.range(0, bytes.length) .map(i -&gt; bytes[i])) .collect(ByteArrayOutputStream::new, (baos, b) -&gt; baos.write(b), (baos1, baos2) -&gt; baos1.write(baos2.toByteArray(), 0, baos2.size())) .toByteArray(); return \"File uploaded: \" + allBytes.length + \" bytes\"; }); } } . ",
    "url": "/docs/spring/webflux.html#webflux-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%EA%B5%AC%ED%98%84",
    
    "relUrl": "/docs/spring/webflux.html#webflux-컨트롤러-구현"
  },"369": {
    "doc": "Spring WebFlux",
    "title": "Reactive Service Layer",
    "content": "1. 서비스 구현 예제 . @Service public class ReactiveUserService { private final ReactiveUserRepository userRepository; private final ReactiveMongoTemplate mongoTemplate; public ReactiveUserService(ReactiveUserRepository userRepository, ReactiveMongoTemplate mongoTemplate) { this.userRepository = userRepository; this.mongoTemplate = mongoTemplate; } // 사용자 조회 public Mono&lt;User&gt; findById(String id) { return userRepository.findById(id) .doOnNext(user -&gt; log.debug(\"Found user: {}\", user.getEmail())) .doOnError(error -&gt; log.error(\"Error finding user: {}\", error.getMessage())); } // 사용자 검색 public Flux&lt;User&gt; findByEmailContaining(String email) { return userRepository.findByEmailContainingIgnoreCase(email) .filter(User::isActive) .take(10); // 최대 10개만 반환 } // 사용자 저장 public Mono&lt;User&gt; save(User user) { return Mono.just(user) .filter(u -&gt; u.getEmail() != null &amp;&amp; !u.getEmail().isEmpty()) .flatMap(u -&gt; { if (u.getId() == null) { u.setCreatedAt(Instant.now()); } u.setUpdatedAt(Instant.now()); return userRepository.save(u); }) .doOnSuccess(savedUser -&gt; log.info(\"User saved: {}\", savedUser.getEmail())) .doOnError(error -&gt; log.error(\"Error saving user: {}\", error.getMessage())); } // 사용자 삭제 public Mono&lt;Void&gt; deleteById(String id) { return userRepository.findById(id) .flatMap(user -&gt; userRepository.deleteById(id)) .doOnSuccess(v -&gt; log.info(\"User deleted: {}\", id)) .doOnError(error -&gt; log.error(\"Error deleting user: {}\", error.getMessage())); } // 복잡한 쿼리 예제 public Flux&lt;User&gt; findActiveUsersByAgeRange(int minAge, int maxAge) { Criteria criteria = Criteria.where(\"age\").gte(minAge).lte(maxAge) .and(\"active\").is(true); Query query = Query.query(criteria); query.with(Sort.by(Sort.Direction.DESC, \"createdAt\")); return mongoTemplate.find(query, User.class) .onBackpressureBuffer(100) // 백프레셔 처리 .doOnNext(user -&gt; log.debug(\"Found user in age range: {}\", user.getEmail())); } } . 2. 에러 처리 . @Component public class ReactiveErrorHandler { @ExceptionHandler(UserNotFoundException.class) public Mono&lt;ResponseEntity&lt;ErrorResponse&gt;&gt; handleUserNotFound( UserNotFoundException ex, ServerWebExchange exchange) { ErrorResponse error = new ErrorResponse( \"USER_NOT_FOUND\", ex.getMessage(), exchange.getRequest().getPath().value() ); return Mono.just(ResponseEntity.status(HttpStatus.NOT_FOUND) .body(error)); } @ExceptionHandler(ValidationException.class) public Mono&lt;ResponseEntity&lt;ErrorResponse&gt;&gt; handleValidation( ValidationException ex, ServerWebExchange exchange) { ErrorResponse error = new ErrorResponse( \"VALIDATION_ERROR\", ex.getMessage(), exchange.getRequest().getPath().value() ); return Mono.just(ResponseEntity.status(HttpStatus.BAD_REQUEST) .body(error)); } @ExceptionHandler(Exception.class) public Mono&lt;ResponseEntity&lt;ErrorResponse&gt;&gt; handleGeneric( Exception ex, ServerWebExchange exchange) { ErrorResponse error = new ErrorResponse( \"INTERNAL_ERROR\", \"An unexpected error occurred\", exchange.getRequest().getPath().value() ); return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR) .body(error)); } } . ",
    "url": "/docs/spring/webflux.html#reactive-service-layer",
    
    "relUrl": "/docs/spring/webflux.html#reactive-service-layer"
  },"370": {
    "doc": "Spring WebFlux",
    "title": "백프레셔 (Backpressure) 처리",
    "content": "1. 백프레셔 전략 . graph TB FastPublisher[빠른 Publisher] --&gt; SlowSubscriber[느린 Subscriber] subgraph \"Backpressure Strategies\" Buffer[onBackpressureBuffer&lt;br/&gt;버퍼링] Drop[onBackpressureDrop&lt;br/&gt;드롭] Error[onBackpressureError&lt;br/&gt;에러] Latest[onBackpressureLatest&lt;br/&gt;최신만 유지] end FastPublisher --&gt; Buffer FastPublisher --&gt; Drop FastPublisher --&gt; Error FastPublisher --&gt; Latest . 2. 백프레셔 처리 예제 . @Service public class BackpressureService { // 버퍼링 전략 public Flux&lt;String&gt; bufferStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureBuffer(1000) // 최대 1000개 버퍼 .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)); } // 드롭 전략 public Flux&lt;String&gt; dropStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureDrop(item -&gt; log.warn(\"Dropped item: {}\", item)) .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)); } // 에러 전략 public Flux&lt;String&gt; errorStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureError() .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)) .onErrorReturn(\"Error occurred due to backpressure\"); } // 최신만 유지 전략 public Flux&lt;String&gt; latestStrategy() { return Flux.interval(Duration.ofMillis(10)) .map(i -&gt; \"Item-\" + i) .onBackpressureLatest() .doOnNext(item -&gt; log.debug(\"Processing: {}\", item)); } } . ",
    "url": "/docs/spring/webflux.html#%EB%B0%B1%ED%94%84%EB%A0%88%EC%85%94-backpressure-%EC%B2%98%EB%A6%AC",
    
    "relUrl": "/docs/spring/webflux.html#백프레셔-backpressure-처리"
  },"371": {
    "doc": "Spring WebFlux",
    "title": "WebFlux 설정 및 최적화",
    "content": "1. application.yml 설정 . spring: webflux: base-path: /api static-path-pattern: /static/** # Netty 설정 netty: connection-timeout: 30s read-timeout: 30s write-timeout: 30s # 로깅 설정 logging: level: org.springframework.web.reactive: DEBUG reactor.netty: DEBUG io.netty: DEBUG # 메트릭 설정 management: endpoints: web: exposure: include: health,info,metrics,prometheus metrics: export: prometheus: enabled: true . 2. 성능 최적화 설정 . @Configuration public class WebFluxConfig { @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { return new NettyReactiveWebServerFactory() { @Override public WebServer getWebServer(HttpHandler httpHandler) { HttpServer httpServer = HttpServer.create() .port(8080) .option(ChannelOption.SO_BACKLOG, 1000) .option(ChannelOption.SO_REUSEADDR, true) .childOption(ChannelOption.SO_KEEPALIVE, true) .childOption(ChannelOption.TCP_NODELAY, true); return super.getWebServer(httpHandler); } }; } @Bean public WebFilter corsFilter() { return (exchange, chain) -&gt; { ServerHttpResponse response = exchange.getResponse(); response.getHeaders().add(\"Access-Control-Allow-Origin\", \"*\"); response.getHeaders().add(\"Access-Control-Allow-Methods\", \"GET,POST,PUT,DELETE,OPTIONS\"); response.getHeaders().add(\"Access-Control-Allow-Headers\", \"Content-Type,Authorization\"); return chain.filter(exchange); }; } } . ",
    "url": "/docs/spring/webflux.html#webflux-%EC%84%A4%EC%A0%95-%EB%B0%8F-%EC%B5%9C%EC%A0%81%ED%99%94",
    
    "relUrl": "/docs/spring/webflux.html#webflux-설정-및-최적화"
  },"372": {
    "doc": "Spring WebFlux",
    "title": "모니터링 및 관찰성",
    "content": "1. 메트릭 수집 . @Component public class WebFluxMetrics { private final MeterRegistry meterRegistry; public WebFluxMetrics(MeterRegistry meterRegistry) { this.meterRegistry = meterRegistry; } @EventListener public void handleHttpRequest(HttpRequestEvent event) { Timer.Sample sample = Timer.start(meterRegistry); event.getExchange().getResponse() .beforeCommit(() -&gt; { sample.stop(Timer.builder(\"http.server.requests\") .tag(\"method\", event.getMethod()) .tag(\"uri\", event.getUri()) .tag(\"status\", event.getStatus().toString()) .register(meterRegistry)); return Mono.empty(); }); } } . 2. 분산 추적 . @Component public class TracingFilter implements WebFilter { @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, WebFilterChain chain) { String traceId = generateTraceId(); String spanId = generateSpanId(); return chain.filter(exchange) .doFirst(() -&gt; { exchange.getAttributes().put(\"traceId\", traceId); exchange.getAttributes().put(\"spanId\", spanId); log.info(\"Request started - TraceId: {}, SpanId: {}, Path: {}\", traceId, spanId, exchange.getRequest().getPath()); }) .doFinally(signalType -&gt; { log.info(\"Request completed - TraceId: {}, SpanId: {}, Signal: {}\", traceId, spanId, signalType); }); } private String generateTraceId() { return UUID.randomUUID().toString(); } private String generateSpanId() { return UUID.randomUUID().toString().substring(0, 8); } } . ",
    "url": "/docs/spring/webflux.html#%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%B0%8F-%EA%B4%80%EC%B0%B0%EC%84%B1",
    
    "relUrl": "/docs/spring/webflux.html#모니터링-및-관찰성"
  },"373": {
    "doc": "Spring WebFlux",
    "title": "WebClient 사용법",
    "content": "1. WebClient 기본 사용법 . @RestController @RequestMapping(\"/api/client\") public class WebClientController { private final WebClient webClient; public WebClientController() { this.webClient = WebClient.builder() .baseUrl(\"https://api.example.com\") .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .defaultHeader(HttpHeaders.USER_AGENT, \"WebFlux-Client\") .build(); } // GET 요청 예제 @GetMapping(\"/users/{id}\") public Mono&lt;User&gt; getUser(@PathVariable String id) { return webClient.get() .uri(\"/users/{id}\", id) .retrieve() .bodyToMono(User.class) .doOnSuccess(user -&gt; log.info(\"User retrieved: {}\", user.getName())) .doOnError(error -&gt; log.error(\"Error retrieving user: {}\", error.getMessage())); } // POST 요청 예제 @PostMapping(\"/users\") public Mono&lt;User&gt; createUser(@RequestBody User user) { return webClient.post() .uri(\"/users\") .bodyValue(user) .retrieve() .bodyToMono(User.class) .doOnSuccess(savedUser -&gt; log.info(\"User created: {}\", savedUser.getId())); } // PUT 요청 예제 @PutMapping(\"/users/{id}\") public Mono&lt;User&gt; updateUser(@PathVariable String id, @RequestBody User user) { return webClient.put() .uri(\"/users/{id}\", id) .bodyValue(user) .retrieve() .bodyToMono(User.class); } // DELETE 요청 예제 @DeleteMapping(\"/users/{id}\") public Mono&lt;Void&gt; deleteUser(@PathVariable String id) { return webClient.delete() .uri(\"/users/{id}\", id) .retrieve() .bodyToMono(Void.class); } } . 2. WebClient 고급 기능 . @Component public class AdvancedWebClient { private final WebClient webClient; public AdvancedWebClient() { this.webClient = WebClient.builder() .baseUrl(\"https://api.example.com\") .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .filter((request, next) -&gt; { // 요청 로깅 log.info(\"Request: {} {}\", request.method(), request.url()); return next.exchange(request) .doOnNext(response -&gt; log.info(\"Response: {} {}\", response.statusCode(), request.url())); }) .filter(ExchangeFilterFunction.ofRequestProcessor(clientRequest -&gt; { // 인증 토큰 추가 return Mono.just(ClientRequest.from(clientRequest) .header(\"Authorization\", \"Bearer \" + getAuthToken()) .build()); })) .build(); } // 타임아웃 설정 public Mono&lt;User&gt; getUserWithTimeout(String id) { return webClient.get() .uri(\"/users/{id}\", id) .retrieve() .bodyToMono(User.class) .timeout(Duration.ofSeconds(5)) .onErrorMap(TimeoutException.class, ex -&gt; new RuntimeException(\"Request timeout\")); } // 재시도 로직 public Mono&lt;User&gt; getUserWithRetry(String id) { return webClient.get() .uri(\"/users/{id}\", id) .retrieve() .bodyToMono(User.class) .retryWhen(Retry.backoff(3, Duration.ofSeconds(1)) .filter(throwable -&gt; throwable instanceof WebClientResponseException) .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -&gt; new RuntimeException(\"Max retries exceeded\"))); } // 스트리밍 응답 처리 public Flux&lt;User&gt; streamUsers() { return webClient.get() .uri(\"/users/stream\") .retrieve() .bodyToFlux(User.class) .doOnNext(user -&gt; log.debug(\"Received user: {}\", user.getName())); } // 파일 업로드 public Mono&lt;String&gt; uploadFile(Flux&lt;DataBuffer&gt; fileData, String filename) { return webClient.post() .uri(\"/upload\") .contentType(MediaType.MULTIPART_FORM_DATA) .body(BodyInserters.fromMultipartData(\"file\", new HttpHeaders(), fileData)) .retrieve() .bodyToMono(String.class); } private String getAuthToken() { // 실제 구현에서는 토큰 관리 로직 return \"your-auth-token\"; } } . 3. WebClient 설정 . @Configuration public class WebClientConfig { @Bean public WebClient webClient() { return WebClient.builder() .baseUrl(\"https://api.example.com\") .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE) .codecs(configurer -&gt; configurer .defaultCodecs() .maxInMemorySize(2 * 1024 * 1024)) // 2MB .filter(ExchangeFilterFunction.ofRequestProcessor(clientRequest -&gt; { // 요청 전처리 return Mono.just(clientRequest); })) .filter(ExchangeFilterFunction.ofResponseProcessor(clientResponse -&gt; { // 응답 후처리 return Mono.just(clientResponse); })) .build(); } @Bean public HttpClient httpClient() { return HttpClient.create() .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000) .responseTimeout(Duration.ofSeconds(10)) .doOnConnected(conn -&gt; conn.addHandlerLast(new ReadTimeoutHandler(10)) .addHandlerLast(new WriteTimeoutHandler(10))); } } . ",
    "url": "/docs/spring/webflux.html#webclient-%EC%82%AC%EC%9A%A9%EB%B2%95",
    
    "relUrl": "/docs/spring/webflux.html#webclient-사용법"
  },"374": {
    "doc": "Spring WebFlux",
    "title": "실제 사용 사례",
    "content": "1. 실시간 채팅 시스템 . @RestController @RequestMapping(\"/chat\") public class ChatController { private final FluxSink&lt;ChatMessage&gt; messageSink; private final Flux&lt;ChatMessage&gt; messageFlux; public ChatController() { Flux&lt;ChatMessage&gt; flux = Flux.create(sink -&gt; { this.messageSink = sink; }); this.messageFlux = flux.publish().autoConnect(); } @PostMapping(\"/send\") public Mono&lt;Void&gt; sendMessage(@RequestBody ChatMessage message) { return Mono.fromRunnable(() -&gt; { message.setTimestamp(Instant.now()); messageSink.next(message); }); } @GetMapping(value = \"/messages\", produces = MediaType.TEXT_EVENT_STREAM_VALUE) public Flux&lt;ServerSentEvent&lt;ChatMessage&gt;&gt; getMessages() { return messageFlux .map(message -&gt; ServerSentEvent.&lt;ChatMessage&gt;builder() .data(message) .build()); } } . 2. 데이터 스트리밍 API . @RestController @RequestMapping(\"/stream\") public class DataStreamController { @GetMapping(value = \"/sensor-data\", produces = MediaType.APPLICATION_NDJSON_VALUE) public Flux&lt;SensorData&gt; streamSensorData() { return Flux.interval(Duration.ofMillis(100)) .map(tick -&gt; new SensorData( \"sensor-\" + (tick % 5), Math.random() * 100, Math.random() * 50, Instant.now() )) .onBackpressureBuffer(1000) .doOnNext(data -&gt; log.debug(\"Streaming sensor data: {}\", data)); } @PostMapping(\"/process-batch\") public Mono&lt;ProcessingResult&gt; processBatch(@RequestBody Flux&lt;DataItem&gt; items) { return items .buffer(100) // 100개씩 배치 처리 .flatMap(batch -&gt; processBatch(batch)) .collectList() .map(results -&gt; new ProcessingResult(results)); } } . ",
    "url": "/docs/spring/webflux.html#%EC%8B%A4%EC%A0%9C-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80",
    
    "relUrl": "/docs/spring/webflux.html#실제-사용-사례"
  },"375": {
    "doc": "Spring WebFlux",
    "title": "결론",
    "content": "Spring WebFlux는 현대적인 웹 애플리케이션에서 높은 성능과 확장성을 요구하는 시스템에 적합한 프레임워크입니다. 특히 다음과 같은 상황에서 큰 장점을 보입니다: . 적합한 사용 사례 . | 대용량 트래픽 처리: 이벤트 루프 모델로 높은 동시성 지원 | 실시간 데이터 스트리밍: Server-Sent Events, WebSocket 지원 | 마이크로서비스 게이트웨이: Spring Cloud Gateway의 기반 | IoT 데이터 처리: 센서 데이터의 실시간 처리 | 실시간 채팅 시스템: WebSocket을 통한 양방향 통신 | 고성능 API 서버: 대용량 트래픽을 처리하는 REST API | . 기술 선택 가이드 . WebFlux를 선택해야 하는 경우: . | 높은 동시성 요구: 초당 수만 개의 요청을 처리해야 하는 경우 | 실시간 데이터 처리: 실시간 스트리밍이나 이벤트 기반 아키텍처 | 마이크로서비스 환경: Spring Cloud Gateway와 함께 사용 | 메모리 효율성: 제한된 리소스 환경에서 최대 성능 필요 | . Spring MVC를 선택해야 하는 경우: . | 기존 코드베이스: 이미 동기식 코드로 구성된 프로젝트 | 간단한 CRUD 애플리케이션: 복잡한 비동기 처리가 필요 없는 경우 | 팀 역량: 리액티브 프로그래밍 경험이 부족한 팀 | 서드파티 라이브러리 의존성: 블로킹 라이브러리를 많이 사용하는 경우 | . 성능 고려사항 . graph TB subgraph \"성능 비교\" MVC[Spring MVC&lt;br/&gt;Thread-per-request] WebFlux[WebFlux&lt;br/&gt;Event Loop] end subgraph \"메모리 사용량\" MVCMemory[높음&lt;br/&gt;스레드당 ~1MB] WebFluxMemory[낮음&lt;br/&gt;이벤트 루프] end subgraph \"동시성\" MVCConcurrency[제한적&lt;br/&gt;스레드 풀 크기] WebFluxConcurrency[높음&lt;br/&gt;이벤트 루프] end MVC --&gt; MVCMemory WebFlux --&gt; WebFluxMemory MVC --&gt; MVCConcurrency WebFlux --&gt; WebFluxConcurrency . 학습 로드맵 . | 기초 단계 . | Reactive Streams 스펙 이해 | Mono와 Flux 개념 학습 | 기본적인 리액티브 프로그래밍 패턴 | . | 중급 단계 . | WebFlux 컨트롤러 구현 | WebClient 사용법 | 백프레셔 처리 방법 | . | 고급 단계 . | 복잡한 리액티브 스트림 조합 | 성능 최적화 및 모니터링 | 마이크로서비스 아키텍처 적용 | . | . 마이그레이션 전략 . 기존 Spring MVC 애플리케이션을 WebFlux로 마이그레이션할 때는 점진적 접근이 권장됩니다: . | 하이브리드 접근: MVC와 WebFlux를 함께 사용 | 새로운 기능: 새로운 기능은 WebFlux로 구현 | 점진적 전환: 기존 코드를 단계적으로 리팩토링 | 성능 테스트: 각 단계에서 성능 측정 및 검증 | . WebFlux의 학습 곡선이 높고, 모든 상황에서 적합하지 않을 수 있으므로, 프로젝트의 요구사항을 잘 분석하여 적절한 기술을 선택하는 것이 중요합니다. 특히 팀의 기술 역량과 프로젝트의 복잡성을 고려한 신중한 결정이 필요합니다. ",
    "url": "/docs/spring/webflux.html#%EA%B2%B0%EB%A1%A0",
    
    "relUrl": "/docs/spring/webflux.html#결론"
  }
}
